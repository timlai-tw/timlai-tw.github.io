<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>使用 Azure DevOps REST API 建立專案</title>
    <url>/post/2025/04/azure-devops-create-project/</url>
    <content><![CDATA[<img    
                       lazyload
                       alt="image"
                       data-src="/post/2025/04/azure-devops-create-project/create-project.png"
                         align="left" style="margin-right: 10px; width: 125px; border: 1px solid gray;"
                 > 
<p>要使用 Azure DevOps 各項功能之前，首先得先建立一個專案，同時必須選擇專案的版本控制是 <strong>TFVC</strong> (Team Fundation Version Control) 還是 <strong>git</strong>，以及專案要使用的流程範本 (Process template)，預設有 <strong>Basic / Agile / Scrum / CMMI</strong> 四種，這次我們就不透過網頁介面建立專案，直接使用 API 小試身手 🎣 。</p>
<br>
<span id="more"></span>
<br>
<h2 id="前言">前言</h2>
<p>當我們想要使用 <strong>Azure DevOps REST API</strong> 進行程式串接時，首先要確認使用情境是 <strong><code>雲端</code></strong> 還是 <strong><code>地端</code></strong>，因為兩者對於 API 的支援程度不盡相同，例如：<strong>Audit log</strong> 目前只有在雲端才能查詢、下載，地端還沒有支援，使用哪一版的 API 也要稍微留意(在<a href="/post/2024/09/azure-devops-rest-api">上一篇文章</a>有說明原因)，這些都可以在 API 說明頁面左上角透過下拉選單來快速切換檢視，以便我們確認 API 規格與差異。</p>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/04/azure-devops-create-project/version_dropdown.png"
                        class=""
                 >
<br>
<div class="tips">
<font color="black">
<a class="link"   href="https://learn.microsoft.com/en-us/rest/api/azure/devops/?view=azure-devops-rest-7.2"  target="_blank">⁍ Azure DevOps Services REST API Reference<i class="fas fa-external-link-alt"></i></a>
</font>
</div>
<br>
<h2 id="API-規格確認">API 規格確認</h2>
<p>經由上面的參考連結，我們可以在 <strong>Core &gt; Projects &gt; Create</strong> 找到建立專案的 API 規格：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">雲端</span><br><span class="line">POST https://dev.azure.com/&#123;organization&#125;/_apis/projects?api-version=7.2-preview.4</span><br></pre></td></tr></table></figure>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">地端</span><br><span class="line">POST https://&#123;instance&#125;/&#123;collection&#125;/_apis/projects?api-version=7.0</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/04/azure-devops-create-project/core_projects_create.png"
                        class=""
                 >
<br>
<p>在頁面上對於 Request Body 的屬性和型別宣告都會逐一說明，但唯一美中不足的是我們看不出來哪些屬性是必要項目(Required)，比較簡便的方式是可以使用 Postman 填入 PAT 驗證後進行測試，通常在 Reponse 都會告訴我們缺少什麼必要欄位值，Postman 設定步驟如下：</p>
<br>
<ol>
<li>Authorization 的 Auth Type 選擇 <strong><code>Basic Auth</code></strong>，並將 PAT 填入 Password 欄位，Username 空白即可。(如何建立 PAT 可以參考：<a href="/post/2024/09/azure-devops-rest-api">上一篇文章</a>)</li>
</ol>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/04/azure-devops-create-project/basic_auth.png"
                        class=""
                 >
<br>
<ol start="2">
<li>Headers 的 Content-Type 設定 <strong><code>application/json</code></strong>。</li>
</ol>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/04/azure-devops-create-project/content_type.png"
                        class=""
                 >
<br>
<ol start="3">
<li>Body 格式選擇 <strong><code>raw</code></strong> 和 <strong><code>JSON</code></strong>，內容先輸入 <strong><code>&#123;&#125;</code></strong> 然後按下 <strong><code>Send</code></strong> 按鈕。</li>
</ol>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/04/azure-devops-create-project/400_bad.png"
                        class=""
                 >
<br>
<p>由 message 回傳的資訊我們就可以得知，必要的屬性有：</p>
<ul>
<li><strong>name</strong> : 專案名稱</li>
<li><strong>description</strong>: 專案描述說明</li>
<li><strong>visibility</strong> : 專案可層級 (Public或Private，預設是Private)</li>
<li><strong>capabilities</strong> : 版控方式、流程範本是必要項目。</li>
</ul>
<p>完整的 Request Body 內容可以參考下列內容：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;MyNewProject&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;This is a new project created via API&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;capabilities&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;versioncontrol&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;sourceControlType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Git&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processTemplate&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;templateTypeId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;6b724908-ef14-45cf-84f8-768b5384da45&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<br>
<p>送出 Request 成功後，可以得到如下訊息：</p>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/04/azure-devops-create-project/202_accepted.png"
                        class=""
                 >
<br>
<p>開啟 Azure DevOps 畫面確認新增的專案是否有正常出現。</p>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/04/azure-devops-create-project/my_new_project.png"
                        class=""
                 >
<h2 id="流程範本-Process-template">流程範本 (Process template)</h2>
<p>在 Azure DevOps 預設有 <strong>Basic / Agile / Scrum / CMMI</strong> 四種流程範本，一般我本幾乎不會去關心它的 templateTypeId (GUID) 是什麼，這邊需要透過另一支查詢 Process template 列表的 API 來取得資訊：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">雲端</span><br><span class="line">GET GET https://dev.azure.com/&#123;organization&#125;/_apis/process/processes?api-version=7.2-preview.1</span><br></pre></td></tr></table></figure>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">地端</span><br><span class="line">GET https://&#123;instance&#125;/&#123;collection&#125;/_apis/process/processes?api-version=7.0</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;count&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;adcc42ab-9882-485e-a3ed-7678f01f66bc&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;This template is flexible and will work great for most teams using Agile planning methods, including those practicing Scrum.&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;system&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://devopssrv/DefaultCollection/_apis/process/processes/adcc42ab-9882-485e-a3ed-7678f01f66bc&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Agile&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;27450541-8e31-4150-9947-dc59f998fc01&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;This template is for more formal projects requiring a framework for process improvement and an auditable record of decisions.&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;system&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://devopssrv/DefaultCollection/_apis/process/processes/27450541-8e31-4150-9947-dc59f998fc01&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;CMMI&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;b8a3a935-7e91-48b8-a94c-606d37c3e9f2&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;This template is flexible for any process and great for teams getting started with Azure DevOps.&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;system&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://devopssrv/DefaultCollection/_apis/process/processes/b8a3a935-7e91-48b8-a94c-606d37c3e9f2&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Basic&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;6b724908-ef14-45cf-84f8-768b5384da45&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;This template is for teams who follow the Scrum framework.&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;system&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://devopssrv/DefaultCollection/_apis/process/processes/6b724908-ef14-45cf-84f8-768b5384da45&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Scrum&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="後記">後記</h2>
<p>再回過頭來看，其實我們上面做的這些動作就是以 API 的方式送出畫面上建立專案的必要欄位而已：</p>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/04/azure-devops-create-project/new_project.png"
                        class=""
                 >
<br>
<p>附帶一提，若是以 C# 實作，在 Header 傳遞 PAT 需要先以 <strong>Base64</strong> 編碼才行，可以參考下列完整範例呼叫範例(第31行)：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Net.Http;</span><br><span class="line"><span class="keyword">using</span> System.Net.Http.Headers;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> Newtonsoft.Json;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProcessTemplate</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="built_in">string</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">		<span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProcessTemplatesResponse</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">public</span> List&lt;ProcessTemplate&gt; Value &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">string</span> pat = <span class="string">&quot;...&quot;</span>;</span><br><span class="line">		<span class="built_in">string</span> serverName = <span class="string">&quot;...&quot;</span>;</span><br><span class="line">		<span class="built_in">string</span> collectionName = <span class="string">&quot;...&quot;</span>;</span><br><span class="line">		<span class="built_in">string</span> url = <span class="string">$&quot;http://<span class="subst">&#123;serverName&#125;</span>/<span class="subst">&#123;collectionName&#125;</span>/_apis/process/processes?api-version=7.0&quot;</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">using</span> (HttpClient client = <span class="keyword">new</span> HttpClient())</span><br><span class="line">		&#123;</span><br><span class="line">			client.DefaultRequestHeaders.Authorization = <span class="keyword">new</span> AuthenticationHeaderValue(<span class="string">&quot;Basic&quot;</span>, Convert.ToBase64String(Encoding.ASCII.GetBytes(<span class="string">$&quot;:<span class="subst">&#123;pat&#125;</span>&quot;</span>)));</span><br><span class="line">			HttpResponseMessage response = <span class="keyword">await</span> client.GetAsync(url);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (response.IsSuccessStatusCode)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">string</span> result = <span class="keyword">await</span> response.Content.ReadAsStringAsync();</span><br><span class="line">				<span class="keyword">var</span> processTemplates = JsonConvert.DeserializeObject&lt;ProcessTemplatesResponse&gt;(result);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">foreach</span> (<span class="keyword">var</span> process <span class="keyword">in</span> processTemplates.Value)</span><br><span class="line">				&#123;</span><br><span class="line">					Console.WriteLine(<span class="string">$&quot;Name: <span class="subst">&#123;process.Name&#125;</span>, ID: <span class="subst">&#123;process.Id&#125;</span>&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				Console.WriteLine(<span class="string">$&quot;Failed to get process templates: <span class="subst">&#123;response.StatusCode&#125;</span>&quot;</span>);</span><br><span class="line">				<span class="built_in">string</span> error = <span class="keyword">await</span> response.Content.ReadAsStringAsync();</span><br><span class="line">				Console.WriteLine(error);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<div class="tips">
<font color="black">
<a class="link"   href="https://learn.microsoft.com/zh-tw/azure/devops/integrate/how-to/call-rest-api?view=azure-devops"  target="_blank">⁍ 開始使用 REST API
<i class="fas fa-external-link-alt"></i></a>
</font>
</div>]]></content>
      <tags>
        <tag>Azure DevOps</tag>
        <tag>Azure DevOps REST API</tag>
      </tags>
  </entry>
  <entry>
    <title>Agent AI 與 Agentic AI 的差別</title>
    <url>/post/2025/12/agent-ai-and-agentic-ai/</url>
    <content><![CDATA[<img    
                       lazyload
                       alt="image"
                       data-src="/post/2025/12/agent-ai-and-agentic-ai/agentic-ai.jpg"
                         align="left" style="margin-right: 10px; width: 125px; border: 1px solid gray;"
                 >
<p>今年大家應該蠻常聽到 <strong>Agent AI</strong> 和 <strong>Agentic AI</strong> 這兩個詞，名稱看起來很像、都有「Agent」，但實際上指的東西不太一樣：一個是「單一代理」的能力，另一個則是「多代理系統」的整體架構。本篇文章以比較白話的比喻來整理兩者的差異，以及 Microsoft 在 Agentic AI 上目前提供的幾種主要解決方案：<strong>Copilot Studio / Azure AI Foundry Agent Service / Microsoft Agent Framework / Semantic Kernel</strong>，方便大家選擇適合自己的開發路線。</p>
<span id="more"></span>
<br>
<h2 id="什麼是-AI-Agent？什麼是-Agentic-AI？">什麼是 AI Agent？什麼是 Agentic AI？</h2>
<p>先用一句話來區分：</p>
<ul>
<li><strong>AI Agent</strong> 比較像是一位「可以自己想辦法完成任務的助手」。</li>
<li><strong>Agentic AI</strong> 則是一個「由很多專業助手組成的團隊」，可以協調分工、一起完成一個複雜目標。</li>
</ul>
<br>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/12/agent-ai-and-agentic-ai/AI-Agent-vs-Agentic-AI.jpg"
                        class=""
                 >
<br>
<h3 id="AI-Agent：會自己用工具的智慧助手">AI Agent：會自己用工具的智慧助手</h3>
<p>一般我們說的 <strong>AI Agent（AI 代理）</strong>，指的是一個以 LLM 為核心、能夠：</p>
<ul>
<li>讀懂使用者的目標。</li>
<li>規劃完成任務需要的步驟。</li>
<li>在過程中主動呼叫工具。</li>
<li>根據工具回傳結果調整接下來要做什麼。</li>
</ul>
<p>也就是說，它不再只是單純回覆文字，而是會「自己動手做事」，例如：</p>
<ul>
<li>我們請它「幫我彙整一份這週專案進度並寄信給主管」，它會：
<ol>
<li>先去查專案系統的狀態（例如：Azure DevOps MCP）。</li>
<li>整理成文字報告。</li>
<li>呼叫工具寄信送出（例如：API 或 Microsoft Team Webhook)。</li>
</ol>
</li>
</ul>
<p>這整個流程都是由一個 Agent 自己掌握、自己決定何時呼叫哪一個工具。</p>
<h3 id="Agentic-AI：多代理協作的系統">Agentic AI：多代理協作的系統</h3>
<p><strong>Agentic AI（代理式 AI）</strong> 則是把「多個 Agent」組織成一個協作系統，讓它們可以彼此溝通、分工合作，來處理一個單一 Agent 很難搞定的複雜任務。例如：</p>
<ul>
<li>從一段 1 小時的 YouTube 影片，自動產生：逐字稿整理、重點大綱、教學文章、社群貼文。</li>
</ul>
<p>在 Agentic AI 的架構下，我們可能會看到這樣的分工：</p>
<ul>
<li><strong>影片分析 Agent</strong>：負責從影片拿到逐字稿、拆段、標註重點。</li>
<li><strong>內容整理 Agent</strong>：把資料整理成易讀的大綱、章節結構。</li>
<li><strong>寫作 Agent</strong>：依照不同輸出格式（部落格、教學、社群貼文）產生內容。</li>
<li><strong>審稿 / 品質控管 Agent</strong>：檢查語氣、品牌一致性、避免重複內容。</li>
</ul>
<p>中間會有一個「協調者」負責安排工作流程、把上一個 Agent 的輸出當成下一個 Agent 的輸入，這就是所謂的 <strong>Agentic workflow</strong>。</p>
<h3 id="差異重點整理">差異重點整理</h3>
<p>用表格簡單整理一下兩者差異：</p>
<table>
<thead>
<tr>
<th style="text-align:left">特性</th>
<th style="text-align:left">AI Agent</th>
<th style="text-align:left">Agentic AI</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">任務範圍</td>
<td style="text-align:left">一次專注在一個明確任務</td>
<td style="text-align:left">處理跨多步驟、多角色的大目標</td>
</tr>
<tr>
<td style="text-align:left">架構組成</td>
<td style="text-align:left">以單一 LLM + 工具為主</td>
<td style="text-align:left">多個 Agent + 協調流程</td>
</tr>
<tr>
<td style="text-align:left">互動模式</td>
<td style="text-align:left">使用者 → 單一 Agent → 工具</td>
<td style="text-align:left">使用者 → 協調層 → 多個 Agent 協作</td>
</tr>
<tr>
<td style="text-align:left">自主程度</td>
<td style="text-align:left">中等：可以自己決定如何用工具</td>
<td style="text-align:left">較高：可以自己規劃、分派、調整流程</td>
</tr>
<tr>
<td style="text-align:left">資訊流向</td>
<td style="text-align:left">Input → Agent → Tools → Output</td>
<td style="text-align:left">Input → Agent1 → Agent2 → … → Output</td>
</tr>
</tbody>
</table>
<p>如果把 AI Agent 比喻成一位「超強助理」，那 Agentic AI 就比較像是「一個專案團隊」，裡面有 PM、工程師、設計、測試，各司其職又互相協作。</p>
<br>
<h2 id="Microsoft-在-Agentic-AI-上的解決方案版圖">Microsoft 在 Agentic AI 上的解決方案版圖</h2>
<p>談完概念之後，回到實務選型：<strong>如果我想在 Microsoft 生態系裡做 Agent / Agentic AI，手上有哪些工具可以選？</strong></p>
<p>目前大致可以分成四條路線，從「幾乎不用寫程式」到「完全程式碼主導」都有：</p>
<table>
<thead>
<tr>
<th style="text-align:left">解決方案</th>
<th style="text-align:left">定位</th>
<th style="text-align:left">適用對象</th>
<th style="text-align:left">程式碼需求</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>Copilot Studio</strong></td>
<td style="text-align:left">低程式碼 AI Agent 平台</td>
<td style="text-align:left">業務部門、一般開發者</td>
<td style="text-align:left">幾乎不用寫程式</td>
</tr>
<tr>
<td style="text-align:left"><strong>Azure AI Foundry Agent Service</strong></td>
<td style="text-align:left">雲端託管 Agent 服務</td>
<td style="text-align:left">企業 IT / 後端工程師</td>
<td style="text-align:left">中等程式碼量</td>
</tr>
<tr>
<td style="text-align:left"><strong>Microsoft Agent Framework</strong></td>
<td style="text-align:left">開源 Agent / 多代理框架 SDK</td>
<td style="text-align:left">進階開發者、架構師</td>
<td style="text-align:left">高度程式碼客製</td>
</tr>
<tr>
<td style="text-align:left"><strong>Semantic Kernel</strong></td>
<td style="text-align:left">輕量級協調 SDK</td>
<td style="text-align:left">.NET / Python 開發者</td>
<td style="text-align:left">中高程式碼量</td>
</tr>
</tbody>
</table>
<br>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/12/agent-ai-and-agentic-ai/Microsoft-Agentic-AI-Comparison.jpg"
                        class=""
                 >
<br>
<h3 id="Copilot-Studio：從「聊天機器人」長大的-Agent-平台">Copilot Studio：從「聊天機器人」長大的 Agent 平台</h3>
<p><strong>Copilot Studio</strong> 可以把它想成是「做聊天機器人、做工作流程型 Copilot」的低程式碼平台，很多情境其實已經很接近單一 Agent：</p>
<ul>
<li>透過圖形化介面定義對話流程、條件分支。</li>
<li>連接各種資料來源（SharePoint、OneDrive、Dynamics、外部 API…）。</li>
<li>透過 <strong>Connector / Plug‑in / MCP</strong> 把外部系統當成工具來使用。</li>
<li>不需要自己處理 Prompt、記憶體、狀態儲存等細節。</li>
</ul>
<p><strong>優點</strong>：</p>
<ul>
<li>幾乎不用寫程式，適合業務單位或一般開發者。</li>
<li>內建大量連接器，串接常見 SaaS / Microsoft 365 生態非常方便。</li>
<li>可以快速發佈到 Teams、Web、LINE 等多種通路。</li>
</ul>
<p><strong>限制 / 缺點</strong>：</p>
<ul>
<li>複雜的 Agentic workflow（多代理協作、細緻的狀態機）比較難完全用圖形化介面表達。</li>
<li>對於版本控管、CI/CD、程式碼共用等軟體工程議題，彈性不如純程式碼框架。</li>
</ul>
<p>如果你的需求是：「想要先做一個可以用的智慧助理，重點是快、好維護」，那 Copilot Studio 是個蠻好的起點。</p>
<br>
<h3 id="Azure-AI-Foundry-Agent-Service：雲端託管的-Agent-平台">Azure AI Foundry Agent Service：雲端託管的 Agent 平台</h3>
<p><strong>Azure AI Foundry Agent Service</strong> 可以視為「由雲端幫你托管 Agent」，我們透過 SDK 或 Portal 定義好下列項目：</p>
<ul>
<li>使用哪個模型（例如 Azure OpenAI GPT‑4o 或其他大語言模型）。</li>
<li>這個 Agent 可以用哪些工具（Function / API / 檔案 / 搜尋等）。</li>
<li>一些系統層的參數（如安全性、網路、儲存體、Log 等）。</li>
</ul>
<p>優點是：</p>
<ul>
<li><strong>雲端全託管</strong>：不需要自己維運負責推理的工作節點、負載平衡、監控、Log 儲存。</li>
<li><strong>企業級安全性</strong>：支援 VNet、Private Endpoint、BYO Storage 等企業需求。</li>
<li><strong>多模型支援</strong>：可以選用不同家族的模型（例如：GPT、Llama、GROK-4）依場景搭配。</li>
</ul>
<p>相對的：</p>
<ul>
<li>必須部署在 Azure，成本與規模需要事前評估。</li>
<li>仍然需要一定程度的程式碼與架構設計。</li>
</ul>
<p>如果已經有開發團隊，希望把 Agent 當成一種「雲端服務元件」，又不想自己維護整套推理基礎架構，那 Azure AI Foundry Agent Service 會是一個折衷但穩健的選擇。</p>
<br>
<h3 id="Microsoft-Agent-Framework：多代理與-A2A-的核心-SDK">Microsoft Agent Framework：多代理與 A2A 的核心 SDK</h3>
<p><strong>Microsoft Agent Framework</strong> 是最近 (2025/10/1) 才開源的 <strong>Agent / Agentic AI 專用 SDK</strong>，同時支援 <strong>Python</strong> 和 <strong>.NET</strong>，可以視為把原本的 <strong>Semantic Kernel</strong> 與 <strong>AutoGen</strong> 整併、提升後的新一代框架。</p>
<p>它的設計大致有下列幾項重點：</p>
<ul>
<li><strong>多代理協調</strong>：原生支援 Agent 之間互相對話、協作，適合實作複雜工作流程。</li>
<li><strong>A2A（Agent‑to‑Agent）協定</strong>：讓不同執行環境、甚至不同平台上的 Agent 也能互通。</li>
<li><strong>MCP / OpenAPI 工具整合</strong>：可以很方便地把 API、外部系統包裝成 Agent 的工具。</li>
<li><strong>生產環境就緒</strong>：有錯誤處理、重試、持久化與觀測性等機制，方便從 PoC 走到 Production。</li>
</ul>
<p><strong>優點</strong>：</p>
<ul>
<li>架構上就是為「Agentic AI」設計，很適合把多個專業 Agent 組合成工作流程。</li>
<li>與 Azure AI Foundry、Microsoft 365 Copilot、Copilot Studio 等平台都可以互相整合。</li>
<li>開源、可行自架設，也可以搭配雲端服務一起使用。</li>
</ul>
<p><strong>缺點 / 挑戰</strong>：</p>
<ul>
<li>技術門檻相對高，需要熟悉 LLM + 分散式系統 + 軟體架構設計。</li>
<li>功能很多，設計彈性也高，前期會需要花時間建立團隊內部的 best practices。</li>
</ul>
<p>從定位來看，它比較像是：</p>
<blockquote>
<p>「如果你想打造一個可以長期演進、支援多代理協作的 AI 應用平台，Agent Framework 就是那個核心 SDK。」</p>
</blockquote>
<br>
<h3 id="Semantic-Kernel：輕量、模組化的協調-SDK">Semantic Kernel：輕量、模組化的協調 SDK</h3>
<p><strong>Semantic Kernel</strong> 則是比較早期推出的 LLM 協調 SDK，一樣支援 .NET / Python，主要幫我們處理：</p>
<ul>
<li>Prompt 組合與模板化。</li>
<li>指令 Function、工具呼叫（例如：把 C# method 變成可被模型呼叫的 function）。</li>
<li>記憶體 (Memory)、Planner 等常見 Agent 開發場景。</li>
</ul>
<p>它本身也可以用來做「單一 Agent」、或是簡單的多 Agent 情境，不過 <strong>多代理協作這一塊，目前的主角已經漸漸交棒給 Microsoft Agent Framework</strong>，Semantic Kernel 則偏向：</p>
<ul>
<li>在既有 .NET / Python 專案裡「嵌入 LLM 能力」的工具箱。</li>
<li>作為 Agent Framework 的一個重要組件或輔助 SDK。</li>
</ul>
<p><strong>優點</strong>：</p>
<ul>
<li>輕量、好嵌入，對 .NET 開發環境相當友善。</li>
<li>社群成熟、文件與範例多，很多既有教學都以它為基礎。</li>
</ul>
<p><strong>限制</strong>：</p>
<ul>
<li>如果要實作複雜的多代理 workflow，會需要自己多寫一層協調邏輯，或是搭配 Microsoft Agent Framework。</li>
</ul>
<br>
<h2 id="四種方案的比較與選擇建議">四種方案的比較與選擇建議</h2>
<p>最後用一張對照表，看一下四種方案的差異：</p>
<table>
<thead>
<tr>
<th style="text-align:left">特性</th>
<th style="text-align:left">Copilot Studio</th>
<th style="text-align:left">Azure AI Foundry Agent Service</th>
<th style="text-align:left">Microsoft Agent Framework</th>
<th style="text-align:left">Semantic Kernel</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">開發方式</td>
<td style="text-align:left">圖形化 / 對話式</td>
<td style="text-align:left">SDK + Portal 管理</td>
<td style="text-align:left">Python / .NET SDK</td>
<td style="text-align:left">.NET / Python SDK</td>
</tr>
<tr>
<td style="text-align:left">多代理協作</td>
<td style="text-align:left">有限（偏向單一 Agent）</td>
<td style="text-align:left">支援，但由服務端協調</td>
<td style="text-align:left">原生支援、多代理主場</td>
<td style="text-align:left">可實作，但需自行組裝</td>
</tr>
<tr>
<td style="text-align:left">MCP / 工具整合</td>
<td style="text-align:left">以 Connector / MCP 方式整合</td>
<td style="text-align:left">支援工具呼叫與多模型</td>
<td style="text-align:left">原生支援 MCP / OpenAPI / A2A</td>
<td style="text-align:left">透過 plug‑in / function 整合</td>
</tr>
<tr>
<td style="text-align:left">部署 / 維運</td>
<td style="text-align:left">由 Microsoft 全託管</td>
<td style="text-align:left">Azure 全託管</td>
<td style="text-align:left">本機自架或上雲</td>
<td style="text-align:left">由應用程式自行負責</td>
</tr>
<tr>
<td style="text-align:left">適用對象</td>
<td style="text-align:left">業務、IT、一般開發者</td>
<td style="text-align:left">有雲端經驗的開發團隊</td>
<td style="text-align:left">進階開發者</td>
<td style="text-align:left">想在既有程式裡加上 LLM 的開發者</td>
</tr>
</tbody>
</table>
<h3 id="什麼情境適合哪一個？">什麼情境適合哪一個？</h3>
<ul>
<li>
<p><strong>「我要快速做一個會聊天、會幫忙查資料或執行流程的助理」</strong><br>
→  先看 Copilot Studio，門檻最低、上線最快。</p>
</li>
<li>
<p><strong>「我們有後端團隊，希望把 Agent 當成一個穩定的雲端服務元件」</strong><br>
→ 可以考慮 Azure AI Foundry Agent Service，享受託管與企業級安全性。</p>
</li>
<li>
<p><strong>「我們已經有一堆 .NET / Python 系統，只是想讓它們變得更聰明一點」</strong><br>
→ 從 Semantic Kernel 下手，把 LLM 能力「嵌進去」既有應用程式。</p>
</li>
<li>
<p><strong>「我們要打造一個可長期演進的多代理平台，未來可能會跟內部系統深度整合」</strong><br>
→ 把 Microsoft Agent Framework 當成主軸，必要時再搭配其他服務。</p>
</li>
</ul>
<br>
<h3 id="先想清楚「要解決的問題」，再選工具">先想清楚「要解決的問題」，再選工具</h3>
<p>「我要學的是 AI Agent 還是 Agentic AI？」其實兩者並不是互斥的選項，而是 <strong>不同層級的抽象</strong>：</p>
<ul>
<li>先理解 <strong>AI Agent</strong>：學會怎麼讓一個 Agent 聽懂需求、會用工具、能把事情做完。</li>
<li>再往上看 <strong>Agentic AI</strong>：學會怎麼設計整個 workflow、怎麼切出不同專業 Agent、如何協調它們的合作與溝通。</li>
</ul>
<br>
微軟提供的這四條路線，剛好也從「低程式碼 → 高自訂」排成一個光譜，我們可以：
<ul>
<li>先用 Copilot Studio 做出可以 demo 的東西，</li>
<li>再把關鍵部分細部展開到 Microsoft Agent Framework / Semantic Kernel，</li>
<li>或是用 Azure AI Foundry Agent Service 接手雲端託管與營運。</li>
</ul>
<br>
<p>AI Agent 與 Agentic AI 是「不同層級」的設計：前者聚焦於讓單一代理能夠自主使用工具完成任務，後者則著重於多個代理之間的協作與流程編排。實務上建議採取由淺入深的策略：先用 Copilot Studio 或簡單的 Agent 快速驗證想法，確認核心流程與資料來源；接著把關鍵邏輯以 Semantic Kernel 或 Microsoft Agent Framework 封裝、進行測試與版本管理；最後視需求將成熟的元件移入 Azure AI Foundry 等託管平台以滿足安全與運維需求。選擇工具時，應以「要解決的問題、團隊技術能力與營運需求」為優先，從小型 PoC 漸進到 Production 架構，才能最小化風險並累積實作經驗。</p>
]]></content>
      <tags>
        <tag>Agent AI</tag>
        <tag>Agentic AI</tag>
      </tags>
  </entry>
  <entry>
    <title>Azure DevOps Services 個別服務</title>
    <url>/post/2025/04/azure-devops-individual-services/</url>
    <content><![CDATA[<img    
                       lazyload
                       alt="image"
                       data-src="/post/2025/04/azure-devops-individual-services/individual_services.jpg"
                         align="left" style="margin-right: 10px; width: 125px; border: 1px solid gray;"
                 > 
<p><a href="/post/2024/09/azure-devops-licensing-description">上一篇文章</a>提到了 Azure DevOps 雲端和地端的使用者授權，當我們建立私有專案 (Private project) 且成員數量在 5 個人以下時，甚至可以直接免費使用，從第 6 個人起才需要計價，並具有 1 Free Microsoft-hosted CI/CD 和 1 Free Self-hosted CI/CD 以及 Azure Artifacts 2GB 可用儲存容量。在實務使用情境較複雜時，很有可能就需要再增加個別服務的用量 (例如：Azure Pipelines 平行作業數量)，這次就帶大家瞭解這些個別服務計價的方式。</p>
<span id="more"></span>
<br>
<h2 id="Azure-Pipelines">Azure Pipelines</h2>
<p>不論我們在 Azure Pipelines 使用文字介面或是圖形介面 (classic editor) 建立 pipeline 腳本內容，其中有個 <strong><code>Agent pools</code></strong> 選項是必要設定，它是用來決定執行階段要把工作 (job) 傳遞到哪個 pool 裡，尋找閒置且符合條件的 <strong>Azure Pipelines agents</strong> 執行個體來執行腳本內容，在 Azure DevOps Services 預設有一個 Microsoft-hosted agent 每個月可以免費使用 1800 分鐘，<mark>但預設無法直接使用</mark>，需要填寫 <strong><a class="link"   href="https://aka.ms/azpipelines-parallelism-request" >Azure DevOps Parallelism Request<i class="fas fa-external-link-alt"></i></a></strong> 表單申請審核通過才行，否則在執行的時候會出現如下錯誤：</p>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/04/azure-devops-individual-services/azpipelines-parallelism-request.jpg"
                        class=""
                 >
<p>當然我們也可以自己準備機器，在上面安裝 Azure Pipelines agents 程式 (支援 Windows / Linux / macOS)，這就屬於 Self-hosted agent。由於是自己準備的執行個體，所以使用時數不受限制，但每個工作 (job) 都是經由佇列 (queue) 的方式排隊一個一個執行，若需要同時間處理一個以上的工作 (job)，則需要再增加執行個體才行 (不論是 Microsoft-hosted 或是 Self-hosted)，基於這樣的概念，以下就是我們所關心的計價標準：</p>
<ul>
<li>每一個 Microsoft-hosted 每個月有 1800 分鐘可以使用。</li>
<li>每增加一個額外的 Microsoft-hosted CI/CD 每個月是 USD $40 (大約 <strong>TWD $1279</strong>)。</li>
<li>每增加一個額外的 Self-hosted CI/CD 每個月是 USD $15 (大約 <strong>TWD $479</strong>)。</li>
<li><mark>如果在地端自建 Azure DevOps Server 則僅能使用 Self-hosted agent，需要更多的平行作業就自己多準備幾個執行個體，不用再額外採購什麼授權。</mark></li>
</ul>
<h2 id="Azure-Artifacts">Azure Artifacts</h2>
<p>在軟體專案開發過程中，多少都會用到一些公司內部自行開發，或是外部來源提供的套件，一般常見的套件來源像是：NuGet、npm、Maven、Python…等，Azure Artifacts 可以將這些外部提供來源設為上游來源 (Upstream sources)，或是自己建立一個套件提供來源 (Feeds)，讓專案團隊成員在內部環境取用，儲存容量在 2GB 以內是免費，若超過則依下列區間以量計價：</p>
<table>
<thead>
<tr>
<th>儲存容量</th>
<th>每GB (USD)</th>
<th>每GB (TWD)</th>
</tr>
</thead>
<tbody>
<tr>
<td>0 - 2 GB</td>
<td>免費</td>
<td>免費</td>
</tr>
<tr>
<td>2 - 10 GB</td>
<td>$2</td>
<td>大約 $63.98</td>
</tr>
<tr>
<td>10 - 100 GB</td>
<td>$1</td>
<td>大約 $31.99</td>
</tr>
<tr>
<td>100 - 1000 GB</td>
<td>$0.50</td>
<td>大約 $16.00</td>
</tr>
<tr>
<td>1000 GB 以上</td>
<td>$0.25</td>
<td>大約 NT$8.00</td>
</tr>
</tbody>
</table>
<h2 id="GitHub-Advanced-Security-for-Azure-DevOps">GitHub Advanced Security for Azure DevOps</h2>
<p>以往我們想要對專案程式碼執行原碼檢測、套件掃描等作業，首先要考量的可能是產品的價錢，或是委外檢測的費用，比較克難一點還可以尋找免費的掃描檢測工具(例如只是想要出個報告 🙈 🙊)，若想要整合到 CI 流程裡，還要得額外花一番功夫，但基本上只要可以透過 command line 來執行，都是可以用 Azure Pipelines 整合起來的。而自從 <strong>GitHub Advanced Security for Azure DevOps</strong> 正式啟用後，省掉了這部份不少麻煩，除了原生的與 Azure DevOps Services 整合 <mark>(不包含地端 Azure DevOps Server)</mark>，也可以與 <strong>Microsoft Defender for Cloud</strong> 串接，它可以做到：</p>
<ul>
<li><strong>Code Scanning</strong>：找出原始程式碼中的漏洞並提供修復指導。</li>
<li><strong>Secret Scanning</strong>：識別 secret 並阻止開發人員將 secret 推送到程式碼儲存庫。</li>
<li><strong>Dependency Scanning</strong>：發現 open-source 依賴項目的漏洞，並為開發人員自動發出更新警報。</li>
</ul>
<p>在 Azure Pipelines 也提供了下列對應的 task 以便我們完善整個 <strong><code>DevSecOps</code></strong> 流程：</p>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/04/azure-devops-individual-services/github_acvanced_security.jpg"
                        class=""
                 >
<p>這個功能可以由每個 git 的儲存庫 (repositry) 個別設定是否啟用 (不支援 TFVC 版控)，計價的原則是：每一個活躍的提交者 (active committer) 每個月 <strong>USD $49</strong> (大約 <strong>TWD $1567</strong>)，在<mark>同一個 Azure Subscription</mark> 中，儲存庫過去 <strong><code>90天</code></strong> 的紀錄中，同一個提交者(committer)在不同專案提交程式碼只會算 1 個數量，不會被重複計價。當我們在 git 儲存庫開啟 <strong><code>Advanced Security</code></strong> 功能時，Azure DevOps 在畫面上也會先幫我們基於上述原則計算有多少使用者會被計費，確定要使用再點選 <strong><code>Begin billing</code></strong> 即可：</p>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/04/azure-devops-individual-services/unique_committers.jpg"
                        class=""
                 >
<p>如同 Azure 各種服務的計價方式，都是<strong>隨付即用 (pay-as-you-go)</strong>，啟用 <strong>GitHub Advanced Security for Azure DevOps</strong> 搭配 CI 流程可以讓我們在開發階段及早發現問題與漏洞，有效減少技術債和後期投入修改的人力成本，跟測試左移 (Shift-Left Testing) 的概念有點雷同，也可以省下大筆購入源碼檢測軟體的費用，大家可以參考看看。</p>
<div class="tips">
<font color="black">
<a class="link"   href="https://azure.microsoft.com/zh-tw/pricing/details/devops/azure-devops-services/"  target="_blank">⁍ Azure DevOps 定價<i class="fas fa-external-link-alt"></i></a><br>
<a class="link"   href="https://azure.microsoft.com/zh-tw/products/devops/github-advanced-security"  target="_blank">⁍ 適用於 Azure DevOps 的 GitHub Advanced Security<i class="fas fa-external-link-alt"></i></a><br>
<a class="link"   href="https://learn.microsoft.com/zh-tw/azure/devops/repos/security/configure-github-advanced-security-features?view=azure-devops&tabs=yaml"  target="_blank">⁍ 設定適用於 Azure DevOps 的 GitHub Advanced Security<i class="fas fa-external-link-alt"></i></a>
</font>
</div>]]></content>
      <tags>
        <tag>Azure DevOps</tag>
        <tag>授權</tag>
      </tags>
  </entry>
  <entry>
    <title>Azure DevOps REST API 說明</title>
    <url>/post/2025/04/azure-devops-rest-api/</url>
    <content><![CDATA[<img    
                       lazyload
                       alt="image"
                       data-src="/post/2025/04/azure-devops-rest-api/rest_api.jpg"
                         align="left" style="margin-right: 10px; width: 125px; border: 1px solid gray;"
                 > 
<p>當我們要自行擴充或串接 Azure DevOps Services / Server 功能時，可以透過 Azure DevOps REST API 來進行客制開發，例如：想要寫一支程式每天發送各專案在版控儲存庫的差異紀錄，或是想要在公司內部表單系統審核後，觸發執行指定的 pipeline … 族繁不及備載，使用 REST API 透過 HTTP 呼叫的好處是可以不用侷限於特定的程式語言，也方便用 Postman 之類的工具測試，這篇整理了呼叫 Azure DevOps REST API 的前置作業與相關說明，方便大家上手😁。</p>
<span id="more"></span>
<br>
<h2 id="REST-API">REST API</h2>
<p>使用 Azure DevOps REST API 時，其 URI 規格如下：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">VERB https://&#123;instance&#125;/&#123;organization&#125;/&#123;project&#125;/_apis/&#123;area&#125;/&#123;resource&#125;?api-version=&#123;version&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>VERB</strong><br>
與一般 RESTful API 相同，在串接 Azure DevOps 各種情境時， <strong><font color='green'>GET</font></strong> / <strong><font color='brown'>POST</font></strong> / <strong><font color='red'>DELETE</font></strong> / <strong><font color='purple'>PATCH</font></strong> 都有機會用到。</li>
<li><strong>instance</strong><br>
如果是使用雲端的 Azure DevOps Services 指的就是 <span>dev.azure.com</span>，地端則是 Azure DevOps Server 所在的位址。</li>
<li><strong>organization/project</strong><br>
取決於 API 作用的範圍，在 URI 裡會有 organization 或 organization/project，例如：使用 API 建立個人權杖 (PAT)，則會是：<br>
<strong><font color='brown'>POST</font></strong> https://vssps.dev.azure.com/<mark>{organization}</mark>/_apis/tokens/pats?api-version=7.2<br>
或者像是用 API 建立一個工作項目，則是：<br>
<strong><font color='brown'>POST</font></strong> https://dev.azure.com/<mark>{organization}/{project}</mark>/_apis/wit/workitems/${type}?api-version=7.2</li>
<li><strong>{area}/{resource}</strong><br>
從這邊大概可以看出呼叫的 API 是做哪方面的操作，以上面兩個例子 (建立 PAT、建立 Work item) 來說：<br>
<strong><font color='brown'>POST</font></strong> https://vssps.dev.azure.com/{organization}/_apis/<mark>tokens/pats</mark>?api-version=7.2<br>
<strong><font color='brown'>POST</font></strong> https://dev.azure.com/{organization}/{project}/_apis/<mark>wit/workitems/${type}</mark>?api-version=7.2</li>
<li><strong>version</strong><br>
通常我們在串接 API 時會明確指定 version，因為每個 TFS / Azure DevOps 版本對於 API 支援的 api-version 也有所不同 (如下表)，如果不指定 api-version 則會自動選用目前產品最新的穩定版本，例如：在 Azure DevOps Server 2019 它會自動取用 5.0 來執行，在不加 api-version 的情況下，若日後升級到 Azure DevOps Server 2022，則會自動取用 7.0 來執行，為維持串接程式正常運作，不會因為 API 版本差異而造成異常，一般我們都會加上指定的 api-version 版號。</li>
</ul>
<blockquote>
<p>提醒大家：<br>
如果是使用 preview 版本 (例如：<strong><code>7.2-preview.3</code></strong>)，該 preview 版本會在 <strong>12 週</strong> 後停用，被穩定的正式版本取代。</p>
</blockquote>
<table>
<thead>
<tr>
<th>Products</th>
<th style="text-align:center">1.0</th>
<th style="text-align:center">2.0</th>
<th style="text-align:center">3.0</th>
<th style="text-align:center">4.0</th>
<th style="text-align:center">5.0</th>
<th style="text-align:center">6.0</th>
<th style="text-align:center">7.0</th>
</tr>
</thead>
<tbody>
<tr>
<td>Azure DevOps Services</td>
<td style="text-align:center">V</td>
<td style="text-align:center">V</td>
<td style="text-align:center">V</td>
<td style="text-align:center">V</td>
<td style="text-align:center">V</td>
<td style="text-align:center">V</td>
<td style="text-align:center">V</td>
</tr>
<tr>
<td>Azure DevOps Server 2022</td>
<td style="text-align:center">V</td>
<td style="text-align:center">V</td>
<td style="text-align:center">V</td>
<td style="text-align:center">V</td>
<td style="text-align:center">V</td>
<td style="text-align:center">V</td>
<td style="text-align:center">V</td>
</tr>
<tr>
<td>Azure DevOps Server 2020</td>
<td style="text-align:center">V</td>
<td style="text-align:center">V</td>
<td style="text-align:center">V</td>
<td style="text-align:center">V</td>
<td style="text-align:center">V</td>
<td style="text-align:center">V</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td>Azure DevOps Server 2019</td>
<td style="text-align:center">V</td>
<td style="text-align:center">V</td>
<td style="text-align:center">V</td>
<td style="text-align:center">V</td>
<td style="text-align:center">V</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td>Team Foundation Server 2018</td>
<td style="text-align:center">V</td>
<td style="text-align:center">V</td>
<td style="text-align:center">V</td>
<td style="text-align:center">V</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td>Team Foundation Server 2017</td>
<td style="text-align:center">V</td>
<td style="text-align:center">V</td>
<td style="text-align:center">V</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td>Team Foundation Server 2015</td>
<td style="text-align:center">V</td>
<td style="text-align:center">V</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
<h2 id="PAT-Personal-Access-Token">PAT (Personal Access Token)</h2>
<p>要使用 Azure DevOps REST API 存取資源前都必需先經過驗證成功才行，建立 <strong><code>個人存取權杖 (PAT)</code></strong> 可以算是安全又簡便的方式，若想要實作 OAuth 2.0 或其他頁面驗證方式，可以參考下列連結：</p>
<div class="tips">
<font color="black">
<a class="link"   href="https://learn.microsoft.com/zh-tw/azure/devops/integrate/get-started/authentication/authentication-guidance?toc=%2Fazure%2Fdevops%2Fmarketplace-extensibility%2Ftoc.json&view=azure-devops"  target="_blank">⁍ 選擇正確的驗證機制<i class="fas fa-external-link-alt"></i></a>
</font>
</div>
<p>要建立一個 PAT 可以從 Azure DevOps 畫面右上角 <strong><code>User settings</code></strong> → <strong><code>Personal access tokens</code></strong> 進入。</p>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/04/azure-devops-rest-api/pat.png"
                        class=""
                 >
<br>
<p>點選 <strong><code>+ New Token</code></strong> 按鈕。</p>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/04/azure-devops-rest-api/pat_1.png"
                        class=""
                 >
<br>
<p>接著就是 PAT 存取期限、授權範圍等相關設定：</p>
<ul>
<li><strong>Organization</strong><br>
選擇 <strong>特定的 Organization</strong> 或 <strong>All accessible organizations</strong> (允許存取全部組織)。</li>
<li><strong>Expiration (UTC)</strong><br>
有效期限可以選擇 <strong>30 / 60 / 90 天</strong>，或是 <strong>Custom defined</strong> (<mark>最長只能一年</mark>)</li>
<li><strong>Scopes</strong><br>
可以選擇 <strong>Full access</strong> (允許存取全部範圍) 或 <strong>Custom defined</strong> 針對各個功能進一步設定，基於最低權限原則，建議大家可以有意義的命名 token 名稱，並且只勾選必要的 <strong>Scopes</strong> 授權範圍。</li>
</ul>
<p>建立 PAT 後，僅能 <strong><code>Revoke</code></strong> (撤銷) 或是 <strong><code>Regenerate</code></strong> (重新產生)，沒有辦法再用任何方式檢視原本產生的 token 內容，大家記得要妥善保存。</p>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/04/azure-devops-rest-api/pat_2.png"
                        class=""
                 >
<h2 id="NET-Client-Library">.NET Client Library</h2>
<p>如果是使用 .NET 進行程式開發，還有一個選擇是從 NuGet.org 下載 Client library 使用，套件相依關係如下圖。</p>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/04/azure-devops-rest-api/dotnet-client-libraries-dependancy-diagram.jpg"
                        class=""
                 >
<br>
<p>最新版本可以由 NuGet.org 查詢結果找到： https://www.nuget.org/packages?q=azure+devops+.net ，套件和 Azure DevOps 版本一樣有相依性， 使用前要留意一下目前環境的 TFS / Azure DevOps Server 版本，例如：Azure DevOps Server 2019 只能使用到套件 16.143.x 版。</p>
<table>
<thead>
<tr>
<th>套件版本</th>
<th>Azure DevOps 版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>16.205.x</td>
<td>versions &gt;= Azure DevOps Server 2022</td>
</tr>
<tr>
<td>16.170.x</td>
<td>versions &gt;= Azure DevOps Server 2020</td>
</tr>
<tr>
<td>16.153.x</td>
<td>versions &gt;= Azure DevOps Server 2019 Update 1</td>
</tr>
<tr>
<td>16.143.x</td>
<td>versions &gt;= Azure DevOps Server 2019</td>
</tr>
<tr>
<td>15.131.x</td>
<td>versions &gt;= TFS 2018 Update 1</td>
</tr>
<tr>
<td>15.112.x</td>
<td>versions &gt;= TFS 2017 Update 1</td>
</tr>
<tr>
<td>14.102.x</td>
<td>versions &gt;= TFS 2015 Update 3</td>
</tr>
<tr>
<td>14.95.x</td>
<td>versions &gt;= TFS 2015 Update 2</td>
</tr>
<tr>
<td>14.89.x</td>
<td>versions &gt;= TFS 2015 Update 1</td>
</tr>
<tr>
<td>14.83.x</td>
<td>versions &gt;= TFS 2015</td>
</tr>
</tbody>
</table>
<p>在實務開發上還是得花些時間先瞭解套件定義了哪些 class、提供了什麼 function，這部份可以參考官方說明和 github sample code，如果有特殊需求或環境考量需要使用的話，可以參考下列連結：</p>
<div class="tips">
<font color="black">
<a class="link"   href="https://learn.microsoft.com/zh-tw/azure/devops/integrate/concepts/dotnet-client-libraries?view=azure-devops&viewFallbackFrom=vsts"  target="_blank">⁍ .NET 用戶端程式庫<i class="fas fa-external-link-alt"></i></a><br>
<a class="link"   href="https://learn.microsoft.com/zh-tw/azure/devops/integrate/get-started/client-libraries/samples?view=azure-devops"  target="_blank">⁍ C# 用戶端連結庫範例<i class="fas fa-external-link-alt"></i></a><br>
<a class="link"   href="https://github.com/microsoft/azure-devops-dotnet-samples"  target="_blank">⁍ .NET samples for Azure DevOps<i class="fas fa-external-link-alt"></i></a>
</font>
</div>
<p>(💁 看完上面連結內容有沒有覺得還是使用 REST API 比較方便 💖)</p>
]]></content>
      <tags>
        <tag>Azure DevOps</tag>
        <tag>Azure DevOps REST API</tag>
        <tag>PAT</tag>
        <tag>.NET Client Library</tag>
      </tags>
  </entry>
  <entry>
    <title>Agentic AI 與 SDLC 協奏曲</title>
    <url>/post/2025/12/agentic-sdlc-explorer/</url>
    <content><![CDATA[<img    
                       lazyload
                       alt="image"
                       data-src="/post/2025/12/agentic-sdlc-explorer/sdlc.jpg"
                         align="left" style="margin-right: 10px; width: 125px; border: 1px solid gray;"
                 > 
<p>在工作上我經常需要跟客戶討論 DevOps 與軟體工作流程，從需求管理、版本控管，到建置、測試與佈署，這幾年又加上 AI / Agentic AI 的導入議題，光靠投影片或架構圖常常很難在短時間內讓大家有「同一個畫面」。也因為這樣，我做了一個小小的 side project —— <strong>Agentic SDLC Explorer</strong>，想用一個可以點點看的互動式網站，來幫助大家快速了解 Agent 在 SDLC 各階段可以扮演什麼角色。</p>
<span id="more"></span>
<br>
<h2 id="為什麼會做-Agentic-SDLC-Explorer？">為什麼會做 Agentic SDLC Explorer？</h2>
<p>這幾年在跟客戶討論 DevOps 或 SDLC 優化時，越來越常被問到幾個問題：</p>
<ul>
<li>「AI 在我們的開發流程裡，<strong>到底能幫上什麼忙</strong>？」</li>
<li>「除了 IDE 裡的 GitHub Copilot，能不能有更『流程化』的應用？」</li>
<li>「如果要導入 Agent，是不是整個 SDLC 都要重改？」</li>
</ul>
<p>多數團隊其實已經有一套既有流程（Jira / Azure DevOps / GitHub / Jenkins / 自家 Pipeline…），真正的問題不是「要不要用 AI」，而是：</p>
<ul>
<li>哪些工作可以交給 Agent？</li>
<li>這些 Agent 應該長什麼樣子？</li>
<li>在實務中，怎麼跟既有 SDLC 串在一起？</li>
</ul>
<p>所以我做了這個 <strong>Agentic SDLC Explorer</strong>，把整個 SDLC 拆成幾個大家比較熟悉的階段，試著用「<strong>如果有一個 Agent 在這裡，它可以幫你做哪些事？</strong>」這個角度來整理，方便在顧問或工作坊場合用來示範與討論。</p>
<br>
<h2 id="什麼是-Agentic-SDLC-Explorer？">什麼是 Agentic SDLC Explorer？</h2>
<p>簡單來說，<strong>Agentic SDLC Explorer</strong> 是一個以 <strong>Vite + React</strong> 打造的輕量前端示範專案，用來視覺化展示 Agent（自動化代理）在軟體開發生命週期（SDLC）中可以協助的各種工作。畫面上會把 SDLC 的不同階段切成數個區塊，點選每個區塊可以展開對應的 Agent 情境與說明，讓大家不用看長篇文件，就能快速瀏覽可能的應用方式。</p>
<p>這個專案目前主要聚焦在「<strong>情境與概念整理</strong>」，也就是：</p>
<ol>
<li>幫你把腦中鬆散的想法具體化：哪些工作其實可以交給 Agent？</li>
<li>提供一個討論框架：在跟團隊或利害關係人溝通時，有一個共同的視覺化藍圖可以對焦。</li>
</ol>
<br>
<h2 id="目標與設計理念">目標與設計理念</h2>
<p>在設計這個 side project 時，我自己抓了兩個核心目標：</p>
<ol>
<li>
<p><strong>示範 Agent 在不同 SDLC 階段的可能應用</strong><br>
從需求分析、系統設計、開發、測試、安全、程式碼審查，到部署與維運，嘗試列出各階段可以交給 Agent 處理或輔助的任務，讓大家看到「不只是在寫程式時可以用 GitHub Copilot」。</p>
</li>
<li>
<p><strong>提供可直接執行的範例介面</strong><br>
雖然現在版本主要還是概念展示，但整個專案結構就是一般前端專案，日後可以很容易地把某些情境換成真實 API / Agent 後端實作，慢慢演進成一個「可以真的點一點就幫你做事」的 Agentic SDLC 工具箱。</p>
</li>
</ol>
<br>
<h2 id="Agent-AI-在-SDLC-中的應用範疇">Agent AI 在 SDLC 中的應用範疇</h2>
<p>在 Agentic SDLC Explorer 裡，我把 SDLC 粗略切成幾個比較容易對應到日常工作的區塊，下面逐一說明每個範疇適合出現哪些 Agent，以及它們可以幫上什麼忙。</p>
<br>
<h3 id="1-需求-Backlog：從想法到可實作的工作項目">1. 需求 / Backlog：從想法到可實作的工作項目</h3>
<p>在需求管理這一段，我通常會想像有幾種類型的 Agent：</p>
<ul>
<li>
<p><strong>需求整理 Agent</strong>：</p>
<ul>
<li>協助整理會議紀錄、Email、聊天訊息，把零散的想法歸納成可管理的 Backlog 項目。</li>
<li>協助補上缺少的欄位，例如：商業價值、風險、驗收條件、相依關係等。</li>
</ul>
</li>
<li>
<p><strong>規格檢視 Agent</strong>：</p>
<ul>
<li>檢查需求描述是否含糊不清、是否缺少邊界條件或錯誤情境。</li>
<li>參考現有系統文件或程式碼，提醒「這個需求可能會影響到哪些模組」。</li>
</ul>
</li>
<li>
<p><strong>系統設計輔助 Agent</strong>：</p>
<ul>
<li>根據需求內容，協助產生初步架構圖、資料流、模組切分建議。</li>
<li>提出多種實作選項（例如：同步 vs 非同步、事件式設計 vs 傳統呼叫），幫助架構師做決策。</li>
</ul>
</li>
</ul>
<p>在 Explorer 的介面上，這一塊會被標示成「需求 / Backlog」，點進去可以看到上面提到的這類情境，方便跟 PM 或 BA 討論「哪些還是要人決定、哪些可以交給 Agent 做第一輪整理」。</p>
<br>
<h3 id="2-開發-Agentic-Coding：讓-IDE-真的變成你的-Pair">2. 開發 / Agentic Coding：讓 IDE 真的變成你的 Pair</h3>
<p>談到開發階段，大家第一個想到的通常是 IDE 裡的 GitHub Copilot 或類似工具，但在 Agent 視角下，可以再往前幾步：</p>
<ul>
<li>
<p><strong>程式碼理解 Agent</strong>：</p>
<ul>
<li>對既有程式碼庫進行分析，協助回答「這支服務在做什麼？」「這段 legacy code 改動會影響哪裡？」。</li>
<li>依需求或 Issue，自動找出相關檔案、類別與測試，當成開發起手式。</li>
</ul>
</li>
<li>
<p><strong>多語言程式碼翻譯 Agent</strong>：</p>
<ul>
<li>把 VB6 / VB.NET / Java 等舊系統片段，逐步翻譯成目標語言（例如 C#、TypeScript），同時標註需要人工確認的區塊。</li>
</ul>
</li>
<li>
<p><strong>Refactoring / Pattern 建議 Agent</strong>：</p>
<ul>
<li>觀察重複邏輯，提出重構建議（提煉函數、抽共用模組、導入設計模式等）。</li>
<li>在 PR 或本地編輯階段，提醒程式碼味道（Code Smell）或潛在技術債。</li>
</ul>
</li>
</ul>
<p>這些都不一定要是「一個超級大 Agent」，實務上更常見的做法是：</p>
<ul>
<li>讓 IDE 內建 GitHub Copilot 負責即時補全與解說，</li>
<li>再搭配幾個針對特定語言或框架的後端 Agent，負責比較重的分析工作，</li>
<li>透過 MCP / API 或自訂工具，把結果回寫到開發者的工作環境中。</li>
</ul>
<br>
<h3 id="3-測試與安全：從「寫測試」變成「設計測試策略」">3. 測試與安全：從「寫測試」變成「設計測試策略」</h3>
<p>在測試這一段，Agent 很適合扮演的是「測試策略設計師」與「測試產生器」：</p>
<ul>
<li>
<p><strong>單元測試產生 Agent</strong>：</p>
<ul>
<li>根據既有程式碼與需求描述，自動產生單元測試範本，並幫你補齊常見的正常 / 例外情境。</li>
<li>協助重構既有測試，讓測試名稱更清楚、結構更一致。</li>
</ul>
</li>
<li>
<p><strong>整合測試 / 合約測試 Agent</strong>：</p>
<ul>
<li>根據 API 規格（OpenAPI / gRPC / 內部文件），自動產生合約測試樣本與測試資料集。</li>
<li>協助模擬下游系統行為（Mock / Stub），加速測試環境就緒。</li>
</ul>
</li>
<li>
<p><strong>安全性分析 Agent</strong>：</p>
<ul>
<li>包裝 SAST / DAST 工具的輸出結果，轉成比較「人看得懂」的風險說明與修正建議。</li>
<li>在 PR 或 Build 階段對惡意輸入、權限控管、密碼與金鑰管理作靜態檢查，幫忙標註優先順序。</li>
</ul>
</li>
</ul>
<p>當然，最終的測試策略仍需要測試工程師或團隊自己決定，但 Agent 可以把大量「機械式、可重複」的工作處理掉，讓人類把時間花在設計更好的測試場景，而不是在那邊苦苦寫樣板。</p>
<br>
<h3 id="4-程式碼提交與審查：讓-PR-審查更聚焦在設計與風險">4. 程式碼提交與審查：讓 PR 審查更聚焦在設計與風險</h3>
<p>在 Commit / PR 流程中，可以想像幾個常見的 Agent：</p>
<ul>
<li>
<p><strong>變更摘要 Agent</strong>：</p>
<ul>
<li>針對這次 Commit / PR，自動整理「改了什麼」、「為什麼要改」、「可能影響到什麼」三個重點。</li>
<li>協助產生較高品質的 PR 描述，讓 Reviewer 不用自己從 diff 猜動機。</li>
</ul>
</li>
<li>
<p><strong>Code Review 佐助 Agent</strong>：</p>
<ul>
<li>結合程式碼規範（Coding Guidelines）、安全規則與團隊慣例，先跑一輪初步檢查，把明顯問題先標出來。</li>
<li>幫 Reviewer 統整重點：哪幾個檔案改最多？哪幾個區塊需要多人共同確認？</li>
</ul>
</li>
<li>
<p><strong>合規 / 安全審查 Agent</strong>：</p>
<ul>
<li>對涉入隱私資料、金流、權限的變更多做一層檢查，確保沒有誤用敏感 API 或外洩機會。</li>
</ul>
</li>
</ul>
<p>這類 Agent 不一定要「自動幫你按 Approve」，比較實際的做法是：</p>
<ul>
<li>把 Review 的「雜訊」濾掉，</li>
<li>協助排出「這個 PR 裡最值得你花時間看的地方」，</li>
<li>讓 Reviewer 有更多時間專注在架構設計、風險與長期維護性。</li>
</ul>
<br>
<h3 id="5-部署與維運：從-Log-與警報中找出可以行動的訊息">5. 部署與維運：從 Log 與警報中找出可以行動的訊息</h3>
<p>在 CI/CD 與維運階段，Agent 的角色通常比較偏向「觀察者 + 分析師」：</p>
<ul>
<li>
<p><strong>Pipeline 輔助 Agent</strong>：</p>
<ul>
<li>監看建置結果與測試報告，將錯誤訊息轉成具體建議（例如：哪個測試常壞？是 flaky 還是真的有問題？）。</li>
<li>針對常失敗的 Stage，提出切分或重構建議，協助 DevOps 工程師優化 Pipeline。</li>
</ul>
</li>
<li>
<p><strong>Incident / On-call 助理 Agent</strong>：</p>
<ul>
<li>當監控系統跳出警報時，整理相關的 Log、最近變更、影響的服務與使用者數量，讓 On-call 能在幾分鐘內掌握大局。</li>
<li>協助產生初版的 Incident Report 或 Postmortem 草稿，後續再由團隊補完。</li>
</ul>
</li>
</ul>
<p>這些應用都很適合被視覺化放在 SDLC Explorer 裡，幫助團隊思考：「我們目前哪一段流程最痛？是不是可以先從這裡開始試驗 Agent？」</p>
<br>
<h3 id="6-文件與發佈：讓知識累積變得更自然">6. 文件與發佈：讓知識累積變得更自然</h3>
<p>最後一塊是很多團隊都想做、但總是排不出時間的：「文件與發佈」。</p>
<ul>
<li>
<p><strong>文件產生 / 更新 Agent</strong>：</p>
<ul>
<li>根據需求、設計決策與程式碼變更，自動產生或更新 API 文件、架構說明、系統操作手冊草稿。</li>
<li>協助比對「實際系統行為」與「文件描述」是否一致，標出可能已過期的段落。</li>
</ul>
</li>
<li>
<p><strong>Release Notes 助理 Agent</strong>：</p>
<ul>
<li>根據這個 Sprint 或 Release 所有 PR / Work Items，整理出對使用者友善的更新說明。</li>
<li>針對不同受眾（End User / 內部技術人員 / 管理層）產生不同版本的摘要。</li>
</ul>
</li>
<li>
<p><strong>溝通與訓練素材 Agent</strong>：</p>
<ul>
<li>把新功能的設計說明轉成簡報、教學稿、FAQ，減少重複解釋的時間。</li>
</ul>
</li>
</ul>
<p>這些工作本質上都很適合由 Agent 先做 70%，再由人類補上最後 30% 的細緻度與裁量。</p>
<br>
<h2 id="Explorer-本身可以怎麼擴充？">Explorer 本身可以怎麼擴充？</h2>
<p>目前的 Agentic SDLC Explorer 主要還是「情境導覽 + 視覺化地圖」，但因為是走 <strong>Vite + React 的標準前端專案結構</strong>，未來可以有很多延伸方向，例如：</p>
<ul>
<li>在每個 SDLC 區塊下，掛上真實後端 Agent 的 API，讓使用者可以直接在畫面上觸發 Demo（例如：產生測試、總結 Issue、分析 Log）。</li>
<li>加入篩選與標籤功能，依角色（開發 / 測試 / DevOps / PM）或成熟度（PoC / Pilot / Production）來瀏覽適合的情境。</li>
<li>把成功案例與實作筆記寫回到這個網站，形成一種「Agentic SDLC 實戰索引」。</li>
</ul>
<p>如果你有其他想補充的場景，也非常歡迎直接發 PR 到 GitHub 專案，一起把這張 SDLC + Agent 地圖補得更完整。</p>
<br>
<h2 id="結語">結語</h2>
<p>Agent AI 帶來的不是「一個超強的萬能助理」，而是讓我們可以在 SDLC 的各個角落，放進許多專精且可協作的 Agent，幫忙處理大量重複、機械、需要跨系統查資料的工作。<strong>Agentic SDLC Explorer</strong> 這個 side project，只是我在顧問工作中為了方便說明而做的一個小工具，但也希望它能成為大家在規劃 AI / Agent 導入時的一個起點：</p>
<ul>
<li>先看清楚目前 SDLC 上有哪些痛點與瓶頸。</li>
<li>想像如果有一個 Agent 待在那個位置，它可以幫你做什麼。</li>
<li>從最有感、風險最低的一兩個情境開始試驗。</li>
</ul>
<p>Demo Site 我已經發佈到 <a class="link"   href="https://sdlc.timlai.dev/" >https://sdlc.timlai.dev/<i class="fas fa-external-link-alt"></i></a> 大家也可以直接到 GitHub 專案 <a class="link"   href="https://github.com/timlai-tw/agentic-ai-sdlc" >https://github.com/timlai-tw/agentic-ai-sdlc<i class="fas fa-external-link-alt"></i></a> 提 issue、分享你在團隊裡導入 Agentic SDLC 的經驗，我也會持續在這個部落格記錄相關的實作心得與趨勢觀察。</p>
<div class="tips">
<font color="black">
<a class="link"   href="https://sdlc.timlai.dev"  target="_blank">⁍ Agentic AI and SDLC Orchestration<i class="fas fa-external-link-alt"></i></a><br>
<a class="link"   href="https://github.com/timlai-tw/agentic-ai-sdlc"  target="_blank">⁍ GitHub | Agentic SDLC Explorer<i class="fas fa-external-link-alt"></i></a>
</font>
</div>
]]></content>
      <tags>
        <tag>Agent AI</tag>
        <tag>Agentic AI</tag>
        <tag>SDLC</tag>
      </tags>
  </entry>
  <entry>
    <title>Azure DevOps MCP Server</title>
    <url>/post/2025/06/azure-devops-mcp-server/</url>
    <content><![CDATA[<img    
                       lazyload
                       alt="image"
                       data-src="/post/2025/06/azure-devops-mcp-server/mcp.png"
                         align="left" style="margin-right: 10px; width: 125px; border: 1px solid gray;"
                 > 
<p>隨著 AI 技術的蓬勃發展，軟體開發與運維 (DevOps) 流程正迎來一場革命性的轉變。傳統的 DevOps 強調自動化、持續整合與持續交付，但在面對日益複雜的專案協作與工具整合時，團隊仍需投入大量人力進行手動操作與跨系統協調。這時，AI 驅動的自動化與智慧化流程成為新一代 DevOps 的核心訴求。Model Context Protocol（MCP，模型上下文協議）正是在這樣的背景下誕生，為大型語言模型（LLM）與外部工具之間建立一套安全、模組化且可擴充的溝通標準。自微軟在上個月 Microsoft Build 2025 開發者大會宣佈會加入對 MCP 的支援，這個月 Azure DevOps MCP Server 也已公開預覽 (Public Preview)，本文將介紹 Azure DevOps MCP Server 提供了哪些工具。</p>
<!-- 結合 MCP 的 Azure DevOps MCP Server，讓 AI 助理（如 GitHub Copilot）能直接理解專案脈絡、查詢與操作 DevOps 資源，甚至根據自然語言指令自動執行工作，徹底改變開發者與工具的互動模式。本文將介紹 MCP 的由來、Azure DevOps MCP 的分類與工具，並詳細說明各工具的實際用途，協助你掌握這項前瞻技術如何為團隊帶來更高的生產力與協作效率。 -->
<br>
<span id="more"></span>
<br>
<h2 id="MCP-的由來">MCP 的由來</h2>
<p>MCP（Model Context Protocol）最初由 Anthropic 在 2024 年 11 月提出，是一套專為大型語言模型設計的開放式標準協議。其核心目標在於讓 LLM 能夠安全、模組化且可擴充地存取外部工具與資料來源。MCP 的設計理念類似於 API，但傳統 API 是給開發者使用，強調結構化資料與嚴謹格式；而 MCP 則是為 AI 模型量身打造，讓模型能用自然語言理解上下文，並以「對話」方式與外部系統互動。對使用者而言，整個過程更貼近人類溝通習慣，MCP 讓 LLM 不只是資訊生成者，更能成為任務執行者，推動開發流程從「使用工具」進化為「與工具對話」。</p>
<h2 id="MCP-和-Function-Calling-的不同">MCP 和 Function Calling 的不同</h2>
<table>
<thead>
<tr>
<th style="text-align:left">功能</th>
<th style="text-align:left">Function Calling</th>
<th style="text-align:left">MCP</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">主要目的</td>
<td style="text-align:left">把自然語言請求轉成結構化函數呼叫，由應用程式執行</td>
<td style="text-align:left">標準化 LLM 與外部工具/資料源的連接與執行流程</td>
</tr>
<tr>
<td style="text-align:left">控制權</td>
<td style="text-align:left">LLM 供應商（如：OpenAI、Anthropic）</td>
<td style="text-align:left">外部系統（MCP Server/Client）</td>
</tr>
<tr>
<td style="text-align:left">輸出格式</td>
<td style="text-align:left">不同 LLM 廠商格式各異（通常為 JSON）</td>
<td style="text-align:left">統一採用標準協議（如：JSON-RPC）</td>
</tr>
<tr>
<td style="text-align:left">擴展性/互通性</td>
<td style="text-align:left">需為每個工具自訂整合，跨平台困難</td>
<td style="text-align:left">一次整合，多方兼容，工具可被多個 LLM 共用</td>
</tr>
<tr>
<td style="text-align:left">標準化</td>
<td style="text-align:left">無統一標準，各家 LLM 格式不同</td>
<td style="text-align:left">統一協議，保證跨工具、跨平台一致性</td>
</tr>
<tr>
<td style="text-align:left">適用場景</td>
<td style="text-align:left">單一應用、簡單任務、需嚴格控制副作用</td>
<td style="text-align:left">多工具、多平台、大規模協作與自動化</td>
</tr>
</tbody>
</table>
<p>MCP 並非為了取代 Function Calling 而推出，兩者是互補關係：</p>
<ul>
<li><strong>Function Calling</strong>：讓 LLM 能夠「決定」要做什麼（下訂單）。</li>
<li><strong>MCP</strong>：讓這些決策能夠在不同工具、平台間「被執行」且流程標準化（執行訂單）。</li>
</ul>
<p>實際應用中，LLM 會先用 Function Calling 決定要呼叫哪個工具、什麼參數，然後 MCP 負責將這個請求標準化、分發到對應的 MCP Server 執行，並將結果回傳。其他關於 MCP 更多的詳細資訊，可以參考下列 Anthropic 官網內容：</p>
<div class="tips">
<font color="black">
<a class="link"   href="https://docs.anthropic.com/zh-TW/docs/agents-and-tools/mcp"  target="_blank">⁍ 模型上下文協議 (MCP)<i class="fas fa-external-link-alt"></i></a><br>
<a class="link"   href="https://github.com/modelcontextprotocol"  target="_blank">⁍ GitHub | Model Context Protocol<i class="fas fa-external-link-alt"></i></a>
</font>
</div>
<h2 id="Azure-DevOps-MCP-Server">Azure DevOps MCP Server</h2>
<p>Azure DevOps MCP Server 以 MCP 為基礎，提供一套可由 AI 助手（如：GitHub Copilot）透過自然語言存取與操作 Azure DevOps 相關服務的工具集合。這些工具依功能可分類如下幾種：</p>
<h2 id="🧿-核心-Core">🧿 核心 (Core)</h2>
<table>
<thead>
<tr>
<th style="text-align:left">工具名稱</th>
<th style="text-align:left">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">core_list_project_teams</td>
<td style="text-align:left">取得指定專案的團隊清單</td>
</tr>
<tr>
<td style="text-align:left">core_list_projects</td>
<td style="text-align:left">取得組織下所有專案清單</td>
</tr>
</tbody>
</table>
<h2 id="⚒️-工作-Work">⚒️ 工作 (Work)</h2>
<table>
<thead>
<tr>
<th style="text-align:left">工具名稱</th>
<th style="text-align:left">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">work_list_team_iterations</td>
<td style="text-align:left">取得專案中某團隊的所有迭代清單</td>
</tr>
<tr>
<td style="text-align:left">work_create_iterations</td>
<td style="text-align:left">在指定專案中建立新迭代</td>
</tr>
<tr>
<td style="text-align:left">work_assign_iterations</td>
<td style="text-align:left">將既有迭代指派給專案中的團隊</td>
</tr>
</tbody>
</table>
<h2 id="📅-工作項目-Work-Items">📅 工作項目 (Work Items)</h2>
<table>
<thead>
<tr>
<th style="text-align:left">工具名稱</th>
<th style="text-align:left">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">wit_my_work_items</td>
<td style="text-align:left">取得目前使用者相關的工作項目</td>
</tr>
<tr>
<td style="text-align:left">wit_list_backlogs</td>
<td style="text-align:left">取得專案與團隊的待辦清單</td>
</tr>
<tr>
<td style="text-align:left">wit_list_backlog_work_items</td>
<td style="text-align:left">取得指定專案、團隊及類別的待辦工作項目</td>
</tr>
<tr>
<td style="text-align:left">wit_get_work_item</td>
<td style="text-align:left">依 ID 取得單一工作項目</td>
</tr>
<tr>
<td style="text-align:left">wit_get_work_items_batch_by_ids</td>
<td style="text-align:left">批次取得多個工作項目</td>
</tr>
<tr>
<td style="text-align:left">wit_update_work_item</td>
<td style="text-align:left">依 ID 更新工作項目欄位</td>
</tr>
<tr>
<td style="text-align:left">wit_create_work_item</td>
<td style="text-align:left">在指定專案建立新工作項目</td>
</tr>
<tr>
<td style="text-align:left">wit_list_work_item_comments</td>
<td style="text-align:left">取得指定工作項目的留言</td>
</tr>
<tr>
<td style="text-align:left">wit_get_work_items_for_iteration</td>
<td style="text-align:left">取得指定迭代的所有工作項目</td>
</tr>
<tr>
<td style="text-align:left">wit_add_work_item_comment</td>
<td style="text-align:left">為指定工作項目新增留言</td>
</tr>
<tr>
<td style="text-align:left">wit_add_child_work_item</td>
<td style="text-align:left">由父項目建立子工作項目</td>
</tr>
<tr>
<td style="text-align:left">wit_link_work_item_to_pull_request</td>
<td style="text-align:left">將工作項目連結至現有 Pull Request</td>
</tr>
<tr>
<td style="text-align:left">wit_get_work_item_type</td>
<td style="text-align:left">取得指定工作項目類型</td>
</tr>
<tr>
<td style="text-align:left">wit_get_query</td>
<td style="text-align:left">依 ID 或路徑取得查詢</td>
</tr>
<tr>
<td style="text-align:left">wit_get_query_results_by_id</td>
<td style="text-align:left">依查詢 ID 取得查詢結果</td>
</tr>
<tr>
<td style="text-align:left">wit_update_work_items_batch</td>
<td style="text-align:left">批次更新多個工作項目</td>
</tr>
<tr>
<td style="text-align:left">wit_close_and_link_workitem_duplicates</td>
<td style="text-align:left">關閉重複的工作項目</td>
</tr>
<tr>
<td style="text-align:left">wit_work_items_link</td>
<td style="text-align:left">批次連結多個工作項目</td>
</tr>
</tbody>
</table>
<h2 id="📁-原始碼儲存庫-Repositories">📁 原始碼儲存庫 (Repositories)</h2>
<table>
<thead>
<tr>
<th style="text-align:left">工具名稱</th>
<th style="text-align:left">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">repo_list_repos_by_project</td>
<td style="text-align:left">取得專案下所有儲存庫</td>
</tr>
<tr>
<td style="text-align:left">repo_list_pull_requests_by_repo</td>
<td style="text-align:left">取得指定儲存庫的 Pull Requests</td>
</tr>
<tr>
<td style="text-align:left">repo_list_pull_requests_by_project</td>
<td style="text-align:left">取得專案下所有 Pull Requests</td>
</tr>
<tr>
<td style="text-align:left">repo_list_branches_by_repo</td>
<td style="text-align:left">取得指定儲存庫的分支</td>
</tr>
<tr>
<td style="text-align:left">repo_list_my_branches_by_repo</td>
<td style="text-align:left">取得指定儲存庫中屬於自己的分支</td>
</tr>
<tr>
<td style="text-align:left">repo_list_pull_request_threads</td>
<td style="text-align:left">取得 Pull Request 的討論串</td>
</tr>
<tr>
<td style="text-align:left">repo_list_pull_request_thread_comments</td>
<td style="text-align:left">取得討論串中的留言</td>
</tr>
<tr>
<td style="text-align:left">repo_get_repo_by_name_or_id</td>
<td style="text-align:left">依名稱或 ID 取得儲存庫</td>
</tr>
<tr>
<td style="text-align:left">repo_get_branch_by_name</td>
<td style="text-align:left">依名稱取得分支</td>
</tr>
<tr>
<td style="text-align:left">repo_get_pull_request_by_id</td>
<td style="text-align:left">依 ID 取得 Pull Request</td>
</tr>
<tr>
<td style="text-align:left">repo_create_pull_request</td>
<td style="text-align:left">建立新的 Pull Request</td>
</tr>
<tr>
<td style="text-align:left">repo_update_pull_request_status</td>
<td style="text-align:left">更新 Pull Request 狀態（啟用或放棄）</td>
</tr>
<tr>
<td style="text-align:left">repo_reply_to_comment</td>
<td style="text-align:left">回覆 Pull Request 的指定留言</td>
</tr>
<tr>
<td style="text-align:left">repo_resolve_comment</td>
<td style="text-align:left">解決 Pull Request 討論串中的留言</td>
</tr>
</tbody>
</table>
<h2 id="🛰️-建置-Builds">🛰️ 建置 (Builds)</h2>
<table>
<thead>
<tr>
<th style="text-align:left">工具名稱</th>
<th style="text-align:left">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">build_get_definitions</td>
<td style="text-align:left">取得專案的建置定義清單</td>
</tr>
<tr>
<td style="text-align:left">build_get_definition_revisions</td>
<td style="text-align:left">取得指定建置定義的歷史版本</td>
</tr>
<tr>
<td style="text-align:left">build_get_builds</td>
<td style="text-align:left">取得專案的建置清單</td>
</tr>
<tr>
<td style="text-align:left">build_get_log</td>
<td style="text-align:left">取得指定建置的日誌</td>
</tr>
<tr>
<td style="text-align:left">build_get_log_by_id</td>
<td style="text-align:left">依日誌 ID 取得建置日誌</td>
</tr>
<tr>
<td style="text-align:left">build_get_changes</td>
<td style="text-align:left">取得指定建置的異動</td>
</tr>
<tr>
<td style="text-align:left">build_run_build</td>
<td style="text-align:left">觸發指定定義的新建置</td>
</tr>
<tr>
<td style="text-align:left">build_get_status</td>
<td style="text-align:left">取得指定建置的狀態</td>
</tr>
</tbody>
</table>
<h2 id="🚀-發行-Releases">🚀 發行 (Releases)</h2>
<table>
<thead>
<tr>
<th style="text-align:left">工具名稱</th>
<th style="text-align:left">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">release_get_definitions</td>
<td style="text-align:left">取得專案的發行定義清單</td>
</tr>
<tr>
<td style="text-align:left">release_get_releases</td>
<td style="text-align:left">取得專案的發行清單</td>
</tr>
</tbody>
</table>
<h2 id="🧪-測試計畫-Test-Plans">🧪 測試計畫 (Test Plans)</h2>
<table>
<thead>
<tr>
<th style="text-align:left">工具名稱</th>
<th style="text-align:left">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">testplan_create_test_plan</td>
<td style="text-align:left">建立新的測試計畫</td>
</tr>
<tr>
<td style="text-align:left">testplan_create_test_case</td>
<td style="text-align:left">建立新的測試案例</td>
</tr>
<tr>
<td style="text-align:left">testplan_add_test_cases_to_suite</td>
<td style="text-align:left">將既有測試案例加入測試套件</td>
</tr>
<tr>
<td style="text-align:left">testplan_list_test_plans</td>
<td style="text-align:left">分頁取得專案的測試計畫清單，可過濾啟用狀態及細節</td>
</tr>
<tr>
<td style="text-align:left">testplan_list_test_cases</td>
<td style="text-align:left">取得測試計畫中的測試案例</td>
</tr>
<tr>
<td style="text-align:left">testplan_show_test_results_from_build_id</td>
<td style="text-align:left">依建置 ID 取得測試結果</td>
</tr>
</tbody>
</table>
<h2 id="🔎-搜尋-Search">🔎 搜尋 (Search)</h2>
<table>
<thead>
<tr>
<th style="text-align:left">工具名稱</th>
<th style="text-align:left">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">search_code</td>
<td style="text-align:left">依關鍵字搜尋原始碼</td>
</tr>
<tr>
<td style="text-align:left">search_wiki</td>
<td style="text-align:left">依關鍵字搜尋 Wiki</td>
</tr>
<tr>
<td style="text-align:left">search_workitem</td>
<td style="text-align:left">依關鍵字搜尋工作項目</td>
</tr>
</tbody>
</table>
<h2 id="VSCode-的-MCP-設定">VSCode 的 MCP 設定</h2>
<p>在 VSCode 中要設定 MCP Server 可以按 <strong><code>Ctrl + ,</code></strong> 打開 Settings 畫面，然後點選右上角 Open Settings 圖示，加入下列設定區塊即可，其中 ado_org 代表 Azure DevOps Services 的 Orgnization 名稱，運行 MCP Server 時會提示在 VSCode 上方讓使用者輸入設定。</p>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/06/azure-devops-mcp-server/open_settings.png"
                        class=""
                 >
<br>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/06/azure-devops-mcp-server/mcp_setting.png"
                        class=""
                 >
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;inputs&quot;:</span> [</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="attr">&quot;id&quot;:</span> <span class="string">&quot;ado_org&quot;</span>,</span><br><span class="line">         <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;promptString&quot;</span>,</span><br><span class="line">         <span class="attr">&quot;description&quot;:</span> <span class="string">&quot;Azure DevOps organization name  (e.g. &#x27;contoso&#x27;)&quot;</span></span><br><span class="line">     &#125;</span><br><span class="line">   ],</span><br><span class="line">   <span class="attr">&quot;servers&quot;:</span> &#123;</span><br><span class="line">     <span class="attr">&quot;ado&quot;:</span> &#123;</span><br><span class="line">         <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;stdio&quot;</span>,</span><br><span class="line">         <span class="attr">&quot;command&quot;:</span> <span class="string">&quot;npx&quot;</span>,</span><br><span class="line">         <span class="attr">&quot;args&quot;:</span> [</span><br><span class="line">             <span class="string">&quot;-y&quot;</span>,</span><br><span class="line">             <span class="string">&quot;@azure-devops/mcp&quot;</span>,</span><br><span class="line">             <span class="string">&quot;$&#123;input:ado_org&#125;&quot;</span></span><br><span class="line">         ]</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<p>而在使用前也必需先以 <strong><code>az login</code></strong> 登入帳號取得使用權限，才能讓 Azure DevOps MCP Server 正常存取資源，要運行或停止設定檔的 MCP Server 僅需要在存檔後，每個 MCP Server 名稱上方就會出現 Start/Stop 的字樣可以點選。</p>
<br>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/06/azure-devops-mcp-server/az_login.png"
                        class=""
                 >
<br>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/06/azure-devops-mcp-server/start_mcp.png"
                        class=""
                 >
<br>
完成 settings.json 的設定並啟動 ado 這個 MCP Server 後，我們就可以在 GitHub Copilot 的 Agent mode 中調用前述整理的各項工具。在對話過程中，GitHub Copilot 會同時列出目前可用的工具清單，讓所選用的模型 (如：GPT-4o) 能根據指令調用相關工具，並將執行結果回傳給使用者，協助回覆各類查詢。
<br>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/06/azure-devops-mcp-server/agent_mode.png"
                        class=""
                 >
<h2 id="結語">結語</h2>
<p>有了 Azure DevOps MCP Server 提供的工具後，我們就可以透過對話的方式來互動取得 Azure DevOps Services 相關資訊，並自動執行各種開發、協作與運維任務，讓 AI 助理真正成為團隊的智慧夥伴。MCP 標準的導入不僅大幅降低了跨系統整合的門檻，也讓開發流程更具彈性與擴展性，目前 Azure DevOps MCP Server 僅支援雲端的 Azure DevOps Services，尚不支援地端 Azure DevOps Server 的存取方式 (依目前得知的消息，未來幾個月內也不會提供)，但其實要實作 MCP Server 來自己串接這一段也不是太困難的問題，後續有機會再開一篇文章向大家說明。</p>
<div class="tips">
<font color="black">
<a class="link"   href="https://github.com/microsoft/mcp"  target="_blank">⁍ GitHub | mcp<i class="fas fa-external-link-alt"></i></a><br>
<a class="link"   href="https://github.com/microsoft/azure-devops-mcp"  target="_blank">⁍ GitHub | azure-devops-mcp<i class="fas fa-external-link-alt"></i></a><br>
<a class="link"   href="https://learn.microsoft.com/en-us/azure/developer/azure-mcp-server/tools/"  target="_blank">⁍ What are the Azure MCP Server tools?<i class="fas fa-external-link-alt"></i></a>
</font>
</div>]]></content>
      <tags>
        <tag>Azure DevOps</tag>
        <tag>MCP</tag>
      </tags>
  </entry>
  <entry>
    <title>Chrome DevTools MCP</title>
    <url>/post/2025/10/chrome-devtools-mcp/</url>
    <content><![CDATA[<img    
                       lazyload
                       alt="image"
                       data-src="/post/2025/10/chrome-devtools-mcp/ChromeDevTools.jpg"
                         align="left" style="margin-right: 10px; width: 125px; border: 1px solid gray;"
                 > 
<p>無論是前端或後端開發工程師，相信大家都經常在瀏覽器中按下 <strong><code>F12</code></strong> 使用 Developer Tool。這個開發者工具不僅能檢視與調整頁面上的 HTML 元素，也能協助測試與偵錯前端 JavaScript。此外，還可以模擬各種裝置的瀏覽情境，或限制網路速度以模擬極端的使用狀況。這些功能都包含在 Chrome DevTools MCP 提供的工具清單中，本文將帶大家快速了解這些工具在實際開發場景中的應用方式。</p>
<span id="more"></span>
<br>
<h2 id="主要特色">主要特色</h2>
<p>透過 MCP 提供的多元服務串接，我們可以以自然語言對話的方式，為 LLMs 帶來更多應用可能。目前 Chrome DevTools MCP 主要涵蓋三大面向：<strong>自動化操作</strong>、<strong>效能洞察</strong>，以及<strong>瀏覽器操作與偵錯</strong>。不論是頁面上的 HTML 元素、操作過程的截圖，或是網路請求的詳細資訊，都能作為上下文 (Context) 的來源，協助我們運用 LLMs 執行各種任務。</p>
<p>環境需求：</p>
<ul>
<li>Node.js v20.19 以上</li>
<li>Chrome 瀏覽器</li>
<li>npm</li>
</ul>
<p>MCP 設定：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;mcpServers&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;chrome-devtools&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npx&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;-y&quot;</span><span class="punctuation">,</span> <span class="string">&quot;chrome-devtools-mcp@latest&quot;</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>Chrome DevTools MCP 目前分為 6 個類別，提供如下列 26 個工具：</p>
<h3 id="Input-automation">Input automation</h3>
<table>
<thead>
<tr>
<th style="text-align:left">工具名稱</th>
<th style="text-align:left">功能簡介</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">click</td>
<td style="text-align:left">點擊指定元素</td>
</tr>
<tr>
<td style="text-align:left">drag</td>
<td style="text-align:left">拖曳元素到指定位置</td>
</tr>
<tr>
<td style="text-align:left">fill</td>
<td style="text-align:left">填入欄位或選取項目</td>
</tr>
<tr>
<td style="text-align:left">fill_form</td>
<td style="text-align:left">批量填寫多個表單元素</td>
</tr>
<tr>
<td style="text-align:left">handle_dialog</td>
<td style="text-align:left">處理彈出對話框</td>
</tr>
<tr>
<td style="text-align:left">hover</td>
<td style="text-align:left">滑鼠懸停於元素上</td>
</tr>
<tr>
<td style="text-align:left">upload_file</td>
<td style="text-align:left">於檔案欄位上傳檔案</td>
</tr>
</tbody>
</table>
<p>使用 Input automation 可以讓我們操作鍵盤 (<strong><code>fill</code></strong> , <strong><code>fill_form</code></strong>)、滑鼠 (<strong><code>click</code></strong> , <strong><code>drag</code></strong> , <strong><code>hover</code></strong>) 在頁面上的各種行為，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">開啟 https://www.tenlong.com.tw/ 在 keyword 欄位輸入 &quot;ai agent&quot; 並送出 search 查詢動作。</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/10/chrome-devtools-mcp/example01.jpg"
                        class=""
                 >
<p>在上面截圖的執行過程可以看到 LLMs 理解我們所輸入的自然語言後，打開了 Chrome 瀏覽器自動使用了 <strong><code>fill</code></strong> 和 <strong><code>click</code></strong> 這兩個工作來達成任務，除此之外，因為 prompt 內容其實並沒有講得很清楚(沒有明確指定頁面元素ID)，所以它自己調用了 <strong><code>take_snapshot</code></strong> 截圖識別頁面內容來判斷下一步該如何進行，並回傳結果。</p>
<h3 id="Navigation-automation">Navigation automation</h3>
<table>
<thead>
<tr>
<th style="text-align:left">工具名稱</th>
<th style="text-align:left">功能簡介</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">close_page</td>
<td style="text-align:left">關閉分頁</td>
</tr>
<tr>
<td style="text-align:left">list_pages</td>
<td style="text-align:left">列出所有分頁</td>
</tr>
<tr>
<td style="text-align:left">navigate_page</td>
<td style="text-align:left">跳轉至指定網址</td>
</tr>
<tr>
<td style="text-align:left">navigate_page_history</td>
<td style="text-align:left">分頁歷史紀錄</td>
</tr>
<tr>
<td style="text-align:left">new_page</td>
<td style="text-align:left">開啟新分頁</td>
</tr>
<tr>
<td style="text-align:left">select_page</td>
<td style="text-align:left">設定操作目標分頁</td>
</tr>
<tr>
<td style="text-align:left">wait_for</td>
<td style="text-align:left">等待頁面出現指定文字</td>
</tr>
</tbody>
</table>
<p>透過 Navigation automation 可以協助我們管理操作多個分頁、控制分頁歷程以及在適當時機等待頁面內容出現，常見應用包括自動化測試流程、抓取需要登入或多頁互動的資料，以及在多分頁工作流程中切換操作目標。此類工具可讓 LLMs 以自然語言指令完成跨分頁的步驟：開啟新分頁、在目標分頁中等待特定文字出現、切換回原分頁或關閉不再需要的分頁，確保後續動作的執行，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.開啟 https://www.books.com.tw 並在 id 為 &quot;key&quot; 的文字方塊中輸入 &quot;ai agent&quot;，按下 title 為 &quot;搜尋&quot; 的按鈕。</span><br><span class="line">2.在新分頁開啟查詢列表第一筆的連結，回傳：書名、作者、出版日期、定價、優惠價。</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/10/chrome-devtools-mcp/example02-1.jpg"
                        class=""
                 >
<br>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/10/chrome-devtools-mcp/example02-2.jpg"
                        class=""
                 >
<h3 id="Emulation">Emulation</h3>
<table>
<thead>
<tr>
<th style="text-align:left">工具名稱</th>
<th style="text-align:left">功能簡介</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">emulate_cpu</td>
<td style="text-align:left">模擬 CPU 效能/限速</td>
</tr>
<tr>
<td style="text-align:left">emulate_network</td>
<td style="text-align:left">模擬網路狀況</td>
</tr>
<tr>
<td style="text-align:left">resize_page</td>
<td style="text-align:left">調整頁面視窗尺寸</td>
</tr>
</tbody>
</table>
<p>我們在前端開發時常會需要模擬不同裝置(解析度)來確認版型是否正確顯示，以往我們會需要手動切換，甚至建一個新的裝置設定來配合測試，現在就可以用自然語言表達，並讓 LLMs 來幫我們 snapshot 截圖。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用 iPhone 13 Pro、iPad 6、FullHD 三種檢視方式打開 https://developer.chrome.com/blog/chrome-devtools-mcp?hl=zh-tw </span><br><span class="line">並截圖儲存在目前工作目錄中，檔名使用 yyyyMMdd-裝置名稱.jpg。</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/10/chrome-devtools-mcp/example03.jpg"
                        class=""
                 >
<h3 id="Performance">Performance</h3>
<table>
<thead>
<tr>
<th style="text-align:left">工具名稱</th>
<th style="text-align:left">功能簡介</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">performance_analyze_insight</td>
<td style="text-align:left">詳細分析效能洞見</td>
</tr>
<tr>
<td style="text-align:left">performance_start_trace</td>
<td style="text-align:left">開始頁面效能記錄</td>
</tr>
<tr>
<td style="text-align:left">performance_stop_trace</td>
<td style="text-align:left">停止頁面效能記錄</td>
</tr>
</tbody>
</table>
<p>上面有一個模擬網路狀況 <strong><code>emulate_network</code></strong> 在實務上也蠻常使用的，可以模擬在網路傳輸速度不佳或是特定的網路傳輸情境，以確認我們的頁面呈現或是功能互動會不會因為傳輸過久而造成什麼問題，再搭配 <strong><code>performance_start_trace</code></strong> 和 <strong><code>performance_stop_trace</code></strong> 就可以很輕易的就達成測試並記錄數值的需求。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">模擬以 &quot;Fast 4G&quot; 開啟 https://developer.chrome.com/blog/chrome-devtools-mcp?hl=zh-tw </span><br><span class="line">確認整頁載入需要花費多少時間，不需要設定 timeout 時間，直到整頁載入完成為止。</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/10/chrome-devtools-mcp/example04_05.jpg"
                        class=""
                 >
<h3 id="Network">Network</h3>
<table>
<thead>
<tr>
<th style="text-align:left">工具名稱</th>
<th style="text-align:left">功能簡介</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">get_network_request</td>
<td style="text-align:left">取得指定的請求資訊</td>
</tr>
<tr>
<td style="text-align:left">list_network_requests</td>
<td style="text-align:left">列出當前頁面網路請求</td>
</tr>
</tbody>
</table>
<p>程式開發人員工具中的 Network 可以看到頁面載入的所有資訊，在介面上也可以透過各種條件篩選或是排序來找到我們想要分析的目標，現在 Chrome DevTools MCP 也提供了對應的單筆、多筆查詢，應用上可以像是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">打開 https://www.momoshop.com.tw/ 分析頁面中哪一個項目的 response time 最久?</span><br><span class="line">整個頁面載入使用多少傳輸量、多少時間?</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/10/chrome-devtools-mcp/example06.jpg"
                        class=""
                 >
<h3 id="Debugging">Debugging</h3>
<table>
<thead>
<tr>
<th style="text-align:left">工具名稱</th>
<th style="text-align:left">功能簡介</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">evaluate_script</td>
<td style="text-align:left">執行 JavaScript 程式片段</td>
</tr>
<tr>
<td style="text-align:left">list_console_messages</td>
<td style="text-align:left">列出 console 訊息</td>
</tr>
<tr>
<td style="text-align:left">take_screenshot</td>
<td style="text-align:left">擷取頁面螢幕截圖</td>
</tr>
<tr>
<td style="text-align:left">take_snapshot</td>
<td style="text-align:left">取得當前頁面元素快照</td>
</tr>
</tbody>
</table>
<p>前面幾張執行過程截圖當中都有穿插呼叫 <strong><code>evaluate_script</code></strong>，它主要是注入 JavaScript 程式片段執行並讀取回傳結果，內容當然可以自己撰寫提供給 LLMs 呼叫，但比較多數的情況可能會是 LLMs 理解完我們所提供的上下文(Context)後，為了達到最終任務目的自己加上的。這裡有兩個名稱很像的 tool：</p>
<ul>
<li><strong><code>take_screenshot</code></strong>：就是把目前呈現的畫面內容截圖，可以儲存成 PNG、JPEG、WebP。</li>
<li><strong><code>take_snapshot</code></strong>：將目前畫面元素以記錄 uid 的方式將所有相關屬性記錄下來，這個適合用來作為上下文提供給 LLMs 使用，不適合人工閱讀。</li>
</ul>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/10/chrome-devtools-mcp/example07.jpg"
                        class=""
                 >
<h2 id="總結">總結</h2>
<p>Chrome DevTools MCP 讓自然語言操控瀏覽器自動化、效能分析與偵錯成為可能，將原本需要撰寫程式或熟悉工具操作的流程，轉化為直覺、可被人類語句驅動的工作流程。透過 Input / Navigation / Emulation / Performance / Network / Debugging 等工具組合，LLMs 能理解任務意圖、自動擷取頁面上下文並執行相應操作，極大地降低了自動化門檻。<br><br>
對一般使用者來說，要更容易達成自動化需求可以採取幾個實用做法：</p>
<ul>
<li>以明確且分步的自然語言描述任務，將複雜流程拆成小步驟（例如：導航 → 填表 → 等待 → 截圖）。</li>
<li>善用快照與截圖作為上下文回饋，讓 LLM 有更精準的操作依據。</li>
<li>建立常用 prompt 與範本（templates），將成功流程模組化、重複使用。</li>
<li>先從小範圍任務切入（如：自動化登入或資料擷取），驗證後再串接更複雜的操作或流程。</li>
<li>為關鍵步驟加入驗證與錯誤處理（檢查元素存在、逾時重試），確保穩定性與安全性。</li>
</ul>
<p><br>結合自然語言與 Chrome DevTools MCP，可以讓更多人不論工程背景與否，更快速地做到瀏覽器自動化與偵錯，提升開發效率並把重複性工作交給工具處理，讓團隊專注在更具價值的設計與判斷。<br>
<br></p>
<div class="tips">
<font color="black">
<a class="link"   href="https://developer.chrome.com/blog/chrome-devtools-mcp?hl=zh-tw"  target="_blank">⁍ AI 代理程式適用的 Chrome 開發人員工具 (MCP)<i class="fas fa-external-link-alt"></i></a><br>
<a class="link"   href="https://github.com/ChromeDevTools/chrome-devtools-mcp"  target="_blank">⁍ GitHub | ChromeDevTools MCP<i class="fas fa-external-link-alt"></i></a><br>
</font>
</div>
]]></content>
      <tags>
        <tag>MCP</tag>
      </tags>
  </entry>
  <entry>
    <title>Azure DevOps Server 正式版發佈</title>
    <url>/post/2025/12/azure-devops-server-ga/</url>
    <content><![CDATA[<img    
                       lazyload
                       alt="image"
                       data-src="/post/2025/12/azure-devops-server-ga/ga.jpg"
                         align="left" style="margin-right: 10px; width: 125px; border: 1px solid gray;"
                 >
<p>微軟在 2025/12/9 宣佈 Azure DevOps Server 已正式達到 GA（General Availability，正式版）狀態，這次 RTW 版本是針對企業自架環境的一次重要里程碑：除了支援 SQL Server 2025、整合 RC 階段已釋出的功能外，也彙整了多項在 Boards、Repos、Pipelines、Test Plans、Reporting、Wiki 等服務上的改進。本文說明為什麼名稱不再掛版號、GA 的發佈重點，以及各服務的新功能亮點，方便大家評估升級與導入時機 😊。</p>
<span id="more"></span>
<br>
<br>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/12/azure-devops-server-ga/azure-devops-server-ga.jpg"
                        class=""
                 >
<br>
<h2 id="為什麼-Azure-DevOps-Server-不再加上版號？">為什麼 Azure DevOps Server 不再加上版號？</h2>
<p>如果大家最近有留意微軟官方文件，會發現標題多半只有「Azure DevOps Server」，而不是像以前那種「Azure DevOps Server 2022 / 2020」清楚掛版號的寫法，主要可以從幾個方向來理解：</p>
<ul>
<li><strong>名稱回到「產品」本身，而不是單一年度版本</strong><br>
微軟希望把 Azure DevOps Server 視為一個持續演進的產品，而不是每隔幾年就出一個「完全不同」的新名字。實際上底層還是有 build number 與發行批次，只是對使用者來說，重點放在「最新 Azure DevOps Server + 對應累積更新」；就像我常被客戶問到：今年都 2025 年了，Azure DevOps Server 最新版還在 2022.2，微軟是不是很久沒更新這個產品了？<s>(大誤)</s></li>
<li><strong>以「發行批次 / 累積更新」與支援週期為主軸</strong><br>
官方的 Release Notes 也改成「Azure DevOps Server Release Notes」這樣的形式，新的 RTW/RC、累積更新（cumulative updates）都掛在同一頁，讓大家用「目前安裝的是哪一個 release」來辨識，而不是只記年份或版號。</li>
<li><strong>與雲端 Azure DevOps Services 的節奏對齊</strong><br>
雲端服務本來就是持續更新、不強調版號，地端版也朝這個方向靠攏。對於有混合情境（雲端 + 地端）的團隊來說，在比較功能差異或規劃遷移時也比較直覺。</li>
</ul>
<p>換句話說：版本仍然存在（build number、支援週期一樣重要），只是公開溝通時不再把「年份」放在產品名稱裡，而是強調「這一個 Azure DevOps Server 發行批次」所帶來的變化與支援範圍。</p>
<br>
<h2 id="正式版發佈重點（GA-RTW-Highlights）">正式版發佈重點（GA / RTW Highlights）</h2>
<p>根據官方部落格與 Release Notes，這次 Azure DevOps Server RTW 主要有幾個值得注意的重點：</p>
<ul>
<li><strong>從 RC 過渡到正式版，適合生產環境全面部署</strong><br>
這次 GA 是在 RC 基礎上進一步收斂修正後的 RTW 版本，針對企業實際使用情境做了額外的穩定度與品質調整，定位上已經是可以在正式環境大規模導入的版本。</li>
<li><strong>支援 SQL Server 2025</strong><br>
RTW 明確標示為「支援 SQL Server 2025 的彙總發行（roll up）」；如果大家準備在資料庫層升級到 SQL Server 2025，這個版本就是官方對應的 Azure DevOps Server 搭配選項。</li>
<li><strong>直接升級路徑清楚</strong><br>
官方支援從 Azure DevOps Server 2019 / 2020 / 2022，或 Team Foundation Server 2015（含）之後的版本直接升級到 Azure DevOps Server。若還停在 TFS 2013 甚至更早，就需要先做中繼升級（要先升級到 2015 才能再升到目前最新的 Azure DevOps Server）。<br>
<mark>同時也提醒：TFS 2015 已在 2025/10/14 結束延伸支援，若還停留在舊版本，這次 GA 其實是很好的「順勢升級」時機。</mark></li>
<li><strong>品質修正與細節優化</strong><br>
RTW 版本除了合併本地化調整外，還修正了多個實務上會遇到的問題，例如：
<ul>
<li>儀表板 Code Tile 在儲存庫或分支名稱太長時的顯示問題。</li>
<li>GitHub PR 狀態透過 webhook 回寫時，已合併與未合併都被記成 Closed 的狀況，現在會依 payload 的 merged flag 正確區分。</li>
<li>某些 Work Item Linking 情境下，Visual Studio 會因遞迴屬性造成當機的問題。</li>
<li>Collection 設定頁中，如果 Analytics 被暫停或停用，Agent Pool 頁面會載入失敗的情形，現在已可正常顯示。</li>
</ul>
</li>
<li><strong>完整的下載與文件連結</strong><br>
官方提供 ISO、Web Install、下載頁、系統需求/相容性與安裝文件，方便 IT 做標準化佈署與維運規劃。</li>
</ul>
<br>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/12/azure-devops-server-ga/upgrade-azure-devops-server.png"
                        class=""
                 >
<br>
<h2 id="新功能與改進：各服務重點整理">新功能與改進：各服務重點整理</h2>
<p>這次 GA 包含 RC 階段累積的一大串新功能與改進，底層細節很多，這裡依服務簡單抓幾個實務上比較有感的部分做摘要，方便大家快速掌握方向。</p>
<h3 id="General">General</h3>
<ul>
<li><strong>Markdown 程式碼區塊一鍵複製</strong><br>
Wiki、Repos 檔案預覽、PR 討論與 Work item 討論中的程式碼區塊，都多了一個 <strong><code>Copy to clipboard</code></strong> 按鈕，貼上範例或文件內容給團隊成員時效率更高。</li>
<li><strong>Delivery Plans 權限更細緻</strong><br>
新增「Manage Delivery Plans」專用權限，避免 Readers 類型的使用者不小心取得不必要的寫入權限，有助於大型組織控管誰可以建立或維護計畫視圖。</li>
</ul>
<h3 id="Boards">Boards</h3>
<ul>
<li><strong>GitHub PR 中的 AB# 連結顯示優化</strong><br>
在 PR 描述裡用 AB#123 這種方式連結 Work item 時，現在會直接出現在 GitHub PR 的 Development 區塊，從 PR 就能快速回到對應的 Azure Boards 工作項目，追蹤性更好。</li>
<li><strong>連結大量 GitHub Repos 的體驗改善</strong><br>
當一個 GitHub 組織裡有成千上萬個儲存庫時，以前在 Azure Boards 裡搜尋/連結很容易 timeout，現在搜尋與載入流程經過最佳化，大型組織會感受比較明顯。</li>
<li><strong>YAML Pipelines 的「Integrated in build」連結支援 GitHub</strong><br>
針對放在 GitHub 的 repo，現在 YAML pipeline 也能在完成 build 後自動在相關 Work item 上顯示「已在哪個 build 中整合」，讓 YAML 與傳統 Classic pipeline 在追蹤能力上更接近。</li>
<li><strong>GitHub 連線 REST API</strong><br>
新增一組 API 讓我們可以程式化地查詢、新增或移除 GitHub Repositories 連結，並將單一連線可掛載的 repo 上限從 500 提升到 2,000，方便用 Script 自動化維護大規模整合。</li>
<li><strong>刪除 Area / Iteration 更安全</strong><br>
現在只有在沒有任何 Work item 使用該路徑時，才能刪除 Area 或 Iteration，避免一個不小心影響一大堆看板、報表與存取權限。</li>
<li><strong>標籤與留言體驗升級</strong><br>
刪除的 Tag 不會再出現在建議清單裡，Work item 討論也能更方便貼上來自 Teams、Email、Word 等來源的圖片，REST API 另外新增留言數量限制，避免濫用導致效能或安全問題。</li>
<li><strong>Delivery Plans 數量上限提高</strong><br>
每個專案可建立的 Delivery Plans 上限，從 1,000 提升到 1,500，對於有大量跨團隊規劃需求的組織比較友善。</li>
</ul>
<h3 id="Repos">Repos</h3>
<ul>
<li><strong>可選擇停用新的 TFVC 儲存庫建立</strong><br>
Git 已經是主流，微軟也明確表示近年不再為 TFVC 加新功能。這次新增一個設定，讓我們可以關閉「建立新的 TFVC Repo」，既不影響既有 TFVC 專案，又能避免新專案再誤用 TFVC。</li>
<li><strong>Git submodules UI 支援</strong><br>
在檔案總管（Files hub）中，可以直接看懂並點進 submodule 指向的儲存庫與特定 commit，支援 Azure Repos、GitHub、GitLab、Bitbucket 等多種來源與 URL 格式，對有 Monorepo 或模組化拆分的團隊很實用。</li>
<li><strong>Repository Health and usage 面板</strong><br>
大型儲存庫會拖慢整體效能，現在 Repos 會監看儲存庫大小、commit 密度與內容結構等指標，必要時會提示 repository owner 檢查健康狀態與最佳化建議。</li>
<li><strong>自訂 PR 目標分支建議</strong><br>
只要在預設分支下建立 .azuredevops/pull_request_targets.yml，就可以定義常見的目標分支（例如 main、release/* 等），建立 PR 或系統自動建議 PR 時就會優先採用這些設定，減少開 PR 開錯分支的情況。</li>
<li><strong>Markdown 支援 Mermaid 圖表與 PR 標題搜尋</strong><br>
Repos 中的 Markdown 如果包含 mermaid 語法，現在會直接渲染成圖表；PR 列表頁也多了依標題搜尋的功能，方便在大量 PR 中快速找到目標。</li>
<li><strong>Pipelines Checkout 支援 sparse checkout</strong><br>
YAML 的 checkout 步驟新增 sparseCheckoutDirectories / sparseCheckoutPatterns 兩個設定，可只抓部分目錄或路徑，大型 repo 跑 CI/CD 時可以明顯縮短 checkout 時間（需要較新的 Agent 版本）。</li>
<li><strong>其他 API 與相容性改善</strong><br>
包含 cross-repo policy 預覽改成大小寫敏感（與實際規則一致）、TFVC check-in policy 新格式與 NuGet 套件更新、Repo 資訊 API 增加建立時間欄位、PR 查詢 API 可選擇回傳標籤（labels）等。</li>
</ul>
<h3 id="Pipelines">Pipelines</h3>
<ul>
<li><strong>TFX 與 Task Node runtime 健康檢查</strong><br>
用 TFX 發佈 extension 時，現在會檢查 Task 是否還在使用已 EOL 的 Node.js 版本（例如 Node.js 10/12/16 等），並給出警告訊息，提醒作者儘早升級。</li>
<li><strong>Pipeline 執行時也會對老舊 Node.js runner 發警示</strong><br>
如果某個 Task 仍依賴已不再維護的 Node.js 版本，執行時會在 log 裡出現警告，並提供官方升級指引連結；若暫時無法調整，也可以透過環境變數關閉這個檢查（不過長期來看還是建議盡快升級）。</li>
<li><strong>DockerCompose@0 改用 Compose v2 相容模式</strong><br>
Hosted Agent 即將移除 Docker Compose v1，因此 DockerCompose@0 Task 會在沒有 v1 時自動改用 v2 的相容模式；若專案還沒做好 v2 相容性，官方也提供範例腳本，教大家在 Pipeline 裡自行下載 v1 執行檔暫時過渡。</li>
<li><strong>使用 Microsoft Entra ID 存取 Azure Service Bus</strong><br>
新版 PublishToAzureServiceBus@2 Task 可以用 Azure Service Connection 搭配 Entra ID（原 Azure AD）存取 Service Bus，支援透過 RBAC 控制權限，比直接塞連線字串安全許多，自訂 server task 也能改用 service connection。</li>
</ul>
<h3 id="Test-Plans">Test Plans</h3>
<ul>
<li><strong>Test &amp; Feedback 擴充功能升級到 Manifest V3</strong><br>
Chrome/Edge 上的 Test &amp; Feedback 延伸模組已改用 Manifest V3，跟上瀏覽器的安全性與效能要求，功能維持不變。</li>
<li><strong>Azure Test Runner 與 Chrome 相容性修正</strong><br>
針對最近 Chrome 在 URL 處理上的變更，更新後的 Azure Test Runner 版本已修正啟動失敗的問題。</li>
<li><strong>Test Plans 與 Build Pipeline 整合更順</strong><br>
在 Test Plan 裡設定好的 Build 定義與 ID 會自動帶到 Web Runner，不需要每次手動重設，減少測試流程中的行政作業。</li>
<li><strong>支援透過 REST API 還原刪除的 Test Plan / Suite</strong><br>
不小心刪錯 Test Plan 或 Suite 時，現在可以用 API 查詢並還原（包含子階層），不用再倚賴客服協助，不過既有的執行結果等 artifact 並不會一併回復。</li>
<li><strong>匯出 Test Case 到 XLSX 支援自訂欄位</strong><br>
匯出測試案例時可以帶出自訂欄位，做報表或離線分析比較方便。</li>
<li><strong>測試執行體驗優化</strong><br>
包含 Test Plans 目錄支援欄位排序、Web/Desktop Runner 提供「Undo」回復步驟狀態、Publish code coverage v2 Task 支援更多格式與 PR 差異覆蓋率（diff coverage）等。</li>
<li><strong>Test Plans 支援 YAML Pipelines</strong><br>
除了 Classic pipeline，現在也可以選擇 YAML pipeline 來執行自動化測試，對已全面轉向 YAML 的團隊非常關鍵。</li>
</ul>
<h3 id="Reporting-Wiki">Reporting &amp; Wiki</h3>
<ul>
<li><strong>Backlog Rollup 資料顯示更清楚</strong><br>
Rollup 欄位會顯示最近一次成功計算的資料與時間戳記，即使 Analytics 略有延遲，也比較不會誤以為是資料遺失。</li>
<li><strong>Wiki 貼上 HTML 內容自動轉 Markdown</strong><br>
從瀏覽器、Office、Teams 等地方複製的 HTML 內容（像是清單、表格、圖片、連結等）貼到 Wiki 時，會自動轉成對應的 Markdown 語法，編輯起來順手很多。</li>
</ul>
<br>
<h2 id="什麼時候該考慮升級？">什麼時候該考慮升級？</h2>
<p>微軟於 2025/12/9 將 Azure DevOps Server 正式宣布為 GA，代表地端版本已足夠穩定可在企業生產環境部署，並帶來多項來自 RC 階段的修正與功能強化（例如更好的 GitHub 整合、Repos 健康檢查、sparse checkout、YAML 與 Test Plans 的整合等），對準備升級到 SQL Server 2025 或仍使用舊版 TFS 的團隊來說是很好的升級時機，但在規劃導入時記得也要留意安裝的最低需求 — Windows Server 2022 與 SQL Server 2022，詳細說明可以參考文末的連結。</p>
<p>綜合來看，這次 Azure DevOps Server GA 有幾個關鍵訊號：</p>
<ul>
<li>若後端環境有計畫升級到 <strong>SQL Server 2025</strong>，這是官方明確對應的 Azure DevOps Server 版本。</li>
<li>若還在 <strong>TFS 2015 或更舊版本</strong>，這次 GA 搭配延伸支援結束，是很適合規劃「一次到位」升級的時點。</li>
<li>如果團隊已大量使用 <strong>Git + YAML Pipelines + GitHub 整合</strong>，這一波新功能會讓追蹤性與操作體驗更接近雲端版 Azure DevOps Services。</li>
</ul>
<p>在官方的 Release Notes 頁面中有相關功能的截圖，有需要可以再參考下列參考連結。 😎</p>
<div class="tips">
<font color="black">
<a class="link"   href="https://devblogs.microsoft.com/devops/announcing-azure-devops-server-general-availability"  target="_blank">⁍ Announcing Azure DevOps Server General Availability<i class="fas fa-external-link-alt"></i></a><br>
<a class="link"   href="https://learn.microsoft.com/en-us/azure/devops/server/release-notes/azuredevopsserver?view=azure-devops-server"  target="_blank">⁍ Azure DevOps Server Release Notes <i class="fas fa-external-link-alt"></i></a><br>
<a class="link"   href="https://learn.microsoft.com/en-us/azure/devops/server/requirements?view=azure-devops-server&branch=releasenotes%2FAzureDevOpsServer2020"  target="_blank">⁍ Requirements for Azure DevOps on-premises <i class="fas fa-external-link-alt"></i></a>
</font>
</div>
]]></content>
      <tags>
        <tag>Azure DevOps</tag>
      </tags>
  </entry>
  <entry>
    <title>Azure DevOps 的 Wiki 應用</title>
    <url>/post/2025/10/azure-devops-wiki/</url>
    <content><![CDATA[<img    
                       lazyload
                       alt="image"
                       data-src="/post/2025/10/azure-devops-wiki/wiki.jpg"
                         align="left" style="margin-right: 10px; width: 125px; border: 1px solid gray;"
                 > 
<p>在軟體開發專案中，文件管理與知識分享一直是團隊協作的重要環節。Azure DevOps 提供了強大的 Wiki 功能，讓團隊能夠在專案中建立、編輯和組織文件。無論是產品規格、技術文件、FAQ 還是操作手冊，Wiki 都能協助團隊將知識系統化地保存下來。更重要的是，Azure DevOps 的 Wiki 是建立在 Git 儲存庫之上，這代表我們也可以用管理程式碼的方式來管理文件，可以進行版本控制、分支管理等優勢。本文將介紹 Azure DevOps Wiki 的核心概念，包括 Wiki 在儲存庫中的連線位置、.order 檔案的用途，以及如何將資料夾升階為 Wiki 頁面。</p>
<br>
<span id="more"></span>
<br>
<h2 id="Wiki-的兩種類型">Wiki 的兩種類型</h2>
<p>Azure DevOps 提供兩種類型的 Wiki：</p>
<h3 id="1-佈建的-Wiki-Provisioned-Wiki">1. 佈建的 Wiki (Provisioned Wiki)</h3>
<p>當我們為專案建立 Wiki 時，Azure DevOps 會自動建立一個獨立的 Git 儲存庫來存放 Wiki 內容。這個儲存庫的命名慣例是 <strong><mark>專案名稱.wiki</mark></strong>，例如：專案名稱是 <strong><code>Contoso</code></strong>，則 Wiki 儲存庫名稱就是 <strong><code>Contoso.wiki</code></strong>。<strong><mark>這個 Wiki 儲存庫不會出現在專案的 Repos 或 Code 區段的儲存庫下拉選單中，也不會列在專案設定的儲存庫頁面中</mark></strong>。</p>
<h3 id="2-發佈的-Wiki-Published-Wiki">2. 發佈的 Wiki (Published Wiki)</h3>
<p>我們也可以將現有 Git 儲存庫中的 Markdown 檔案發佈為 Wiki。這種方式適合已經在儲存庫中維護技術文件或產品說明的團隊。透過發佈程式碼為 Wiki 可以：</p>
<ul>
<li>將內容組織成受控的頁面順序結構。</li>
<li>瀏覽和篩選目錄。</li>
<li>發佈新版本的內容。</li>
<li>以管理程式碼的方式管理內容。</li>
<li>使用 Wiki 搜尋功能輕鬆地搜尋 Wiki。</li>
</ul>
<p>每個專案可以發佈多個 Wiki，每個發佈的 Wiki 最多可以發佈 <strong><mark>10 個分支</mark></strong>。</p>
<h2 id="Wiki-在-Repo-的連線位置">Wiki 在 Repo 的連線位置</h2>
<h3 id="佈建的-Wiki-儲存庫結構">佈建的 Wiki 儲存庫結構</h3>
<p>Wiki 的 Git 儲存庫有以下特性：</p>
<ul>
<li>儲存庫名稱：<code>專案名稱.wiki</code></li>
<li>主分支名稱：<code>wikiMain</code></li>
</ul>
<p>我們可以透過在 wikiMain 分支上定義分支原則來管理 Wiki 儲存庫，也可以直接修改本機 wikiMain 分支內容，將它們直接推送至遠端分支。</p>
<h3 id="存取-Wiki-儲存庫的方法">存取 Wiki 儲存庫的方法</h3>
<p>由於 Wiki 儲存庫不會顯示在一般的儲存庫清單中，但我們可以透過特定方式來存取：</p>
<ol>
<li>
<p>建立存取 URL：將以下 URL 中的 &lt;Organization&gt;、&lt;ProjectName&gt; 和 &lt;WikiName&gt; 替換為實際值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://dev.azure.com/&lt;Organization&gt;/&lt;ProjectName&gt;/_git/&lt;WikiName&gt;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>從 Wiki 頁面存取：在 Wiki 頁面的「更多選項」(…)，選取「複製」(Clone wiki) 選項，即可取得 Wiki 儲存庫的 URL。</p>
</li>
</ol>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/10/azure-devops-wiki/clone_wiki.jpg"
                        class=""
                 >
<h2 id="order-檔案的用途">.order 檔案的用途</h2>
<p>在 Wiki 中的 .order 檔案扮演著關鍵角色，它定義了 Wiki 頁面在目錄中的顯示順序，當資料夾沒有 .order 檔案時，Git 會使用預設的字母順序（A 到 Z）來排列頁面。</p>
<h2 id="order-檔案的結構">.order 檔案的結構</h2>
<p>.order 檔案是一個純文字檔案，每一行對應一個 Markdown 檔案的名稱（不含 .md 副檔名），例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Wiki-Welcome</span><br><span class="line">Project-Overview</span><br><span class="line">Get-Started</span><br><span class="line">Submit-a-pull-request</span><br><span class="line">team-contacts</span><br><span class="line">readme-version-9</span><br></pre></td></tr></table></figure>
<h3 id="重要注意事項">重要注意事項</h3>
<ol>
<li><strong>大小寫敏感</strong>：頁面標題區有分大小寫，每行所條列的項目應與頁面標題和檔名中使用的大小寫一致。</li>
<li><strong>階層結構</strong>：Wiki 根目錄的 .order 檔案指定根層級頁面的顯示順序，每個子資料夾也可以有自己的 .order 檔案來定義該資料夾的頁面順序。</li>
<li><strong>未列出的檔案</strong>：.order 檔案中未列出的檔案會呈現在頁面順序中的最後。</li>
<li><strong>設定首頁</strong>：<strong><mark>將首頁名稱放在根目錄 .order 檔案的第一行，即可指定 Wiki 的首頁。</mark></strong></li>
</ol>
<h3 id="還原為字母順序">還原為字母順序</h3>
<p>如果想要將自訂順序還原為字母順序，只需刪除 .order 檔案即可，刪除後 Git 會自動建立新的 .order 檔案，使用預設的字母順序。</p>
<h3 id="資料夾注意事項">資料夾注意事項</h3>
<p>當我們透過 Git 將資料夾 push 到 Wiki 時，若資料夾內完全沒有任何檔案但是有其他資料夾，整個資料夾的顯示會是空白的。如下圖，在 Wiki 介面中只會看到 folder1 空目錄，並無法正確呈現 subfolder1 及其內容 file1.md 和 file2.md。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">|- folder1</span><br><span class="line">|-- subfolder1</span><br><span class="line">|   |-- file1.md</span><br><span class="line">|   |-- file2.md</span><br></pre></td></tr></table></figure>
<p>Wiki 呈現的結構</p>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/10/azure-devops-wiki/folder1-nofile.jpg"
                        class=""
                 >
<p>若要讓資料夾結構正常顯示，記得在每個資料夾內至少保持任一個有內容的檔案，如下圖在 folder1 目錄中新增 123.md。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">|- folder1</span><br><span class="line">|- 123.md</span><br><span class="line">|-- subfolder1</span><br><span class="line">|   |-- file1.md</span><br><span class="line">|   |-- file2.md</span><br></pre></td></tr></table></figure>
<p>Wiki 呈現的結構</p>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/10/azure-devops-wiki/folder1-hasfile.jpg"
                        class=""
                 >
<h2 id="如何將目錄升階至頁面">如何將目錄升階至頁面</h2>
<p>在 Azure DevOps Wiki 中，我們可以將儲存庫中的資料夾顯示為 Wiki 中的頁面，這個過程稱為「將資料夾升階至頁面」(Promote folder to page)，要將資料夾升階為頁面，需要滿足以下條件：</p>
<ol>
<li>同名的 Markdown 檔案：Wiki 中必須有一個 Markdown (.md) 檔案，其名稱與資料夾相同。</li>
<li>位於相同位置：Markdown 檔案和資料夾必須是 Wiki 檔案清單中相同位置的對等項目（peers）。</li>
</ol>
<br>
<p>延續上面提到的目錄結構，在下圖這樣的結構中，點選 folder1 並不會顯示任何內容，也沒有選項可以進行編輯。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">|- folder1</span><br><span class="line">|- 123.md</span><br><span class="line">|-- subfolder1</span><br><span class="line">|   |-- file1.md</span><br><span class="line">|   |-- file2.md</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/10/azure-devops-wiki/folder1-noContent.jpg"
                        class=""
                 >
<p><strong><mark>若想要編輯 folder1 資料夾的頁面，必需在同一層路徑中新增一個和目錄名稱相同的 .md (folder1.md)，這個檔案並不會顯示在 Wiki 列表中，而是會直接呈現在 folder1 資料夾的頁面。</mark></strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">|- folder1</span><br><span class="line">|- 123.md</span><br><span class="line">|-- subfolder1</span><br><span class="line">|   |-- file1.md</span><br><span class="line">|   |-- file2.md</span><br><span class="line">|- folder1.md</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/10/azure-devops-wiki/folder1-hasContent.jpg"
                        class=""
                 >
<h2 id="Wiki-版本管理">Wiki 版本管理</h2>
<p>發佈的 Wiki 可以有多個版本，預設會顯示最新版本，我們可以從分支下拉式選單中選取要顯示的版本，由於 Wiki 是儲存在 Git 儲存庫，所有的變更都需要透過 commit 來完成，我們可以：</p>
<ul>
<li>直接在 Azure DevOps Web 介面編輯 Wiki 頁面內容。</li>
<li>使用 Git 在本機編輯後 commit &amp; push。</li>
<li>透過 Pull Request 的方式進行審核後再合併變更。</li>
</ul>
<br>
<p>如果希望對 Wiki 進行更嚴格的控制，也可以在 Wiki 分支上定義分支原則，例如：</p>
<ul>
<li>要求 Pull Request 審核。</li>
<li>要求建置驗證（Build Validation）。</li>
<li>自動連結工作項目。</li>
</ul>
<h2 id="結語">結語</h2>
<p>Azure DevOps 的 Wiki 功能為團隊提供了一個強大且靈活的知識管理平台。透過 Git 儲存庫的支援，Wiki 不僅能夠進行版本控制，還能整合到現有的開發工作流程中。.order 檔案讓我們可以自由地組織頁面結構，而資料夾升階功能則讓文件的層級關係更加清晰。無論選擇建立佈建的 Wiki 還是將現有的 Markdown 檔案發佈為 Wiki，Azure DevOps 都能滿足團隊在不同情境下的需求。善用這些功能，可以大幅提升團隊的知識分享效率和文件品質。</p>
<div class="tips">
<font color="black">
<a class="link"   href="https://learn.microsoft.com/zh-tw/azure/devops/project/wiki/wiki-create-repo?view=azure-devops&tabs=browser"  target="_blank">⁍ 為您的專案建立 Wiki<i class="fas fa-external-link-alt"></i></a><br>
<a class="link"   href="https://learn.microsoft.com/zh-tw/azure/devops/project/wiki/publish-repo-to-wiki?view=azure-devops&tabs=browser"  target="_blank">⁍ 將 Git 存放庫發佈至 Wiki<i class="fas fa-external-link-alt"></i></a><br>
<a class="link"   href="https://learn.microsoft.com/zh-tw/azure/devops/project/wiki/wiki-file-structure?view=azure-devops"  target="_blank">⁍ Git 中的 Wiki 檔案和資料夾結構<i class="fas fa-external-link-alt"></i></a>
</font>
</div>
]]></content>
      <tags>
        <tag>Azure DevOps</tag>
        <tag>Wiki</tag>
      </tags>
  </entry>
  <entry>
    <title>整理 Context 的利器 — MarkItDown 與 Docling</title>
    <url>/post/2025/10/docling-to-markdown/</url>
    <content><![CDATA[<img    
                       lazyload
                       alt="image"
                       data-src="/post/2025/10/docling-to-markdown/logo.png"
                         align="left" style="margin-right: 10px; width: 125px; border: 1px solid gray;"
                 > 
<p>在 Agentic AI 的各式應用場景中，提供正確且良好品質的上下文來源是至關重要的環結，實務上我們可能透過 RAG 從外部檢索資料，或是從手邊的各種檔案格式轉換成 markdown 來提供 LLM 作為上下文參考資料以便展開執行後續的任務，若以輕量、快速上手為考量，可以試試 MarkItDown，但若只能在純地端環境執行，或是對於文件內容(例如：表格、版面)有更高的解析需求不妨試試 Docling，本文以實務角度比較兩者設計取向、支援格式與優缺點，以及提供不同應用場景的建議。</p>
<span id="more"></span>
<p>在建立知識庫、資料前處理或把企業文件提供給 LLM 時，原始文件往往可能是 PDF、各種 Office 文件格式、圖片或音訊，而真正要給 LLM 使用時，需要：</p>
<ul>
<li>保留語意與結構（標題、段落、表格…等）。</li>
<li>去除雜訊並以 token 使用效率高的格式呈現（例如：Markdown）。</li>
<li>在有需要時，保留更結構化的表示（例如：JSON）以便後續自動化處理。</li>
</ul>
<p>MarkItDown 與 Docling 都致力於把各種來源轉成容易被 LLM 或檢索系統消化的輸出，但設計側重與功能集合有明顯差異，下面我們直接比較。</p>
<h2 id="MarkItDown">MarkItDown</h2>
<ul>
<li>出處：由 Microsoft AutoGen 團隊維護（Python）。</li>
<li>設計取向：把各式檔案轉成「結構化 Markdown」；以 LLM 與文本分析為取向。</li>
<li>優勢：
<ul>
<li>直接產生適合 LLM 的 Markdown（標題、列表、表格、內嵌程式碼等）。</li>
<li>支援多媒體（圖片 OCR、音訊轉錄、YouTube 字幕抓取）。</li>
<li>可用作 MCP 伺服器，利於 AI Agent／LLM 整合。</li>
</ul>
</li>
<li>限制：
<ul>
<li>對於複雜的 PDF 版面（精細表格、多欄佈局、複雜閱讀順序），解析深度稍嫌不足。</li>
<li>若要取得更高階 PDF 能力，可能會依賴 Azure Document Intelligence（雲端）。</li>
</ul>
</li>
</ul>
<p>若要使用 MarkItDown MCP 現在可以在 GitHub MCP Registry(https://github.com/mcp) 列表找到，也可以 docker 方式或 clone 整個專案在本地端以 STDIO 的方式執行，參考微軟官方 GitHub 說明。</p>
<div class="tips">
<font color="black">
<a class="link"   href="https://github.com/mcp"  target="_blank">⁍ GitHub MCP Registry<i class="fas fa-external-link-alt"></i></a><br>
<a class="link"   href="https://github.com/microsoft/markitdown?tab=readme-ov-file"  target="_blank">⁍ GitHub | MarkItDown<i class="fas fa-external-link-alt"></i></a><br>
<a class="link"   href="https://github.com/microsoft/markitdown/tree/main/packages/markitdown-mcp"  target="_blank">⁍ GitHub | MarkItDown MCP<i class="fas fa-external-link-alt"></i></a><br>
</font>
</div>
<h2 id="Docling">Docling</h2>
<ul>
<li>出處：由 Docling Project（原起始於 IBM Research Zurich，目前管於 LF AI &amp; Data）維護。</li>
<li>設計取向：專注於文件理解，特別是進階 PDF 解析（版面、閱讀順序、表格結構、公式、程式碼、影像分類），並提供統一的 DoclingDocument 表示與多種匯出選項。</li>
<li>優勢：
<ul>
<li>在複雜 PDF（掃描文件、排版、多欄表格）與表格重構上表現優異，使用自家模型（DocLayNet、TableFormer）提升解析品質。</li>
<li>支援本地執行（適合敏感資料或隔離環境），也有 VLM / ASR 整合能力。</li>
<li>輸出豐富：Markdown / HTML / JSON / DocTags 等，便於後續分析或顯示詳細資訊。</li>
<li>與 LangChain、LlamaIndex、Haystack 等生態系可以直接整合，便於搭建 RAG pipeline。</li>
</ul>
</li>
<li>限制：
<ul>
<li>因為功能較廣、選項較多，學習曲線會比 MarkItDown 高。</li>
<li>Docling 會完全在本地環境執行，需要考量相關系統資源 (是優點也是缺點)。</li>
</ul>
</li>
</ul>
<p>如何取得並建置 Docling 環境可以參考 GitHub 專案，它一樣有支援 MCP 但要在它的官網才找得到說明，如同前面說的，它是完全在本地端執行，所以 MCP 是由 uvx 來執行啟動。</p>
<div class="tips">
<font color="black">
<a class="link"   href="https://github.com/docling-project/docling"  target="_blank">⁍ GitHub | Docling <i class="fas fa-external-link-alt"></i></a><br>
<a class="link"   href="https://docling-project.github.io/docling/"  target="_blank">⁍ Docling<i class="fas fa-external-link-alt"></i></a><br>
<a class="link"   href="https://docling-project.github.io/docling/usage/mcp/"  target="_blank">⁍ Docling MCP<i class="fas fa-external-link-alt"></i></a><br>
</font>
</div>
<p>如果想要手動在 mcp.json 加入這兩個 MCP 工具，可以直接參考：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;servers&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;microsoft/markitdown&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;stdio&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;uvx&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">				<span class="string">&quot;markitdown-mcp==0.0.1a4&quot;</span></span><br><span class="line">			<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;gallery&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://api.mcp.github.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span></span><br><span class="line">		<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">		 <span class="attr">&quot;docling&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		 <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;uvx&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">				<span class="string">&quot;--from=docling-mcp&quot;</span><span class="punctuation">,</span></span><br><span class="line">				<span class="string">&quot;docling-mcp-server&quot;</span></span><br><span class="line">			<span class="punctuation">]</span></span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;inputs&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="支援格式與各面向比較">支援格式與各面向比較</h2>
<table>
<thead>
<tr>
<th>格式</th>
<th>MarkItDown</th>
<th>Docling</th>
<th>備註</th>
</tr>
</thead>
<tbody>
<tr>
<td>PDF</td>
<td>良好</td>
<td>優秀（尤其是複雜/掃描文件）</td>
<td>MarkItDown 對一般 PDF 處理良好；若需高保真解析或掃描 OCR 建議用 Docling</td>
</tr>
<tr>
<td>DOCX / PPTX / XLSX</td>
<td>支援</td>
<td>支援</td>
<td>兩者皆可處理 Office 文件</td>
</tr>
<tr>
<td>Images</td>
<td>OCR、EXIF 支援</td>
<td>OCR + VLM（視覺語言模型）分類支援</td>
<td>Docling 在影像分類與 VLM 整合上較強</td>
</tr>
<tr>
<td>Audio (WAV / MP3)</td>
<td>支援音訊轉錄</td>
<td>ASR 支援</td>
<td>兩者皆支援轉錄；可串接不同模型以改善品質</td>
</tr>
<tr>
<td>HTML</td>
<td>支援</td>
<td>支援</td>
<td>皆可匯入網頁內容</td>
</tr>
<tr>
<td>Markdown</td>
<td>原生支援</td>
<td>支援匯入/匯出</td>
<td></td>
</tr>
<tr>
<td>CSV / JSON / XML</td>
<td>文字格式支援</td>
<td>支援</td>
<td>適合結構化文字資料</td>
</tr>
<tr>
<td>YouTube</td>
<td>可抓取與轉錄</td>
<td>可處理 WebVTT / 影片字幕</td>
<td>MarkItDown 偏向抓取與轉錄；Docling 處理字幕檔更完整</td>
</tr>
<tr>
<td>EPUB / ZIP</td>
<td>支援</td>
<td>支援</td>
<td>支援程度依內容與封裝方式而異</td>
</tr>
<tr>
<td>VTT / WebVTT</td>
<td>支援</td>
<td>支援</td>
<td>若以字幕為主，Docling 支援度較好</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>設計目標：</p>
<ul>
<li>MarkItDown：以「快速把各類來源轉成 LLM-friendly Markdown」為核心，偏重 token 效率與多媒體前處理。</li>
<li>Docling：以「高保真文件理解」為核心，強調版面/表格/閱讀順序的精確還原與 lossless 結構化。</li>
</ul>
</li>
<li>
<p>解析深度與還原度：</p>
<ul>
<li>MarkItDown：輸出以可讀且可索引的 Markdown 為主，對一般文件足夠；遇到跨欄或複雜表格時可能會犧牲部分細節。</li>
<li>Docling：使用版面模型與表格重建，保留更多區塊座標與結構資訊，適合需精準抽取或重現原始排版的情境。</li>
</ul>
</li>
<li>
<p>多媒體支援：</p>
<ul>
<li>MarkItDown：支援音訊轉錄、YouTube 字幕抓取、圖片 OCR 等，偏向 LLM 前處理工作流。</li>
<li>Docling：也支援 OCR/ASR/VLM，但更強調影像分類、表格語意重構與公式/程式碼片段的解析。</li>
</ul>
</li>
<li>
<p>本地化 vs 雲端依賴：</p>
<ul>
<li>MarkItDown：可本地執行，但在某些高階 PDF 能力上會建議採用雲端 Azure Document Intelligence 作為選項。</li>
<li>Docling：設計上強調本地端運行，適合敏感資料或離線環境。</li>
</ul>
</li>
<li>
<p>效能與資源需求：</p>
<ul>
<li>MarkItDown：輕量、上手快，適合大量快速預處理。</li>
<li>Docling：依賴模型與較高運算資源，單檔處理時間較長但輸出更精確。</li>
</ul>
</li>
<li>
<p>整合生態與可擴充性：</p>
<ul>
<li>MarkItDown：以 plugin 與 MCP 為導向，容易接入 AI Agent / LLM pipeline。</li>
<li>Docling：提供豐富的 JSON / Markdown / HTML 匯出，與 LangChain、LlamaIndex 等檢索生態整合良好，利於深度資料工程。</li>
</ul>
</li>
<li>
<p>可驗證性與審核：</p>
<ul>
<li>MarkItDown：輸出簡潔，人工檢視方便，但在表格或版面細節需抽樣驗證。</li>
<li>Docling：提供中間結構（座標、區塊、表格邊界），便於自動化驗證與回溯修正。</li>
</ul>
</li>
<li>
<p>學習曲線與運維成本：</p>
<ul>
<li>MarkItDown：學習低、文件少、運維簡單。</li>
<li>Docling：功能與選項多，需時間調校模型與處理參數，運維成本較高。</li>
</ul>
</li>
</ul>
<h2 id="總結">總結</h2>
<p>MarkItDown 與 Docling 均可將各類原始文件轉為 LLM 友好的結構化格式，但設計取向與適用場景不同：MarkItDown 輕量且易上手，輸出以節省 token 的 Markdown 為主，適合大量快速預處理與整合至 AI Agent / LLM pipeline；Docling 則強調高保真文件理解與版面還原，擅長複雜 PDF、表格重建及本地化運行，適用於需精準解析或資安敏感的情境。實務上如果是遇到比較複雜的文件內容，例如像論文有分左右兩欄、各式表格，或是有圖片需要 OCR 辨識、流程圖想要轉換成 Mermaid，使用 Docling 產出的結果都蠻不錯的，強力推薦給大家!</p>
  <!-- 實務上建議依文件類型、解析精度、處理量與可用資源做選擇，並透過抽樣驗證或混合流程（以 MarkItDown 做批次預處理、以 Docling 處理關鍵或需人工驗證的檔案）來兼顧效率與精確性。 -->
<p>.xls -&gt; .md</p>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/10/docling-to-markdown/docling-excel.jpg"
                        class=""
                 >
<p>.pptx -&gt; .md</p>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/10/docling-to-markdown/docling-pptx.jpg"
                        class=""
                 >
<p>使用本地端資源運行 Docling</p>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/10/docling-to-markdown/docling-performance.jpg"
                        class=""
                 >
]]></content>
      <tags>
        <tag>Docling</tag>
        <tag>MarkItDown</tag>
        <tag>文件處理</tag>
        <tag>RAG</tag>
      </tags>
  </entry>
  <entry>
    <title>Devdays Asia 2025 簡報下載</title>
    <url>/post/2025/10/devdays-asia-2025/</url>
    <content><![CDATA[<img    
                       lazyload
                       alt="image"
                       data-src="/post/2025/10/devdays-asia-2025/DevdaysAsia2025.jpg"
                         align="left" style="margin-right: 10px; width: 125px; border: 1px solid gray;"
                 > 
<p>今年是微軟 50 週年、DevDays 10 週年，話題大多圍繞在 Agentic AI，考量多數企業還是有 On-Premises 需求，所以這次我將主題訂在如何使用 Azure DevOps + GitHub Copilot 重新打造 SDLC，讓大家瞭解不是雲原生環境還可以有哪些應用，以及賦與 LLM 更多 Tools 後，可以讓我們的軟體開發過程產生多大的助益和改變，雖然主題是 Azure DevOps 與 GitHub Copilot，但基本上套在任何軟體開發流程概念都是一樣的，提供給大家參考，有任何想討論交流也歡迎大家留言或直接與我聯繫。</p>
<span id="more"></span>
<br>
<div class="tips">
<font color="black">
<a href="/post/2025/10/devdays-asia-2025/0925_Track A 1330-1400_DevDaysAsia_20250925_精誠軟體.pdf" target="_blank">⁍ Azure DevOps 與 GitHub Copilot：AI 驅動的團隊協作新時代</a><br>
<a class="link"   href="https://www.digitimes.com.tw/Seminar/DevDaysAsia2025/index.html"  target="_blank">⁍ DevDays Asia 2025 亞太技術年會 | 議程介紹<i class="fas fa-external-link-alt"></i></a><br>
<a class="link"   href="https://onedrive.live.com/?redeem=aHR0cHM6Ly8xZHJ2Lm1zL2YvYy85NmJjZGNhMWVkYWIwZmMyL0VvUncyR1ZIaVRaUG1NNW1Ib0hPeWxFQlpvSW5aOU55ckY1QVJsOU5wbGpYWXc_ZT01VlhkMXQ&id=96BCDCA1EDAB0FC2%21s65d8708489474f3698ce661e81ceca51&cid=96BCDCA1EDAB0FC2"  target="_blank">⁍ DevDays Asia 2025 亞太技術年會 | 所有簡報下載 (OneDrive)<i class="fas fa-external-link-alt"></i></a><br>
</font>
</div>]]></content>
      <tags>
        <tag>Azure DevOps</tag>
        <tag>Devdays Asia 2025</tag>
        <tag>GitHub Copilot</tag>
      </tags>
  </entry>
  <entry>
    <title>.NET Conf 2025 - 碼農出擊 ! GitHub Copilot 帶你飛</title>
    <url>/post/2025/12/dotnet-conf-2025/</url>
    <content><![CDATA[<img    
                       lazyload
                       alt="image"
                       data-src="/post/2025/12/dotnet-conf-2025/dotNet-conf-2025.jpg"
                         align="left" style="margin-right: 10px; width: 125px; border: 1px solid gray;"
                 > 
<p>很開心受邀在 <strong>.NET Conf 2025 Taiwan</strong> 擔任講者，這場活動由 STUDY4 社群主辦，是全球 .NET Conf 的台灣在地場，今年主軸放在 <strong>.NET 10</strong> 與 <strong>AI 驅動的應用開發</strong>。我的議程主要聚焦在：當企業想要導入 GitHub Copilot，不只是單純「幫工程師補程式碼」，而是思考如何有計畫地將 GitHub Copilot 融入 SDLC 既有流程之中。<br></p>
<span id="more"></span>
<br>
<br>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/12/dotnet-conf-2025/presentation.jpg"
                        class=""
                 >
<br>
<h2 id="從-DevDays-Asia-2025-延伸而來">從 DevDays Asia 2025 延伸而來</h2>
<p>9月我在 <strong>DevDays Asia 2025</strong> 分享的是「Azure DevOps 與 GitHub Copilot：AI 驅動的團隊協作新時代」，比較像是從高空俯瞰：</p>
<ul>
<li>怎麼用 Azure DevOps + GitHub Copilot 重新包裝 SDLC</li>
<li>就算還在 On-Premises 或混合環境，也一樣可以享受 AI 輔助開發</li>
<li>讓 LLM 透過 Tools / MCP 介接既有系統，把「會聊天」變成「會做事」</li>
</ul>
<p>這次在 .NET Conf 2025，則是把鏡頭拉近到 <strong>「GitHub Copilot 本身該怎麼在企業裡落地」</strong>，特別是：</p>
<ol>
<li>從哪幾個層次開始導入比較務實？</li>
<li>怎麼跟 SDLC 的每一個階段對得上？</li>
<li>除了 IDE 內的 Chat / Completions 之外，團隊層級還能玩到多深？</li>
</ol>
<br>
<h2 id="四層次的-GitHub-Copilot-客製化思維">四層次的 GitHub Copilot 客製化思維</h2>
<p>簡報裡我用了一個「<strong>AI 客製化四層次架構</strong>」來整理 Copilot 在企業導入時可以怎麼分階段思考：</p>
<br>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/12/dotnet-conf-2025/levels.jpg"
                        class=""
                 >
<br>
<ol>
<li>
<p><strong>模型與提示詞（Models &amp; Prompting）</strong><br>
先搞清楚目前 Copilot 內建提供哪些模型、哪些是 0x 乘數（不額外計費）、哪些是進階付費模型，依照團隊的情境選擇適合的組合，再搭配基本的 Prompt 寫法，讓開發者在 Chat / Inline Chat 裡可以比較穩定地拿到想要的答案。</p>
</li>
<li>
<p><strong>自訂指令與提示詞（Custom Instructions &amp; Prompts）</strong><br>
把「每次都會重複說的那些話」抽出來，例如：命名規則、例外處理策略、錯誤訊息語氣、專案的架構慣例等，寫進：</p>
<ul>
<li><strong><code>/.github/copilot-instructions.md</code></strong>（工作區全域規則）</li>
<li><strong><code>/.github/instructions/*.instructions.md</code></strong>（依語言 / 任務做條件式套用）<br>
讓 Copilot 自動帶著這些背景知識工作，而不是每次對話都從零開始重新交代。</li>
<li><strong><code>/.github/prompts/*.prompt.md</code></strong> (會重複使用的 prompt)</li>
</ul>
</li>
<li>
<p><strong>自訂代理人（Custom Agents）</strong><br>
把「角色」概念正式化，為不同開發階段建立專屬 Agent，例如：</p>
<ul>
<li>專門負責需求拆解與規劃的 PLANNER</li>
<li>專心寫程式碼與重構的 IMPLEMENTER</li>
<li>聚焦測試與驗證的 TESTER</li>
<li>做 Code Review 與安全檢查的 REVIEWER<br>
然後用 <strong><code>/agents/*.agent.md</code></strong> 定義好他們各自的行為模式與可用工具，讓團隊在 Copilot Chat 或 Copilot CLI 裡可以一鍵切換角色工作。</li>
</ul>
</li>
<li>
<p><strong>整合應用（Integration）</strong><br>
最後一層就是把 Copilot 拉進既有的工具鏈：</p>
<ul>
<li>在 CI/CD Pipeline 裡呼叫 Copilot CLI 做自動化 Code Review 或文件生成</li>
<li>搭配 Pull Request Flow，讓 Copilot 先幫忙整理變更摘要、找出可疑區塊</li>
<li>用 Prompt Files 把常用工作（例如：「幫我重寫這份 README」）標準化，讓團隊成員都能重複使用同一套流程</li>
</ul>
</li>
</ol>
<p>這四個層次並不是一次到位，而是可以循序漸進、視團隊成熟度慢慢往上疊。</p>
<br>
<h2 id="GitHub-Copilot-與-SDLC-的結合">GitHub Copilot 與 SDLC 的結合</h2>
<p>在 SDLC 的觀點，我會把 Copilot 放進這樣一個簡化版流程裡看（更多的應用可以參考前幾天提到的 <a class="link"   href="https://sdlc.timlai.dev" >https://sdlc.timlai.dev<i class="fas fa-external-link-alt"></i></a>）：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Plan (規劃)</span><br><span class="line">  ↓</span><br><span class="line">  └─ Copilot Chat：輔助需求釐清、工作拆解、規格草稿</span><br><span class="line"></span><br><span class="line">Code (程式編寫)</span><br><span class="line">  ↓</span><br><span class="line">  ├─ Code Completions：自動補全樣板程式碼與重複片段</span><br><span class="line">  └─ Copilot Chat：在 IDE 裡協助除錯、重構、產生單元測試</span><br><span class="line"></span><br><span class="line">Review (程式碼審查)</span><br><span class="line">  ↓</span><br><span class="line">  └─ Copilot CLI / Agents：自動化 Code Review、風險掃描與文件補強</span><br><span class="line"></span><br><span class="line">Deploy (部署)</span><br><span class="line">  ↓</span><br><span class="line">  └─ Coding Agent / Pipeline 整合：協助修改設定、產生部署腳本、建立 PR</span><br></pre></td></tr></table></figure>
<p>對企業來說，重點不是「多一個會寫程式的 AI」，而是：</p>
<ul>
<li>在每一個階段都有明確、可度量的應用場景</li>
<li>知道哪些事情適合交給 Copilot，哪些仍然要由人類工程師把關</li>
<li>把規則寫進 Custom Instructions、流程寫進 Prompt Files 或 Agents，讓團隊可以<strong>穩定地複製成功經驗</strong></li>
</ul>
<br>
<h2 id="從個人到團隊的導入建議">從個人到團隊的導入建議</h2>
<p>簡報裡我也分享了一個比較務實的導入路線，給正在觀望是否要導入 Copilot 的團隊參考：</p>
<ol>
<li>
<p><strong>先從開發者個人開始體驗</strong><br>
讓團隊成員先在 VS Code / Visual Studio 裡熟悉 Chat、Completions、Inline Chat 等基本能力，累積最直覺的「效率感」。</p>
</li>
<li>
<p><strong>很快地補上團隊層級的規範</strong><br>
不要讓每個人用 Copilot 的方式完全長得不一樣，建議盡早建立：</p>
<ul>
<li>共同的 <strong><code>copilot-instructions.md</code></strong></li>
<li>基本的安全與隱私原則（哪些程式碼 / 資料不能貼上雲端）</li>
<li>簡單的「好 Prompt 範例庫」</li>
</ul>
</li>
<li>
<p><strong>針對關鍵流程做深度整合</strong><br>
找出團隊最痛的幾個流程（例如：Code Review 太花時間、文件總是寫不完、重複的樣板專案很難維護），優先用 Copilot CLI、Custom Agents 或 CI/CD 整合來做自動化，讓大家看到「不只是省幾行程式碼」的價值。</p>
</li>
<li>
<p><strong>持續迭代與量化成果</strong><br>
導入一段時間後，回頭檢視：</p>
<ul>
<li>PR 週期、缺陷率、上線前修正量是否有改善？</li>
<li>開發者的主觀感受是「變快」還是「變亂」？</li>
<li>有沒有新的反模式需要在指令或流程上修正？</li>
</ul>
</li>
</ol>
<p>這次的簡報放在下方參考連結，也非常歡迎有參加活動、或正在思考 <strong>GitHub Copilot 如何在自己團隊落地</strong> 的朋友留言交流，一起把 AI 真正變成開發流程的一部分，而不是只停留在「玩玩看」的階段。</p>
<div class="tips">
<font color="black">
<a href="/post/2025/12/dotnet-conf-2025/碼農出擊 ! GitHub Copilot 帶你飛_20251129.pdf" target="_blank">⁍ 簡報下載 - 碼農出擊 ! GitHub Copilot 帶你飛</a><br>
<a class="link"   href="https://dotnetconf.study4.tw"  target="_blank">⁍ .NET Conf 2025 Taiwan 官方網站<i class="fas fa-external-link-alt"></i></a>
</font>
</div>]]></content>
      <tags>
        <tag>GitHub Copilot</tag>
        <tag>.NET Conf 2025</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Playwright 測試框架 - 環境準備 (.NET)</title>
    <url>/post/2025/05/how-to-use-playwright-1/</url>
    <content><![CDATA[<img    
                       lazyload
                       alt="image"
                       data-src="/post/2025/05/how-to-use-playwright-1/playwright.png"
                         align="left" style="margin-right: 10px; width: 125px; border: 1px solid gray;"
                 > 
<p>在現代軟體開發中，自動化測試已成為確保程式碼品質的重要一環，Playwright 是一個強大的自動化測試框架，支援 Chromium / Firefox / WebKit 瀏覽器，搭配測試產生器(codegen)讓開發者能夠輕鬆撰寫可靠且高效的測試腳本。本篇文章將介紹如何在 .NET 開發環境中設置和使用 Playwright，從安裝必要的套件到撰寫基本的測試案例，幫助大家快速上手這個工具。<br>
<br></p>
<span id="more"></span>
<br>
<h2 id="使用-Visual-Studio">使用 Visual Studio</h2>
<p>如果是慣用地表最強開發工具，打開 Visual Studio 建立一個新的 <strong><code>MSTest 測試專案</code></strong>，讓我們有一個基本測試環境可以開始撰寫 Playwright 測試。</p>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/05/how-to-use-playwright-1/vs-01.png"
                        class=""
                 >
<br>
<p>要在 MSTest 使用 Playwright 必需要安裝 <strong><code>Microsoft.Playwright.MSTest</code></strong> 套件，這個套件會將 Playwright 與 MSTest 整合，使我們能夠在 MSTest 測試過程中使用 Playwright 功能。</p>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/05/how-to-use-playwright-1/vs-02.png"
                        class=""
                 >
<h2 id="使用-NET-CLI">使用 .NET CLI</h2>
<p>若是使用 VSCode 開發工具，我們可以用 <strong>dotnet new</strong> 指令新增一個 PlaywrightTests 專案，預設內容會包含一個 UnitTest1.cs 檔案。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dotnet new mstest -n PlaywrightTests</span><br><span class="line">cd PlaywrightTests</span><br></pre></td></tr></table></figure>
<p>安裝必要的 Playwright 相依套件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dotnet add package Microsoft.Playwright.MSTest</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/05/how-to-use-playwright-1/cli-01.png"
                        class=""
                 >
<br>
<p>建置程式碼，確認環境準備是否有異常。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dotnet build</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/05/how-to-use-playwright-1/cli-02.png"
                        class=""
                 >
<br>
<h2 id="安裝-Playwright-CLI">安裝 Playwright CLI</h2>
<p>在 .NET 開發環境中，雖然 <strong>playwright.exe</strong> 指令沒有像 <strong>npx playwright</strong> 那麼多參數與功能，但我們在錄製網頁操作過程來產生測試程式碼 (codegen)，或是開啟追蹤檔 (show-trace) 時仍會使用到，可以透過下列指令來安裝 <strong><code>Microsoft.Playwright.CLI</code></strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dotnet tool install --global Microsoft.Playwright.CLI</span><br></pre></td></tr></table></figure>
<p>上述套件預設會被安裝到目前的使用者範圍內的 .NET 全局工具路徑中，具體安裝位置會因作業系統而異：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Windows</span><br><span class="line">C:\Users\&lt;你的用戶名&gt;\.dotnet\tools\</span><br><span class="line"></span><br><span class="line">Linux / macOS</span><br><span class="line">/home/&lt;你的用戶名&gt;/.dotnet/tools/</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/05/how-to-use-playwright-1/cli-03.png"
                        class=""
                 >
<p>我們可以直接開啟目錄確認工具是否安裝成功，或是使用以下指令來列出所有安裝的 .NET 工具：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dotnet tool list --global</span><br></pre></td></tr></table></figure>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Package Id                    Version      Commands</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">dotnet-ef                     8.0.8        dotnet-ef</span><br><span class="line">microsoft.playwright.cli      1.2.3        playwright</span><br></pre></td></tr></table></figure>
<h2 id="移除-Playwright-CLI">移除 Playwright CLI</h2>
<p>若需要移除已安裝的套件，可以使用下列指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dotnet tool uninstall microsoft.playwright.cli</span><br></pre></td></tr></table></figure>
<h2 id="安裝-Playwright-支援的瀏覽器">安裝 Playwright 支援的瀏覽器</h2>
<p>Playwright 支援 Chromium、WebKit 和 Firefox 瀏覽器，我們可以使用 <strong>playwright install</strong> 指令來安裝預設瀏覽器，這個動作會將瀏覽器安裝到 <strong><mark>%LOCALAPPDATA%\ms-playwright</mark></strong> 目錄下，若想要自訂安裝的項目，可以透過 <strong>playwright help install</strong> 來瞭解所有的選項。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">playwright install</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/05/how-to-use-playwright-1/cli-04.png"
                        class=""
                 >
<br>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">playwright help install</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/05/how-to-use-playwright-1/cli-05.png"
                        class=""
                 >
<h2 id="小試身手">小試身手</h2>
<p>以上 Playwright 環境設定都完成後，我們就可以直接用官網的第一個範例來小試身手：</p>
<ul>
<li>
<p><code>HasTitle()</code><br>
打開 Playwright 官方網站，檢查網站的標題是否包含特定的字串，確認網頁標題中是否包含 “Playwright” 這個字。</p>
</li>
<li>
<p><code>GetStartedLink()</code><br>
一樣是打開 Playwright 官方網站，點擊一個名為 “Get started” 的連結，然後檢查點擊後的頁面是否有一個名為 “Installation” 的標題，以確保連結正確導向到預期的頁面。</p>
</li>
</ul>
<p>大家應該不難發現 Playwright 的程式碼很直覺易讀，通常也不太需要夾雜 CSS class 或 style 來尋找定位網頁上的元素，除此之外還提供了豐富的 API 來進行各種操作，如：點擊、輸入文字、截圖等，之後再陸續向大家介紹各項重點特色，希望大家也都能快速上手 Playwright，並在日常開發中提升測試效率與程式碼品質。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Text.RegularExpressions;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Playwright;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Playwright.MSTest;</span><br><span class="line"><span class="keyword">using</span> Microsoft.VisualStudio.TestTools.UnitTesting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">PlaywrightTests</span>;</span><br><span class="line"></span><br><span class="line">[<span class="meta">TestClass</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ExampleTest</span> : <span class="title">PageTest</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">TestMethod</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">HasTitle</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> Page.GotoAsync(<span class="string">&quot;https://playwright.dev&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Expect a title &quot;to contain&quot; a substring.</span></span><br><span class="line">        <span class="keyword">await</span> Expect(Page).ToHaveTitleAsync(<span class="keyword">new</span> Regex(<span class="string">&quot;Playwright&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">TestMethod</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">GetStartedLink</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> Page.GotoAsync(<span class="string">&quot;https://playwright.dev&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Click the get started link.</span></span><br><span class="line">        <span class="keyword">await</span> Page.GetByRole(AriaRole.Link, <span class="keyword">new</span>() &#123; Name = <span class="string">&quot;Get started&quot;</span> &#125;).ClickAsync();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Expects page to have a heading with the name of Installation.</span></span><br><span class="line">        <span class="keyword">await</span> Expect(Page.GetByRole(AriaRole.Heading, <span class="keyword">new</span>() &#123; Name = <span class="string">&quot;Installation&quot;</span> &#125;)).ToBeVisibleAsync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Unit Test</tag>
        <tag>Playwright</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Playwright 測試框架 - 執行階段 (.NET)</title>
    <url>/post/2025/05/how-to-use-playwright-2/</url>
    <content><![CDATA[<img    
                       lazyload
                       alt="image"
                       data-src="/post/2025/05/how-to-use-playwright-1/playwright.png"
                         align="left" style="margin-right: 10px; width: 125px; border: 1px solid gray;"
                 > 
<p><a href="/post/2024/11/how-to-use-playwright-1">上一篇文章</a>提到了如何使用 Playwright 的測試產生器(codegen) 錄製腳本，除了可以運用在自動化測試之外，舉凡想要透過程式來自動執行的一連串行為，都可以透過 Playwright 來完成，本篇文章使用 Windows Sandbox 全新環境來執行由 .NET 8 撰寫的 Console 程式，讓大家知道建置產生執行檔後，還需要哪些必要的環境設定才可以正常讓程式運作。<br>
<br></p>
<span id="more"></span>
<br>
<h2 id="安裝-NET-Runtime">安裝 .NET Runtime</h2>
<p>不論是以前的 .NET Framework 或是現在的 .NET Core，在執行時都需要安裝 .NET Runtime 才能順利運行開發好的程式，以下圖 Console 專案建置後的執行檔為例，畫面還會很貼心的指引我們目前的需求版本和下載路徑，完成安裝後便可順利執行 Console 程式。</p>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/05/how-to-use-playwright-2/dotnet8.png"
                        class=""
                 >
<br>
<div class="tips">
<font color="black">
<a class="link"   href="https://dotnet.microsoft.com/download"  target="_blank">⁍ 下載 .NET<i class="fas fa-external-link-alt"></i></a>
</font>
</div>
<h2 id="安裝-PowerShell">安裝 PowerShell</h2>
<p>如果是全新的環境，安裝完 .NET Runtime 後應該還會出現如下圖的錯誤，主要原因是：</p>
<ul>
<li>pwsh 找不到路徑 (或是沒有安裝 PowerShell)</li>
<li>缺少 WebDriver (Edge/Chrome/Firefox)</li>
</ul>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/05/how-to-use-playwright-2/pwsh.png"
                        class=""
                 >
<br>
若要安裝 PowerShell 可以依據自己的作業系統參考下列連結：
<div class="tips">
<font color="black">
<a class="link"   href="https://learn.microsoft.com/zh-tw/powershell/scripting/install/installing-powershell-on-windows?view=powershell-7.5"  target="_blank">⁍ 在 Windows 上安裝 PowerShell<i class="fas fa-external-link-alt"></i></a><br>
<a class="link"   href="https://learn.microsoft.com/zh-tw/powershell/scripting/install/installing-powershell-on-linux?view=powershell-7.5"  target="_blank">⁍ 在 Linux 上安裝 PowerShell<i class="fas fa-external-link-alt"></i></a><br>
<a class="link"   href="https://learn.microsoft.com/zh-tw/powershell/scripting/install/installing-powershell-on-macos?view=powershell-7.5"  target="_blank">⁍ 在 macOS 上安裝 PowerShell<i class="fas fa-external-link-alt"></i></a>
</font>
</div>
<h2 id="安裝-WebDriver">安裝 WebDriver</h2>
<p>在上圖的錯誤訊息中有提到如下指令，路徑中的 <strong><mark>netX</mark></strong> 要替換為自己使用的版本路徑，而其中的 playwright.ps1 會存在於 .NET 程式建置後的 bin 目錄中，這個 .ps1 的主要用途是在 Windows 環境下執行 Playwright 測試，讓它可以正確找到 Playwright 主程式和相關驅動程式，確認 pwsh 指令可以運作後，就可以接著安裝 WebDriver 了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwsh bin/Debug/netX/playwright.ps1 install</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/05/how-to-use-playwright-2/playwright.png"
                        class=""
                 >
<br>
若在 install 之後沒有加上任何參數，則會安裝下列預設項目：
<ul>
<li>Chromium</li>
<li>Chromium Headless Shell</li>
<li>Firefox</li>
<li>Webkit</li>
<li>FFMPEG</li>
</ul>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/05/how-to-use-playwright-2/install.png"
                        class=""
                 >
<br>
也可以依自己的需求安裝指定項目，可使用 install -h 查看相關資訊：
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/05/how-to-use-playwright-2/custom.png"
                        class=""
                 >
<h2 id="總結">總結</h2>
<p>本文介紹了在全新環境下，如何讓 .NET 8 撰寫的 Playwright 測試程式順利執行，包含安裝 .NET Runtime、PowerShell 及 WebDriver 等必要步驟。只要依照上述流程完成環境設定，就能避免常見的錯誤訊息，順利執行自動化測試。希望這些說明能幫助你在不同平台上快速部署與運行 Playwright 測試專案。</p>
]]></content>
      <tags>
        <tag>Playwright</tag>
      </tags>
  </entry>
  <entry>
    <title>關於 MCP 的 Capability Negotiation</title>
    <url>/post/2025/07/mcp-capability-negotiation/</url>
    <content><![CDATA[<img    
                       lazyload
                       alt="image"
                       data-src="/post/2025/07/mcp-capability-negotiation/robot.jpg"
                         align="left" style="margin-right: 10px; width: 125px; border: 1px solid gray;"
                 > 
<p>在當前 AI 技術快速發展的時代，MCP (Model Context Protocol) 為大型語言模型帶來更多元且強大的擴展能力。透過 MCP 讓開發者能使 IDE 工具與語言模型自然結合，實現語意驅動的互動體驗。MCP 架構中包含 MCP Server、MCP Host 與 MCP Client 三大核心角色，彼此協同合作並透過能力協商（Capability Negotiation）機制，確保雙方能根據自身能力與需求，協調出最佳的功能組合與協作方式。本文將以<a href="/post/2025/06/azure-devops-mcp-server/">上一篇文章</a>為例，說明其背景運作流程。</p>
<span id="more"></span>
<br>
<h2 id="Core-Components-核心組件">Core Components 核心組件</h2>
<p>MCP 採用 client-host-server 的架構設計，其中一個 host 可以同時管理多個 client instance，並與 MCP Server 建立一對一的連線，藉此維持安全邊界並隔離各自的關注點。以 VSCode 安裝 GitHub Copilot Extension 並連接 Azure DevOps MCP Server 為例，VSCode 扮演 host 角色，而 GitHub Copilot 則是 client，而 Azure DevOps MCP Server 則是 server。每個 client 透過 host 啟動並與 server 進行能力協商，確保各自的功能與需求能被正確識別與協調，進而實現安全且高效的協作。</p>
<p>正如 MCP 官方文件所示意的架構圖，我們可以在 VSCode 中透過 GitHub Copilot 與不同的模型進行互動。只要註冊並設定不同的 MCP Server，就能根據需求取得各式各樣的工具，進一步擴展大型語言模型的應用範圍與處理能力。目前要開發 MCP Server 的門檻已經大幅降低，在 Python / Node.js / Java / Kotlin / C# 都有很豐富的實作範例可以參考，可以參考下列整理連結。</p>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/07/mcp-capability-negotiation/core_components.png"
                        class=""
                 >
<br>
<div class="tips">
<font color="black">
<a class="link"   href="https://modelcontextprotocol.io/quickstart/server"  target="_blank">⁍ Quickstart - For MCP Server Developers<i class="fas fa-external-link-alt"></i></a><br>
<a class="link"   href="https://github.com/modelcontextprotocol/csharp-sdk"  target="_blank">⁍ GitHub | csharp-sdk<i class="fas fa-external-link-alt"></i></a><br>
<a class="link"   href="https://learn.microsoft.com/zh-tw/dotnet/ai/get-started-mcp"  target="_blank">⁍ 開始使用 .NET AI 和模型內容通訊協定<i class="fas fa-external-link-alt"></i></a><br>
<a class="link"   href="https://learn.microsoft.com/zh-tw/dotnet/ai/quickstarts/build-mcp-server"  target="_blank">⁍ 使用 .NET 建立並連線到最小的 MCP 伺服器<i class="fas fa-external-link-alt"></i></a><br>
</font>
</div>
<h2 id="Capability-Negotiation-能力協商">Capability Negotiation 能力協商</h2>
<p>在 MCP 官方說明文件裡有一張關於 Capability Negotiation 的循序圖畫得很詳細，大家想要瞭解可以參考下方連結，這邊我就以上次的情境舉例：描述使用者透過 VSCode 及 GitHub Copilot 選擇使用 gpt-4o 模型，透過 Azure DevOps MCP Server 與 Azure DevOps Services 溝通，查詢組織專案列表的完整流程。大家可以先看一下循序圖中有哪些角色，再試著由上往下依序閱讀，完整說明在圖片下面。</p>
<div class="tips">
<font color="black">
<a class="link"   href="https://modelcontextprotocol.io/specification/2025-06-18/architecture#capability-negotiation"  target="_blank">⁍ MCP - Architecture | Capacity Negotiation<i class="fas fa-external-link-alt"></i></a><br>
</font>
</div>
<br>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/07/mcp-capability-negotiation/capability_negotiation.png"
                        class=""
                 >
<h3 id="角色說明">角色說明</h3>
<ul>
<li>User（使用者）：在 VSCode 輸入查詢指令的人。</li>
<li>MCP Host（VSCode）：負責接收使用者指令，與其他元件溝通的 IDE 工具。</li>
<li>MCP Client（GitHub Copilot）：協助分析指令、整合工具，並與 AI 互動的中介。</li>
<li>gpt-4o：負責理解指令、產生工具操作建議與自然語言回應的 AI 模型。</li>
<li>Azure DevOps MCP Server：負責與 Azure DevOps 溝通的 MCP 伺服器。</li>
<li>Azure DevOps：實際儲存專案資料的雲端平台 (Azure DevOps Services)。</li>
</ul>
<h3 id="步驟流程說明">步驟流程說明</h3>
<h4 id="1-建立工具清單（首次連線時）">1. 建立工具清單（首次連線時）</h4>
<ul>
<li>MCP Client 會先建立一份工具清單（例如：有哪些查詢指令可用），並把這些資訊傳給 gpt-4o。</li>
<li>gpt-4o 準備好解析工具需求，回傳每個工具的詳細資料（名稱、參數、用途等）給 MCP Client。</li>
<li>MCP Client 把這些工具相關資料暫存下來，方便後續使用。</li>
</ul>
<h4 id="2-使用者輸入查詢">2. 使用者輸入查詢</h4>
<ul>
<li>User 在 VSCode 輸入像「組織有哪些專案？」這樣的問題。</li>
<li>MCP Host 把這個問題傳給 MCP Client。</li>
</ul>
<h4 id="3-問題分析與轉換">3. 問題分析與轉換</h4>
<ul>
<li>MCP Client 將指令及上下文資訊傳送給 gpt-4o。</li>
<li>gpt-4o 解析後發現需要查詢 Azure DevOps 的資料，於是產生對應的 MCP 指令（例如 list_projects）。</li>
</ul>
<h4 id="4-發送查詢請求">4. 發送查詢請求</h4>
<ul>
<li>MCP Client 把 list_projects 的請求發送給 MCP Host。</li>
<li>MCP Host 再把這個請求傳給 MCP Server。</li>
</ul>
<h4 id="5-與-Azure-DevOps-溝通">5. 與 Azure DevOps 溝通</h4>
<ul>
<li>MCP Server 收到請求後，轉換成 Azure DevOps 的 REST API 呼叫。</li>
<li>Azure DevOps 回傳專案列表資料給 MCP Server。</li>
</ul>
<h4 id="6-結果回傳與整合">6. 結果回傳與整合</h4>
<ul>
<li>MCP Server 將查詢結果回傳給 MCP Host。</li>
<li>MCP Host 把結果傳給 MCP Client。</li>
<li>MCP Client 整合資料，並將查詢結果及相關內容傳給 gpt-4o。</li>
</ul>
<h4 id="7-生成自然語言回應">7. 生成自然語言回應</h4>
<ul>
<li>gpt-4o 把查詢到的專案資料，轉換成自然語言答案。</li>
<li>MCP Client 將這個答案封裝好，傳回 MCP Host。</li>
<li>MCP Host 最後把結果顯示在 VSCode 介面上，讓 User 看到。</li>
</ul>
<p>整個流程就是：</p>
<p><mark>使用者發問 → VSCode 接收 → GitHub Copilot 分析 → gpt-4o 理解並產生查詢指令 → Azure DevOps 查詢 → 回傳結果 → gpt-4o 產生易懂的自然語言回應 → 顯示在 VSCode</mark><br>
每個角色都扮演特定溝通橋樑，確保使用者的問題能被正確理解並得到回覆。</p>
<h2 id="總結">總結</h2>
<p>MCP 的能力協商機制讓各個元件能根據自身特性協調最佳合作方式，確保安全、彈性與高效的互動體驗。透過明確的角色分工與標準化流程，開發者能更容易串接多元工具與服務，擴展 AI 應用場景。未來隨著 MCP 生態系持續發展，將有助於推動語意驅動開發與 AI 協作的普及。</p>
]]></content>
      <tags>
        <tag>MCP</tag>
      </tags>
  </entry>
  <entry>
    <title>Azure DevOps Services / Server 使用者授權</title>
    <url>/post/2025/04/azure-devops-licensing-description/</url>
    <content><![CDATA[<img    
                       lazyload
                       alt="image"
                       data-src="/post/2025/04/azure-devops-licensing-description/affliction512.jpg"
                         align="left" style="margin-right: 10px; width: 125px; border: 1px solid gray;"
                 > 
<p>Azure DevOps 是一個可以讓我們有效管理軟體開發流程，同時維持良好團隊協作的強大平台，除了可以直接使用雲端 Azure DevOps Services，也可以在地端自建 Azure DevOps Server 讓企業內部環境也能提供相同的服務，但許多人遇到的第一個問題是如何購買授權才能讓成本效益最大化？這篇文章主要協助大家瞭解 Azure DevOps 在授權與定價上的內容。</p>
<br>
<span id="more"></span>
<br>
<h2 id="Azure-DevOps-Services">Azure DevOps Services</h2>
<p>Azure DevOps 有五個主要功能：</p>
<ol>
<li><strong>Azure Boards</strong> (專案管理、看板管理、Scrum / Kanban、討論議題)</li>
<li><strong>Azure Repos</strong> (程式碼版控 TFVC/git)</li>
<li><strong>Azure Pipelines</strong> (自動化建置部署)</li>
<li><strong>Azure Artifacts</strong> (套件管理、自建套件來源)</li>
<li><strong>Azure Test Plans</strong> (建立與執行測試計劃)</li>
</ol>
<h3 id="Basic-Plan-與-Basic-Test-Plans">Basic Plan 與 Basic + Test Plans</h3>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/04/azure-devops-licensing-description/Basic_TestPlans.jpg"
                        class=""
                 >
<p>在 Azure DevOps 定價頁面中的 <strong><code>Basic Plan</code></strong> 包含了前面四項功能，費用是 <strong>USD $6</strong> (每個人/月)，折合台幣就要看當月的匯率計算 (例如目前是 TWD <strong>$191</strong>)；一般來說，在專案團隊裡並不是每個成員都需要建立與管理測試計劃，所以 <strong>Azure Test Plans</strong> 這項功能額外被拆出來計價，若選擇 <strong><code>Basic + Test Plans</code></strong> 費用則是 <strong>USD $52</strong> (大約 TWD <strong>$1663</strong>)。</p>
<h3 id="Stakeholder">Stakeholder</h3>
<p>除了上述兩種存取層級(Access level)之外，還有一種是免費、可使用<mark>有限功能</mark>的 <strong><code>Stakeholder</code></strong>，比較簡單的來說，這個存取層級可以：</p>
<ul>
<li>建立 / 編輯 / 查詢工作項目</li>
<li>檢視 / 核准 pipeline</li>
<li>檢視測試計劃</li>
</ul>
<p>如同它的名稱一樣：想要瞭解專案資訊，但又不需要實際參與開發實作細節(例如：單位主管、使用單位…等)，就不用再額外採購授權，使用 <strong><code>Stakeholder</code></strong> 這個存取層級就行。若需要 <strong>程式碼版控</strong>、<strong>建立/編輯 pipeline</strong>、<strong>執行測試計劃</strong> 那就不用猶豫了，至少一定需要 <strong><code>Basic</code></strong> 存取層級才能使用，這些資訊可以參閱下列連結，利用頁面裡的幣別下拉選單、拖曳數量捲軸來即時檢視費用估算，頁面最後還有一個針對不同存取層級的功能比較表，方便大家查閱。</p>
<div class="tips">
<font color="black">
<a class="link"   href="https://azure.microsoft.com/zh-tw/pricing/details/devops/azure-devops-services/"  target="_blank">⁍ Azure DevOps 定價<i class="fas fa-external-link-alt"></i></a>
<br>
<a class="link"   href="https://learn.microsoft.com/zh-tw/azure/devops/organizations/security/stakeholder-access?view=azure-devops"  target="_blank">⁍ 項目關係人存取快速參考<i class="fas fa-external-link-alt"></i></a>
</font>
</div>
<h3 id="Visual-Studio-Subscription">Visual Studio Subscription</h3>
<p>若目前已經具備 <strong>Visual Studio monthly subscription</strong> (注意：<mark>訂閱制</mark>才行)，它也包含了 Azure DevOps 的使用授權，基本上可以理解為：<strong>Visual Studio Professional monthly subscription</strong> 包含了 <strong><code>Basic Plan</code></strong>，而 <strong>Visual Studio Enterprise monthly subscription</strong> 包含了 <strong><code>Basic + Test Plans</code></strong>，詳細功能支援列表可以參考下列連結。</p>
<div class="tips">
<font color="black">
<a class="link"   href="https://learn.microsoft.com/zh-tw/azure/devops/organizations/security/access-levels?view=azure-devops"  target="_blank">⁍ 關於存取層級<i class="fas fa-external-link-alt"></i></a>
<br>
<a class="link"   href="https://marketplace.visualstudio.com/items?itemName=ms.vs-professional-monthly"  target="_blank">⁍ Visual Studio Professional monthly subscription<i class="fas fa-external-link-alt"></i></a>
<br>
<a class="link"   href="https://marketplace.visualstudio.com/items?itemName=ms.vs-enterprise-monthly"  target="_blank">⁍ Visual Studio Enterprise monthly subscription<i class="fas fa-external-link-alt"></i></a>
</font>
</div>
<h2 id="Azure-DevOps-Server">Azure DevOps Server</h2>
<p>要在地端環境自建 Azure DevOps Server 則需要先準備好 SQL Server 環境，兩者在版本上有相依性，例如：Azure DevOps Server 2022 需要搭配 SQL Server 2019 以上 (不支援 Linux 上的 SQL Server)，其他版本與相關需求建議可以參考下列連結。</p>
<div class="tips">
<font color="black">
<a class="link"   href="https://learn.microsoft.com/zh-tw/azure/devops/server/requirements?view=azure-devops-2022"  target="_blank">⁍ Azure DevOps 內部部署的需求<i class="fas fa-external-link-alt"></i></a>
</font>
</div>
<p>以授權的概念來說，安裝幾台 Azure DevOps Server 就需要幾個 Server CAL，可以透過下列幾種方式取得合法授權：</p>
<ul>
<li>傳統購買 (<mark>3年SA</mark>) Azure DevOps <mark>Server</mark> CAL</li>
<li>Visual Studio Professional / Enterprise monthly subscription (包含 Azure DevOps Server CAL)</li>
</ul>
<br>
<p>地端的使用者授權可以由下列幾種方式取得合法授權：</p>
<ul>
<li>傳統購買 (<mark>3年SA</mark>) Azure DevOps User CAL (包含 <strong><code>Basic + Test Plans</code></strong> 所有功能)</li>
<li>Visual Studio Professional / Enterprise monthly subscription (包含 Azure DevOps <mark>User</mark> CAL)</li>
<li>Azure DevOps <strong><code>Basic</code></strong> 或 <strong><code>Basic + Test Plans</code></strong> (雲端的每人每月購買方式，也包含了地端的使用者授權)</li>
</ul>
<br>
<p>以上是對於 Azure DevOps Services / Server 授權的整理說明，若大家還有其他不瞭解的地方，歡迎透過下方留言討論。 😃</p>
]]></content>
      <tags>
        <tag>Azure DevOps</tag>
        <tag>授權</tag>
      </tags>
  </entry>
  <entry>
    <title>MSTest 生命週期與常用屬性</title>
    <url>/post/2025/04/mstest-attribute-lifecycle/</url>
    <content><![CDATA[<img    
                       lazyload
                       alt="image"
                       data-src="/post/2025/04/mstest-attribute-lifecycle/MSTest.png"
                         align="left" style="margin-right: 10px; width: 125px; border: 1px solid gray;"
                 > 
<p>在軟體開發過程中，妥善進行測試可以協助我們確保程式碼的功能性與可靠性，不論是最小範圍的<strong>單元測試 (Unit Tests)</strong> 或是模擬實際用戶的<strong>端對端測試(E2E Tests)</strong>，都是品質把關的重要防線，而 MSTest 除了被整合在 Visual Studio 中，簡化了 .NET 應用程式建立和執行單元測試的過程，也可以透過 Azure Pipelines 將既有的測試專案整合到 CI 流程裡，這篇主要帶大家瞭解 MSTest 生命週期以及常用屬性，以便大家更能掌握自己的測試流程。</p>
<span id="more"></span>
<br>
<h2 id="前言">前言</h2>
<p><strong>測試類別(TestClass)</strong> 和 <strong>測試方法(TestMethod)</strong> 是 MSTest 核心要素，一個 TestClass 可以包含一個或多個 TestMethod，而我們實際要執行測試的內容就是寫在每個 TestMethod 裡，一般大家比較熟知的 3A Principle (<strong>A</strong>rrange-<strong>A</strong>ct-<strong>A</strong>ssert) 可以幫助我們快速聚焦測試方法裡面該撰寫的內容，簡單範例如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">TestClass</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyTestClass</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">TestMethod</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestMethod1</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Arrange: 初始化測試過程中所需要的變數、物件或其他設定。</span></span><br><span class="line">        <span class="built_in">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> b = <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Act: 實際測試操作、內容。</span></span><br><span class="line">        <span class="built_in">int</span> ans = a + b;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Assert: 驗證操作是否產生預期結果。</span></span><br><span class="line">        <span class="built_in">int</span> excepted = <span class="number">3</span>;</span><br><span class="line">        Assert.AreEqual(expected, actual);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="測試組件">測試組件</h2>
<p>一個 MSTest 專案建置完成後會產生一個組件(Assembly)，白話來說就是 bin 目錄的 dll 檔案，其中可以包含多個 TestClass，而一個 TestClass 裡可以有各自的 TestMethod (層級如下圖)，此外，我們會使用 <strong><code>[TestClass]</code></strong> 和 <strong><code>[TestMethod]</code></strong> 屬性項目在 MSTest 專案標記程式碼中哪些是測試類別與測試方法，下列四種寫法都代表相同的意思：</p>
<ul>
<li>[TestClass()]</li>
<li>[TestClassAttribute()]</li>
<li>[TestClass]</li>
<li>[TestClassAttribute]</li>
</ul>
<div style="max-width: 800px; text-align:center;">
<pre class="mermaid">flowchart LR
  subgraph 測試組件 Assembly 
    subgraph 測試類別 TestClass 
        subgraph 測試方法 TestMethod 
            Test1 --> Test2 --> TestN
        end
    end    
  end</pre>
</div>
<h2 id="生命週期">生命週期</h2>
<p>當我們實際在撰寫或執行多個測試時，經常需要在不同情境時初始化或清除測試資料，而上述提到的 <strong>組件層級</strong> / <strong>類別層級</strong> / <strong>測試層級</strong> 都提供了 <mark>Initialize</mark> 和 <mark>Cleanup</mark> 屬性讓我們可以在適當的時機會處理對應的邏輯。在下列範例程式中：TestProject1 組件中包含了兩個類別：Calculator(加法、減法運算)，CaculatorTests(測試類別)，在測試類別中撰寫了兩個 TestMethod (Test_AddMethod 和 Test_SubtractMethod)，同時也加上了 Constructor / Dispose、AssemblyInit / AssemblyCleanup、ClassInit / Cleanup、TestInit / TestCleanup，大家應該不難發現，這些函式都是成對的，可以直接參考下列範例程式碼與執行結果，瞭解一個測試組件從開始執行到結束歷經了哪些階段。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Diagnostics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">TestProject1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Calculator</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a + b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Subtract</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a - b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">TestClass</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CalculatorTests</span> : <span class="title">IDisposable</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Calculator calculator;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CalculatorTests</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.WriteLine(<span class="string">&quot;CalculatorTests - Constructor&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在整個測試程序集開始時執行一次</span></span><br><span class="line">        [<span class="meta">AssemblyInitialize</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AssemblyInit</span>(<span class="params">TestContext context</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.WriteLine(<span class="string">&quot;AssemblyInitialize: 測試程序集初始化。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在所有測試執行前初始化，只執行一次</span></span><br><span class="line">        [<span class="meta">ClassInitialize</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ClassInit</span>(<span class="params">TestContext context</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.WriteLine(<span class="string">&quot;ClassInitialize: 初始化 Calculator 類別實例。&quot;</span>);</span><br><span class="line">            calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在每個測試方法執行前調用</span></span><br><span class="line">        [<span class="meta">TestInitialize</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestInit</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.WriteLine(<span class="string">&quot;TestInitialize: 開始執行新的測試。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 測試加法功能</span></span><br><span class="line">        [<span class="meta">TestMethod</span>]</span><br><span class="line">        [<span class="meta">TestCategory(<span class="string">&quot;CalculatorTests&quot;</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test_AddMethod</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.WriteLine(<span class="string">&quot;Test_AddMethod: 測試加法運算。&quot;</span>);</span><br><span class="line">            <span class="built_in">int</span> result = calculator.Add(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">            Assert.AreEqual(<span class="number">8</span>, result, <span class="string">&quot;加法結果不正確&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 測試減法功能</span></span><br><span class="line">        [<span class="meta">TestMethod</span>]</span><br><span class="line">        [<span class="meta">TestCategory(<span class="string">&quot;CalculatorTests&quot;</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test_SubtractMethod</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.WriteLine(<span class="string">&quot;Test_SubtractMethod: 測試減法運算。&quot;</span>);</span><br><span class="line">            <span class="built_in">int</span> result = calculator.Subtract(<span class="number">10</span>, <span class="number">5</span>);</span><br><span class="line">            Assert.AreEqual(<span class="number">5</span>, result, <span class="string">&quot;減法結果不正確&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在每個測試方法執行後調用</span></span><br><span class="line">        [<span class="meta">TestCleanup</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestCleanup</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.WriteLine(<span class="string">&quot;TestCleanup: 測試完成，清理測試上下文。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在所有測試執行完畢後清理，只執行一次</span></span><br><span class="line">        [<span class="meta">ClassCleanup</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ClassCleanup</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.WriteLine(<span class="string">&quot;ClassCleanup: 清理 Calculator 類別實例。&quot;</span>);</span><br><span class="line">            <span class="comment">//calculator = null;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在整個測試程序集結束時執行一次</span></span><br><span class="line">        [<span class="meta">AssemblyCleanup</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AssemblyCleanup</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.WriteLine(<span class="string">&quot;AssemblyCleanup: 測試程序集清理。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.WriteLine(<span class="string">&quot;CalculatorTests - Dispose&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/04/mstest-attribute-lifecycle/console-run-test.png"
                        class=""
                 >
<h2 id="常用屬性">常用屬性</h2>
<h3 id="逾時設定-TimeoutAttribute">逾時設定 TimeoutAttribute</h3>
<p><strong><code>TimeoutAttribute</code></strong> 用於設定測試方法的最大執行時間（以<strong>毫秒</strong>為單位）。如果執行測試超過指定的時間限制，測試則會失敗，這個屬性可以讓我們避免測試執行時間過長，或是為某些測試情境設定一個逾時期限，如下範例：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.VisualStudio.TestTools.UnitTesting;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">TestProject1</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">TestClass</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TimeoutExampleTests</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 這個測試會在 500 毫秒內完成，所以它會通過</span></span><br><span class="line">        [<span class="meta">TestMethod</span>]</span><br><span class="line">        [<span class="meta">Timeout(1000)</span>]  <span class="comment">// 設置 1 秒的超時</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestMethod_WithSufficientTime</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Thread.Sleep(<span class="number">500</span>);  <span class="comment">// 模擬較短的處理時間</span></span><br><span class="line">            Assert.AreEqual(<span class="number">4</span>, <span class="number">2</span> + <span class="number">2</span>);  <span class="comment">// 假設這是測試邏輯</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 這個測試會因為超時而失敗</span></span><br><span class="line">        [<span class="meta">TestMethod</span>]</span><br><span class="line">        [<span class="meta">Timeout(1000)</span>]  <span class="comment">// 設置 1 秒的超時</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestMethod_WithTimeout</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Thread.Sleep(<span class="number">1500</span>);  <span class="comment">// 模擬超過1秒的處理時間</span></span><br><span class="line">            Assert.AreEqual(<span class="number">4</span>, <span class="number">2</span> + <span class="number">2</span>);  <span class="comment">// 假設這是測試邏輯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="平行測試-ParallelizeAttribute">平行測試 ParallelizeAttribute</h3>
<p>自 MSTest v2 起，提供了兩個關於平行測試的屬性：</p>
<ul>
<li><strong><code>ParallelizeAttribute</code></strong>：可以應用於類別或測試集來啟用平行測試。</li>
<li><strong><code>DoNotParallelizeAttribute</code></strong>：可以應用於個別測試方法來<mark>禁止</mark>它與其他測試並行執行。</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.VisualStudio.TestTools.UnitTesting;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">TestProject1</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">TestClass</span>]</span><br><span class="line">    [<span class="meta">Parallelize(Workers = 2, Scope = ExecutionScope.MethodLevel)</span>]  <span class="comment">// 啟用並行，指定最多兩個工作線程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ParallelTests</span></span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="meta">TestMethod</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestMethod1</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Thread.Sleep(<span class="number">1000</span>);  <span class="comment">// 模擬工作</span></span><br><span class="line">            Assert.AreEqual(<span class="number">4</span>, <span class="number">2</span> + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">TestMethod</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestMethod2</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Thread.Sleep(<span class="number">1000</span>);  <span class="comment">// 模擬工作</span></span><br><span class="line">            Assert.AreEqual(<span class="number">9</span>, <span class="number">3</span> * <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止這個方法與其他測試並行執行</span></span><br><span class="line">        [<span class="meta">TestMethod</span>]</span><br><span class="line">        [<span class="meta">DoNotParallelize</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestMethod3_DoNotParallelize</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Thread.Sleep(<span class="number">1000</span>);  <span class="comment">// 模擬工作</span></span><br><span class="line">            Assert.AreEqual(<span class="number">15</span>, <span class="number">5</span> * <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>[Parallelize(Workers = 2, Scope = ExecutionScope.MethodLevel)]</code></strong>：
<ul>
<li>Workers = 2 表示最多使用 2 個執行緒來執行平行測試。</li>
<li>Scope = ExecutionScope.MethodLevel 表示在方法層級平行測試，代表每個測試方法可以平行執行；如果想要在類別層級，可以設定為 ExecutionScope.ClassLevel。</li>
</ul>
</li>
<li>TestMethod1 和 TestMethod2：<br>
因為類別層級已經使用 Parallelize 屬性，並且設定 Workers = 2 表示這兩個測試方法會在執行緒池裡平行執行。</li>
<li>TestMethod3_DoNotParallelize：<br>
這個方法加了 <strong><code>[DoNotParallelize]</code></strong>，所以它<mark>不會</mark>與其他方法同時執行，當 TestMethod3_DoNotParallelize 執行時，其他平行測試會暫停，直到這個測試完成。</li>
</ul>
<h2 id="後記">後記</h2>
<p>MSTest 從推出至今已經來到了 v3，從一開始只能在 Windows 平台上運作，隨著 .NET Framework 的演進，也逐步支援跨平台運行，特別是在 .NET Core 和 .NET 5 之後，MSTest 成為了 .NET 生態系中一個可靠且簡單易用的測試框架。它不僅適合快速撰寫單元測試，還能與多種持續整合和部署工具無縫結合，例如：Azure DevOps 和 GitHub Actions。</p>
<p>由於應用程式複雜度日益提高，MSTest 從 v2 開始也提供了平行測試，允許多個測試同時執行，這不僅加快了測試速度，也提高了 CI/CD 的效能。平行測試使開發人員能夠在不影響測試完整性的前提下，顯著縮短測試週期，對大型專案尤為重要。此外，MSTest 也包含：數據驅動測試、生命週期管理、異常處理測試等，這讓我們能夠更全面地驗證應用程式的功能和效能。</p>
<p>MSTest 的易用性使得它適合不同規模的專案，加上 Visual Studio 開發工具與 Azure DevOps Services 的支援，不論是小型開發團隊或是大型企業應用，都能輕鬆採用，為軟體開發專案品質把關，也讓整個 DevOps 流程更加完善。</p>
<div class="tips">
<font color="black">
<a class="link"   href="https://github.com/microsoft/testfx"  target="_blank">⁍ Microsoft Test Framework<i class="fas fa-external-link-alt"></i></a><br>
<a class="link"   href="https://learn.microsoft.com/zh-tw/dotnet/core/testing/unit-testing-with-mstest?source=recommendations"  target="_blank">⁍ 使用 MSTest 和 .NET 進行 C# 單元測試<i class="fas fa-external-link-alt"></i></a><br>
<a class="link"   href="https://learn.microsoft.com/zh-tw/dotnet/core/testing/unit-testing-mstest-writing-tests-attributes"  target="_blank">⁍ MSTest 屬性<i class="fas fa-external-link-alt"></i></a><br>
<a class="link"   href="https://www.meziantou.net/mstest-v2-setup-a-test-project-and-run-tests.htm"  target="_blank">⁍ MSTest v2: Setup a test project and run tests<i class="fas fa-external-link-alt"></i></a>
</font>
</div>]]></content>
      <tags>
        <tag>MSTest</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 VB5/VB6 連線至 Azure DevOps Server 2022 (TFVC)</title>
    <url>/post/2025/04/vb-connect-to-azure-devops/</url>
    <content><![CDATA[<img    
                       lazyload
                       alt="image"
                       data-src="/post/2025/04/vb-connect-to-azure-devops/VS_TFS.png"
                         align="left" style="margin-right: 10px; width: 125px; border: 1px solid gray;"
                 > 
<p>Visual Studio 從 97 發展到現在的 2022 號稱地表最強開發工具，能夠與 TFS 或 Git 版控連線自然不是問題，最近剛好遇到客戶還有許多 VB5/VB6 開發的 Winform 程式需要維護，而且版控伺服器也從 TFS 2013 升級至 Azure DevOps Server 2022，藉此機會向大家整理說明 Visual Studio 各版本與 TFS / Azure DevOps 連線的需求與設定。<br>
<br></p>
<span id="more"></span>
<br>
<h2 id="前言">前言</h2>
<p>我們使用 Visual Studio 開發工具能夠與 TFS 連線是因為它的功能包含了 <strong><code>Team Explorer</code></strong>，明確來說是從 Visual Studio 2005 首次引入 TFS (Team Foundation Server) 起才開始包含此功能，在這個版本之前則需要額外安裝 <strong>Team Explorer</strong> 和 <strong>MSSCCI Provider</strong> (Microsoft Source Code Control Integration) 才能夠在開發工具中與 TFS 進行整合。</p>
<h2 id="版本相依性">版本相依性</h2>
<p>作業系統、開發工具與版控伺服器彼此間有一定的版本相依性，Windows XP 無法安裝 Team Explorer 2013，只能安裝 Team Explorer 2010，搭配 MSSCCI Provider 2010 可以連線的版本有：TFS 2005 ~ 2018 和 Azure DevOps Server 2019/2020 <mark>(不包含2022)</mark>，若舊開發環境 (Visual Studio 2013 以前) 想要與 Azure DevOps Server 2022 連線，必要最低門檻可以參考下列配置：</p>
<ul>
<li><strong>Windows 7 以上</strong></li>
<li><strong>Team Explorer 2013</strong></li>
<li><strong>MSSCCI Provider 2013</strong></li>
</ul>
<p>Visual Studio 97/6/2003~2008 搭配 Team Explorer 2010 + MSSCCI Provider 2010 可以從開發工具連線至 TFS 2010~2017 和 Azure DevOps Server 2019/2020，若要連線至 Azure DevOps Server 2022 則需要搭配 Team Explorer 2013 + MSSCCI Provider 2013 才行，各版本 MSSCCI Provider 可以自 Visual Studio | Marketplace 取得：</p>
<div class="tips">
<font color="black">
<a class="link"   href="https://marketplace.visualstudio.com/items?itemName=TFSPowerToolsTeam.MicrosoftVisualStudioTeamFoundationServer2010MSSCC"  target="_blank">⁍ Microsoft Visual Studio Team Foundation Server 2010 MSSCCI Provider 32-bit<i class="fas fa-external-link-alt"></i></a><br>
<a class="link"   href="https://marketplace.visualstudio.com/items?itemName=TFSPowerToolsTeam.MicrosoftVisualStudioTeamFoundationServer2012MSSCC"  target="_blank">⁍ Microsoft Visual Studio Team Foundation Server 2012 MSSCCI Provider 32-bit<i class="fas fa-external-link-alt"></i></a><br>
<a class="link"   href="https://marketplace.visualstudio.com/items?itemName=TFSPowerToolsTeam.MicrosoftVisualStudioTeamFoundationServer20132015M"  target="_blank">⁍ Microsoft Visual Studio Team Foundation Server 2013&2015 MSSCCI Provider 32-bit<i class="fas fa-external-link-alt"></i></a><br>
<a class="link"   href="https://marketplace.visualstudio.com/items?itemName=TFSPowerToolsTeam.TeamFoundationServerMSSCCIProvider201064-bit"  target="_blank">⁍ Team Foundation Server MSSCCI Provider 2010 64-bit<i class="fas fa-external-link-alt"></i></a><br>
<a class="link"   href="https://marketplace.visualstudio.com/items?itemName=TFSPowerToolsTeam.MicrosoftVisualStudioTeamFoundationServer2012MSSCC-9956"  target="_blank">⁍ Microsoft Visual Studio Team Foundation Server 2012 MSSCCI Provider 64-bit<i class="fas fa-external-link-alt"></i></a><br>
<a class="link"   href="https://marketplace.visualstudio.com/items?itemName=TFSPowerToolsTeam.MicrosoftVisualStudioTeamFoundationServer20132015M-11387"  target="_blank">⁍ Microsoft Visual Studio Team Foundation Server 2013&2015 MSSCCI Provider 64-bit<i class="fas fa-external-link-alt"></i></a><br>
</font>
</div>
<h2 id="VB5-VB6">VB5/VB6</h2>
<p>在 VB5/VB6 的工具列需要額外安裝上述提到的 MSSCCI Provider 2010/2013 才會出現 <strong>Team Foundation</strong> 選項，讓我們在開發工具中將程式碼與版控伺服器整合。</p>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/04/vb-connect-to-azure-devops/create-project-from-tfs.png"
                        class=""
                 >
<p>若出現下列錯誤訊息，就是 MSSCCI Provider 版本太舊了，無法連線到新的版控伺服器，例如：安裝 MSSCCI Provider 2010 但想要與 Azure DevOps Server 2022 連線，唯一解法就是安裝 Team Explorer 2013 + MSSCCI Provider 2013。</p>
<blockquote>
<p>TF14045: The identity 主機名稱\2ffd15ae-91e4-4df8-a346-e5be57e1340e is not a recognized identity.</p>
</blockquote>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/04/vb-connect-to-azure-devops/not-a-recognized-identity.png"
                        class=""
                 >
<p>在實務情境可能還會遇到其他各種版本組合，經此次嘗試後，確認 VB5/VB6 都還可以與 Azure DevOps Server 2022 的 TFVC 版控進行整合，這邊有篇文章將各種組合條列得很詳盡，也提供大家參考。</p>
<div class="tips">
<font color="black">
<a class="link"   href="https://jessehouwing.net/azure-devops-connect-any-visual-studio-version/"  target="_blank">⁍ Connect any version of Visual Studio to Azure DevOps or Azure DevOps Server<i class="fas fa-external-link-alt"></i></a><br>
</font>
</div>
]]></content>
      <tags>
        <tag>VB5</tag>
        <tag>VB6</tag>
        <tag>TFS</tag>
        <tag>Team Explorer</tag>
        <tag>MSSCCI Provider</tag>
      </tags>
  </entry>
  <entry>
    <title>VS Code 的 Custom Instructions</title>
    <url>/post/2025/11/vscode-custom-instructions/</url>
    <content><![CDATA[<img    
                       lazyload
                       alt="image"
                       data-src="/post/2025/11/vscode-custom-instructions/vscode-github-copilot.jpg"
                         align="left" style="margin-right: 10px; width: 125px; border: 1px solid gray;"
                 > 
<p>隨著 AI 輔助開發工具的普及，GitHub Copilot 已成為許多開發者日常工作中不可或缺（CP值最高）的助手。在預設情況下 GitHub Copilot 僅能提供通用的程式碼建議與回應。為了讓 AI 更貼近專案需求、遵循團隊的程式碼風格，以及提升開發效率，VS Code 提供了多種自訂機制，讓開發者能夠客製化 GitHub Copilot 的行為。本文將介紹 VS Code 中 GitHub Copilot 可以自訂的幾種方式：Custom Instructions、Prompt Files 以及 Chat Modes，協助大家打造更符合個人或團隊需求的 AI 開發環境。</p>
<span id="more"></span>
<br>
<p>GitHub Copilot 可以依據上下文提供程式碼建議，但每個專案或團隊都有其獨特的需求：不同的程式碼風格、特定的開發框架、安全性檢查標準，或是團隊約定的最佳實踐。透過自訂機制我們可以：</p>
<ul>
<li><strong>統一程式碼風格</strong>：確保生成的程式碼符合專案規範。</li>
<li><strong>提升工作效率</strong>：減少重複性的提示輸入，讓 AI 自動遵循既定規則。</li>
<li><strong>強化專案一致性</strong>：讓所有團隊成員使用相同的 AI 輔助標準。</li>
<li><strong>擴展 AI 能力</strong>：透過工具整合與外部服務連接，讓 AI 執行更複雜的任務。</li>
</ul>
<p>在 VS Code 中我們可以從最基本的設定逐步延伸到進階的工作流程，依需求打造專屬的 AI 開發環境。VS Code 的工作區設定通常儲存在專案根目錄下的 <strong><code>.vscode</code></strong> 資料夾；而 GitHub Copilot 的客製 instructions、prompt 與 chat modes 則常放在 <strong><code>.github</code></strong> 目錄中。順帶一提，VS Code 的使用者設定也可以放在系統的使用者設定（User Profile）路徑：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">VS Code</span><br><span class="line">%APPDATA%\Code\User\settings.json</span><br><span class="line">%APPDATA%\Code\User\prompts\*.md</span><br><span class="line">--</span><br><span class="line">VS Code Insider</span><br><span class="line">%APPDATA%\Code - Insiders\User\settings.json</span><br><span class="line">%APPDATA%\Code - Insiders\User\prompts\*.md</span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/11/vscode-custom-instructions/custom-instructions.jpg"
                        class=""
                 >
<h2 id="Custom-Instructions">Custom Instructions</h2>
<p>Custom Instructions 讓我們可以在 Markdown 檔案中定義通用規則，這些 instructions 會自動套用到 AI 產生程式碼的方式以及處理其他開發任務的行為。相較於在每次對話中手動重複提供相同的上下文，Custom Instructions 能確保 AI 回應始終符合我們程式碼實作與專案需求。需要注意的是 Custom Instructions <mark><strong>不會套用於編輯器中的程式碼自動完成功能（code completions），僅影響聊天互動的回應內容</strong></mark>。</p>
<h3 id="Instructions-類型">Instructions 類型</h3>
<p>VS Code 支援下列基於 Markdown 的 instructions 檔案，這些檔案可以同時存在，VS Code 會將它們合併並加入到聊天的上下文中：</p>
<table>
<thead>
<tr>
<th style="text-align:left">檔案類型</th>
<th style="text-align:left">說明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">.github/copilot-instructions.md</td>
<td style="text-align:left">單一檔案且檔名與路徑都要符合規定，會自動套用於工作區中的所有聊天請求。</td>
</tr>
<tr>
<td style="text-align:left">.instructions.md</td>
<td style="text-align:left">可依據實際需求建立多個檔案，針對特定任務或檔案使用，透過 <strong><code>applyTo</code></strong> 定義適用範圍。</td>
</tr>
<tr>
<td style="text-align:left">AGENTS.md （experimental）</td>
<td style="text-align:left">可以在工作區中定義多個 AI agent 的使用情境。</td>
</tr>
</tbody>
</table>
<h3 id="使用-copilot-instructions-md">使用 copilot-instructions.md</h3>
<p>適合定義全域的規範（例如：目前專案的 Coding Guidline）, 在工作區根目錄建立 <strong>.github/copilot-instructions.md</strong> 檔案後，VSCode 就會自動將其套用到所有聊天請求中。</p>
<p><strong>設定步驟：</strong></p>
<ol>
<li>啟用 VS Code 設定 <strong>github.copilot.chat.codeGeneration.useInstructionFiles</strong>（預設是已啟用)。</li>
<li>在工作區根目錄建立 <strong>.github/copilot-instructions.md</strong> 檔案。</li>
<li>使用 Markdown 格式以自然語言描述內容。</li>
</ol>
<p><strong>以 C# Coding Guidline 為例：</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 專案程式碼規範（C# / .NET 8）</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 使用 C# 開發（目標平台：.NET 8），專案建議啟用 Nullable Reference Types（在 csproj 中設定 <span class="code">`&lt;Nullable&gt;enable&lt;/Nullable&gt;`</span>）</span><br><span class="line"><span class="bullet">-</span> 遵循 <span class="code">`.editorconfig`</span> 與 Microsoft 建議（使用 <span class="code">`dotnet format`</span>、Roslyn analyzers，如 <span class="code">`Microsoft.CodeAnalysis.NetAnalyzers`</span>），並在 CI 中自動檢查格式與規則</span><br><span class="line"><span class="bullet">-</span> 命名規則：</span><br><span class="line"><span class="bullet">  -</span> 公開型別（類別、結構、介面）、方法、屬性、事件：PascalCase（介面以 <span class="code">`I`</span> 前綴）</span><br><span class="line"><span class="bullet">  -</span> 私有欄位使用 <span class="code">`_camelCase`</span>（底線 + camelCase）或 <span class="code">`camelCase`</span>，局部變數使用 <span class="code">`camelCase`</span></span><br><span class="line"><span class="bullet">  -</span> 非同步方法以 <span class="code">`Async`</span> 後綴（例如：<span class="code">`GetItemsAsync`</span>）</span><br><span class="line"><span class="bullet">-</span> 所有公開 API 與重要方法應加上 XML 文件註解（<span class="code">`///`</span>），說明用途、參數與回傳值，以利產生文件與使用者理解</span><br><span class="line"><span class="bullet">-</span> 優先使用 <span class="code">`async`</span>/<span class="code">`await`</span>，避免使用 <span class="code">`async void`</span>（事件處理器除外）；所有可取消的非同步方法應接收 <span class="code">`CancellationToken`</span></span><br><span class="line"><span class="bullet">-</span> 使用依賴注入（DI）與介面抽象，避免全域靜態狀態；以相依反轉提高可測性</span><br><span class="line"><span class="bullet">-</span> 資源釋放使用 <span class="code">`using`</span> / <span class="code">`await using`</span> 或透過 DI 管理生命週期，避免手動忘記 Dispose</span><br><span class="line"><span class="bullet">-</span> 序列化建議使用 <span class="code">`System.Text.Json`</span>（除非有特殊需求才考慮 Newtonsoft.Json），並注意用 JsonSerializerOptions 設定</span><br><span class="line"><span class="bullet">-</span> 例外處理：不要靜默吞錯；捕獲例外時要有明確策略（記錄、重試或以 Domain-specific 例外包裝再拋出）</span><br><span class="line"><span class="bullet">-</span> 日誌請使用結構化日誌（例如：Microsoft.Extensions.Logging），在日誌中記錄足夠的上下文，不要記錄敏感資訊</span><br><span class="line"><span class="bullet">-</span> 測試：為核心邏輯撰寫單元測試、為重要整合與端對端流程建立整合測試，CI 中執行 <span class="code">`dotnet test`</span></span><br><span class="line"><span class="bullet">-</span> 效能考量：避免不必要的複製與分配；在熱路徑考慮使用 <span class="code">`Span&lt;T&gt;/Memory&lt;T&gt;`</span> 與 pooling 技術，但以可讀性為優先</span><br><span class="line"><span class="bullet">-</span> 安全性：不要在原始碼中放置密碼或金鑰；使用 Secret Manager、環境變數或外部秘密管理系統（如 Key Vault）</span><br><span class="line"><span class="bullet">-</span> 避免使用 <span class="code">`dynamic`</span> 或 <span class="code">`unsafe`</span>，除非有充分理由並在程式碼中加上註解與測試</span><br></pre></td></tr></table></figure>
<h3 id="使用-instructions-md">使用 .instructions.md</h3>
<p>當我們需要針對不同的程式語言、框架或任務建立專屬指示時，可以使用 <strong>.instructions.md</strong> 檔案。<mark>透過 <strong>applyTo</strong> 屬性，可以指定套用的檔案或路徑範圍</mark>。</p>
<p><strong>檔案結構：</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">description: &quot;Python 專案程式碼規範&quot;</span><br><span class="line"><span class="section">applyTo: &quot;<span class="strong">**/<span class="emphasis">*.py&quot;</span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="section">---</span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="section"></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="section"># Python 程式撰寫風格</span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="section"></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="section">- 遵循 PEP 8 風格指南</span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="section">- 優先考慮可讀性與清晰度</span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="section">- 為每個函式撰寫清晰簡潔的註解</span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="section">- 確保函式名稱具有描述性並包含型別提示</span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="section">- 保持適當的縮排（每層使用 1 個 Tab 間隔）</span></span></span></span><br></pre></td></tr></table></figure>
<p><strong>建立方式：</strong></p>
<ol>
<li>在 Chat 中選擇 <strong>Configure Chat &gt; Instructions &gt; New instruction file</strong></li>
<li>選擇儲存位置（Workspace 或 User Profile）</li>
<li>輸入檔案名稱並撰寫指示內容</li>
<li>使用 applyTo 定義套用的範圍（例如：<strong>*.ts</strong> , <strong>*.tsx</strong>）</li>
</ol>
<p><mark><strong>注意事項</strong></mark><br>
過去我們習慣把各種自訂情境集中寫在 <strong>.github/copilot-instructions.md</strong>，但這樣容易造成不必要的 token 浪費或增加模型誤判（幻覺）的風險。現在可以透過建立多個獨立的 instruction 檔案來區分不同情境，並以 <strong>applyTo</strong> 指定要套用的檔案或路徑。不過在定義 custom instruction 時，要特別留意 <strong>applyTo</strong> 的範圍設定。例如下圖所示，本來只想針對特定檔案執行程式碼審查（review）以檢查是否符合 coding guideline，但若其他情境也設定了相同的 <strong>applyTo</strong>（例如都指定 *.cs），就可能出現規則衝突或語意矛盾，而這類上下文衝突往往是造成 AI 幻覺的主要原因。</p>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/11/vscode-custom-instructions/review-coding-guideline.jpg"
                        class=""
                 >
<h3 id="設定檔">設定檔</h3>
<p>對於 Custom Instructions 我們也可以透過 VS Code 的使用者設定或工作區設定來定義。在設定檔（VS Code 的 <strong>settings.json</strong>）中，既可以直接把內容輸入到 <strong><code>text</code></strong> 屬性，也可以用 <strong><code>file</code></strong> 屬性指定實體檔案路徑。此外，<strong>Code generation</strong> 與 <strong>Test generation</strong> 已明確建議改用 Instruction files，並標示為 deprecated（已棄用）。</p>
<table>
<thead>
<tr>
<th style="text-align:left">使用情境</th>
<th style="text-align:left">設定項目</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Code review</td>
<td style="text-align:left">github.copilot.chat.reviewSelection.instructions</td>
</tr>
<tr>
<td style="text-align:left">Commit message generation</td>
<td style="text-align:left">github.copilot.chat.commitMessageGeneration.instructions</td>
</tr>
<tr>
<td style="text-align:left">Pull Request title and description generation</td>
<td style="text-align:left">github.copilot.chat.pullRequestDescriptionGeneration.instructions</td>
</tr>
<tr>
<td style="text-align:left">Code generation <strong>(deprecated)</strong></td>
<td style="text-align:left">github.copilot.chat.codeGeneration.instructions</td>
</tr>
<tr>
<td style="text-align:left">Test generation <strong>(deprecated)</strong></td>
<td style="text-align:left">github.copilot.chat.testGeneration.instructions</td>
</tr>
</tbody>
</table>
<p><strong>設定範例：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;github.copilot.chat.pullRequestDescriptionGeneration.instructions&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Always include a list of key changes.&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;github.copilot.chat.reviewSelection.instructions&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;file&quot;</span><span class="punctuation">:</span> <span class="string">&quot;guidance/backend-review-guidelines.md&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;file&quot;</span><span class="punctuation">:</span> <span class="string">&quot;guidance/frontend-review-guidelines.md&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/11/vscode-custom-instructions/custom-instructions-settings.jpg"
                        class=""
                 >
<h3 id="撰寫技巧">撰寫技巧</h3>
<ul>
<li>保持指示簡短且獨立，每條指示應該是單一、簡單的陳述。</li>
<li>針對特定任務或程式語言，使用多個 <strong>.instructions.md</strong> 檔案，並透過 <strong><code>applyTo</code></strong> 屬性選擇性套用。</li>
<li>將專案特定的指示儲存在工作區中，以便與團隊成員共享並納入版本控制。</li>
<li>在 Prompt Files 和 Chat Modes 中參考 Instructions 檔案，保持內容簡潔並避免重複。</li>
</ul>
<h2 id="Prompt-Files">Prompt Files</h2>
<p>Prompt Files 是可重複使用的 Markdown 檔案，可以定義我們常用、可重複執行的任務。與 Custom Instructions 不同的是，Prompt Files 是獨立的提示，可以在聊天中直接執行。我們可以在其中包含任務特定的上下文與執行指引，並結合 Custom Instructions 確保複雜任務的一致執行，在 VS Code 的 GitHub Copilot 對話視窗中只要輸入 <strong><code>/</code></strong> 就可以選擇自訂的 Prompt Files。</p>
<h3 id="檔案結構">檔案結構</h3>
<p>Prompt Files 使用 <mark><strong>.prompt.md</strong></mark> 副檔名，結構如下：</p>
<p><strong>YAML frontmatter</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;建立 React 表單元件&quot;</span></span><br><span class="line"><span class="attr">mode:</span> <span class="string">&quot;agent&quot;</span></span><br><span class="line"><span class="attr">model:</span> <span class="string">&quot;Claude Sonnet 4&quot;</span></span><br><span class="line"><span class="attr">tools:</span> [<span class="string">&quot;search&quot;</span>, <span class="string">&quot;fetch&quot;</span>, <span class="string">&quot;git&quot;</span>]</span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left">欄位</th>
<th style="text-align:left">說明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">description</td>
<td style="text-align:left">提示的簡短描述。</td>
</tr>
<tr>
<td style="text-align:left">mode</td>
<td style="text-align:left">聊天模式：<code>ask</code>、<code>edit</code> 或 <code>agent</code>（預設）。</td>
</tr>
<tr>
<td style="text-align:left">model</td>
<td style="text-align:left">執行提示時使用的語言模型，若未指定則使用目前選擇的模型。</td>
</tr>
<tr>
<td style="text-align:left">tools</td>
<td style="text-align:left">可使用的工具或工具集名稱陣列。</td>
</tr>
</tbody>
</table>
<p><strong>Markdown 格式的提示指示</strong></p>
<p>在主體中可以使用變數，例如：</p>
<ul>
<li>工作區變數：<code>$&#123;workspaceFolder&#125;</code>、<code>$&#123;workspaceFolderBasename&#125;</code></li>
<li>選取變數：<code>$&#123;selection&#125;</code>、<code>$&#123;selectedText&#125;</code></li>
<li>檔案上下文變數：<code>$&#123;file&#125;</code>、<code>$&#123;fileBasename&#125;</code>、<code>$&#123;fileDirname&#125;</code></li>
<li>輸入變數：<code>$&#123;input:variableName&#125;</code>、<code>$&#123;input:variableName:placeholder&#125;</code></li>
</ul>
<h3 id="建立-Prompt-File">建立 Prompt File</h3>
<p><strong>步驟：</strong></p>
<ol>
<li>啟用設定 <strong>chat.promptFiles</strong> （預設已啟用，且路徑是 .github/prompts）。</li>
<li>在 Chat 視窗中選擇 <strong>Configure Chat &gt; Prompt Files &gt; New prompt file</strong>。</li>
<li>選擇儲存位置（Workspace 或 User Profile）。</li>
<li>輸入檔案名稱並使用 Markdown 格式撰寫提示內容。</li>
</ol>
<p><strong>範例：</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">description: &quot;建立可重複使用的 React 表單元件&quot;</span><br><span class="line">mode: &quot;agent&quot;</span><br><span class="line"><span class="section">tools: [&quot;search&quot;, &quot;edit&quot;]</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 建立 React 表單元件</span></span><br><span class="line"></span><br><span class="line">請建立一個可重複使用的 React 表單元件，具有以下特性：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 使用 TypeScript 並包含完整的型別定義</span><br><span class="line"><span class="bullet">2.</span> 支援表單驗證（使用 React Hook Form）</span><br><span class="line"><span class="bullet">3.</span> 包含錯誤訊息顯示</span><br><span class="line"><span class="bullet">4.</span> 具有可自訂的樣式屬性</span><br><span class="line"><span class="bullet">5.</span> 提供使用範例與說明文件</span><br><span class="line"></span><br><span class="line">元件名稱：$&#123;input:componentName:FormComponent&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用-Prompt-File">使用 Prompt File</h3>
<p>有三種方式可以執行 Prompt File：</p>
<ol>
<li><strong>在 Chat 視窗中輸入</strong>：在聊天輸入欄位中輸入 <code>/</code> 後接 prompt file 名稱和參數，例如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/create-react-form: componentName=LoginForm</span><br></pre></td></tr></table></figure>
</li>
<li><strong>使用命令面板</strong>：執行 <strong>Chat: Run Prompt</strong> 命令並從列表中選擇 prompt file。</li>
<li><strong>直接執行</strong>：在編輯器中開啟 prompt file，點擊編輯器標題列的播放按鈕。</li>
</ol>
<h2 id="Chat-Modes">Chat Modes</h2>
<p>Chat Modes 可以為特定角色或任務建立專屬的 AI 助理，在 Markdown 檔案中我們可以定義其範圍與能力、可存取的工具以及語言模型。不同的任務需要不同的能力，例如在規劃階段可能只需要唯讀工具進行研究與分析以防止意外的程式碼變更，而實作模式則需要完整的編輯能力。Chat Modes 讓我們能夠精確指定每個任務可用的工具，確保 AI 具備適合該工作的能力。</p>
<h3 id="Chat-Mode-檔案結構">Chat Mode 檔案結構</h3>
<p>Chat Mode 檔案使用 <mark><strong>.chatmode.md</strong></mark> 副檔名，結構如下：</p>
<p><strong>YAML frontmatter</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;建立實作計畫&quot;</span></span><br><span class="line"><span class="attr">tools:</span> [<span class="string">&quot;search&quot;</span>, <span class="string">&quot;fetch&quot;</span>]</span><br><span class="line"><span class="attr">model:</span> <span class="string">&quot;Claude Sonnet 4&quot;</span></span><br><span class="line"><span class="attr">handoffs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">label:</span> <span class="string">&quot;開始實作&quot;</span></span><br><span class="line">    <span class="attr">agent:</span> <span class="string">&quot;implementation&quot;</span></span><br><span class="line">    <span class="attr">prompt:</span> <span class="string">&quot;請根據上述計畫開始實作&quot;</span></span><br><span class="line">    <span class="attr">send:</span> <span class="literal">false</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left">欄位</th>
<th style="text-align:left">說明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">description</td>
<td style="text-align:left">Chat mode 的簡短描述，顯示在聊天輸入欄位的文字。</td>
</tr>
<tr>
<td style="text-align:left">tools</td>
<td style="text-align:left">可用的工具或工具集名稱列表。</td>
</tr>
<tr>
<td style="text-align:left">model</td>
<td style="text-align:left">執行提示時使用的 AI 模型。</td>
</tr>
<tr>
<td style="text-align:left"><mark>handoffs</mark> （experimental）</td>
<td style="text-align:left">可選的後續動作或提示列表，用於在 Chat Modes 之間轉換。</td>
</tr>
</tbody>
</table>
<h3 id="Handoffs">Handoffs</h3>
<p>Handoffs 是 VS Code Insiders 版本的實驗性功能，讓我們能夠建立引導式的順序工作流程，在不同 Chat Modes 之間轉換並提供建議的下一步操作。在聊天回應完成後，會出現交接按鈕，讓使用者可以帶著相關上下文提示移動到下一個模式。以軟體開發流程為例，我們可以設計如下三個 Chat mode：</p>
<ul>
<li>規劃（planning）— 產出任務清單與接受準則。</li>
<li>實作（implementation）— 產生/修改程式碼、建立測試、建立 branch。</li>
<li>程式碼審查（review）— 讀取程式碼變更、產生 review 建議和 PR 描述。</li>
</ul>
<p>透過 Handoffs 可以讓我們在「規劃」完成後，一鍵把上下文（任務清單、接受準則、檔案清單）傳到「實作」模式，或從「實作」傳到「審查」模式，讓下一個模式能立即取得足夠的上下文與行動指示（也可選擇自動執行或先由使用者確認）。</p>
<p><strong>planning.chatmode.md</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;規劃模式 — 擬定需求與任務拆分&quot;</span></span><br><span class="line"><span class="attr">tools:</span> [<span class="string">&quot;search&quot;</span>]</span><br><span class="line"><span class="attr">model:</span> <span class="string">&quot;default&quot;</span></span><br><span class="line"><span class="attr">handoffs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">label:</span> <span class="string">&quot;開始實作&quot;</span></span><br><span class="line">    <span class="attr">agent:</span> <span class="string">&quot;implementation&quot;</span></span><br><span class="line">    <span class="attr">prompt:</span> <span class="string">|</span></span><br><span class="line"><span class="string">      我已完成規劃。請以下列任務清單開始實作：</span></span><br><span class="line"><span class="string">      任務清單：</span></span><br><span class="line"><span class="string">      &#123;&#123;tasks&#125;&#125;</span></span><br><span class="line"><span class="string">      接受準則：</span></span><br><span class="line"><span class="string">      &#123;&#123;acceptance&#125;&#125;</span></span><br><span class="line"><span class="string">      請建立一個實作任務（branch + 主要檔案列表），並在實作模式中列出需要產生或修改的檔案與測試。</span></span><br><span class="line"><span class="string"></span>    <span class="attr">send:</span> <span class="literal">false</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>
<p><strong>implementation.chatmode.md</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;實作模式 — 產生程式碼、測試與 commit&quot;</span></span><br><span class="line"><span class="attr">tools:</span> [<span class="string">&quot;edit&quot;</span>, <span class="string">&quot;git&quot;</span>, <span class="string">&quot;search&quot;</span>]</span><br><span class="line"><span class="attr">model:</span> <span class="string">&quot;default&quot;</span></span><br><span class="line"><span class="attr">handoffs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">label:</span> <span class="string">&quot;送交審查&quot;</span></span><br><span class="line">    <span class="attr">agent:</span> <span class="string">&quot;review&quot;</span></span><br><span class="line">    <span class="attr">prompt:</span> <span class="string">|</span></span><br><span class="line"><span class="string">      已完成實作，請啟動審查流程：</span></span><br><span class="line"><span class="string">      - 列出本次變更檔案</span></span><br><span class="line"><span class="string">      - 產生 PR 標題與描述（包含變更重點、測試覆蓋與注意事項）</span></span><br><span class="line"><span class="string">      - 若發現明顯問題請直接在 review 模式中提出建議</span></span><br><span class="line"><span class="string"></span>    <span class="attr">send:</span> <span class="literal">false</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>
<p><strong>review.chatmode.md</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;審查模式 — 產生審查建議與 PR 文案&quot;</span></span><br><span class="line"><span class="attr">tools:</span> [<span class="string">&quot;search&quot;</span>]</span><br><span class="line"><span class="attr">model:</span> <span class="string">&quot;default&quot;</span></span><br><span class="line"><span class="attr">handoffs:</span> []</span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>
<p>handoffs 屬性說明：</p>
<ul>
<li>label：在 Chat 介面會看到的按鈕名稱。</li>
<li>agent：目標 Chat Mode 的識別名稱（通常與對應 .chatmode.md 的檔案名或 agent 名稱一致）。</li>
<li>prompt：傳給目標模式的內容（建議使用簡短清楚的指示，也可用變數替換）。</li>
<li>send：
<ul>
<li>true 表示使用者點按後立即將 prompt 送出並執行。</li>
<li>false 表示只切換到目標模式並把 prompt 放在輸入框，讓使用者檢視/修改後再發送。</li>
</ul>
</li>
</ul>
<h3 id="建立-Chat-Mode">建立 Chat Mode</h3>
<ol>
<li>在 Chat 視窗中選擇 <strong>Configure Chat &gt; Modes &gt; Create new custom chat mode file</strong>。</li>
<li>選擇儲存位置（Workspace 或 User Profile）。</li>
<li>輸入 Chat Mode 的名稱（此名稱會顯示在 Chat 視窗的 Chat Mode 下拉選單中）。</li>
<li>在新建立的 <strong>.chatmode.md</strong> 檔案中提供詳細資訊。</li>
</ol>
<h3 id="工具列表優先順序">工具列表優先順序</h3>
<p>當 chat mode 和 prompt file 都指定了 <strong>tools</strong> 欄位時，可用工具的優先順序如下：</p>
<ol>
<li>Prompt file 中指定的工具（如果有）。</li>
<li>Prompt file 中參考的 Chat Mode 的工具（如果有）。</li>
<li>所選 chat mode 的預設工具。</li>
</ol>
<h2 id="客製化的實際應用情境">客製化的實際應用情境</h2>
<table>
<thead>
<tr>
<th style="text-align:left">使用情境</th>
<th style="text-align:left">建議方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">專案級程式碼規範</td>
<td style="text-align:left">Custom Instructions</td>
</tr>
<tr>
<td style="text-align:left">程式語言或框架特定規則</td>
<td style="text-align:left">Custom Instructions（搭配 glob patterns）</td>
</tr>
<tr>
<td style="text-align:left">可重複使用的開發任務</td>
<td style="text-align:left">Prompt Files</td>
</tr>
<tr>
<td style="text-align:left">以規劃或研究模式使用聊天</td>
<td style="text-align:left">Custom Chat Modes</td>
</tr>
<tr>
<td style="text-align:left">定義專門的工作流程</td>
<td style="text-align:left">Custom Chat Modes</td>
</tr>
<tr>
<td style="text-align:left">整合外部服務</td>
<td style="text-align:left">MCP and Tools</td>
</tr>
</tbody>
</table>
<h2 id="入門建議">入門建議</h2>
<h3 id="1-嘗試不同的語言模型">1. 嘗試不同的語言模型</h3>
<p>從實驗不同的語言模型開始，為不同類型的工作獲得更好的結果。使用聊天中的模型選擇器切換模型，簡單任務使用較快的模型，複雜推理使用更強大的模型，例如：一般工作任務可以使用 GPT-5 mini (0x)，實際要產生程式碼再選擇 Claude Sonnet 4.5 (1x)。</p>
<h3 id="2-設定基本指引">2. 設定基本指引</h3>
<p>建立 Custom Instructions 可讓所有與 LLM 的聊天互動產生一致的結果。建議在工作區建立一個包含程式碼規範與偏好的 <strong>.github/copilot-instructions.md</strong>，以改善聊天回應；一般來說，整個專案應遵循的規範可在此定義。</p>
<h3 id="3-加入任務自動化">3. 加入任務自動化</h3>
<p>識別重複性任務後，為常見工作流程建立 Prompt Files。就像開發時會把常用的程式碼區塊抽成共用元件一樣，在 GitHub Copilot 的情境中，這類流程可儲存為獨立的 Prompt Files 以便重複使用。</p>
<h3 id="4-擴展能力">4. 擴展能力</h3>
<p>當需要連接外部服務或執行特定操作時，可以加入 MCP servers 和工具來擴展 LLM 的輔助能力。</p>
<h3 id="5-建立自己的工作流程">5. 建立自己的工作流程</h3>
<p>我們也可以透過建立自訂的 Chat Modes 並結合特定工具、指示與上下文，針對特定角色或專案階段使用，甚至也可以透過 handoffs 的方式來實作一個像是 Spec-kit 但卻又更符合自己需求的工作流程。</p>
<h2 id="結語">結語</h2>
<p>透過 Custom Instructions、Prompt Files 和 Chat Modes 三種機制，VS Code 中的 GitHub Copilot 能夠從通用的 AI 助手轉變為貼近專案需求、遵循團隊規範的專屬開發夥伴。Custom Instructions 提供全域或特定範圍的程式碼規範，Prompt Files 讓重複性任務標準化與自動化，而 Chat Modes 則為不同角色與工作流程建立專門的 AI 環境。這些客製化功能不僅提升了開發效率，也確保了團隊協作的一致性。從最簡單的設定檔開始，逐步建立適合你的 AI 開發環境，讓 GitHub Copilot 成為真正理解你需求的智慧助手。</p>
<p><mark>下面參考連結有一個 Awesome Copilot (非常重要)，裡面有豐富的 Instructions / Prompts / Chat Modes 可以參考使用，大家記得一定要去挖寶!</mark></p>
<div class="tips">
<font color="black">
<a class="link"   href="https://code.visualstudio.com/docs/copilot/customization/overview"  target="_blank">⁍ Customize chat to your workflow<i class="fas fa-external-link-alt"></i></a><br>
<a class="link"   href="https://code.visualstudio.com/docs/copilot/customization/custom-instructions"  target="_blank">⁍ Use custom instructions in VS Code<i class="fas fa-external-link-alt"></i></a><br>
<a class="link"   href="https://code.visualstudio.com/docs/copilot/customization/prompt-files"  target="_blank">⁍ Use prompt files in VS Code<i class="fas fa-external-link-alt"></i></a><br>
<a class="link"   href="https://code.visualstudio.com/docs/copilot/customization/custom-chat-modes"  target="_blank">⁍ Custom chat modes in VS Code<i class="fas fa-external-link-alt"></i></a><br>
<a class="link"   href="https://github.com/github/awesome-copilot"  target="_blank">⁍ GitHub | Awesome Copilot<i class="fas fa-external-link-alt"></i></a>
</font>
</div>
]]></content>
      <tags>
        <tag>GitHub Copilot</tag>
        <tag>VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Azure Pipelines Agents 代理程式</title>
    <url>/post/2025/06/update-azure-pipelines-agents/</url>
    <content><![CDATA[<img    
                       lazyload
                       alt="image"
                       data-src="/post/2025/06/update-azure-pipelines-agents/azure_pipelines_agents.png"
                         align="left" style="margin-right: 10px; width: 125px; border: 1px solid gray;"
                 > 
<p>Azure Pipelines Agents 是現代 DevOps 流程中不可或缺的基礎組件。隨著企業加速數位轉型，持續整合（CI）與持續交付（CD）成為團隊自動化建置、測試與部署的重要手段。Azure Pipelines 做為 Azure DevOps 的核心服務之一，透過代理程式（Agent）來執行各式自動化工作。無論是雲端託管或自我託管，代理程式皆負責與 Azure DevOps Server 或 Azure DevOps Services 溝通，協助團隊將程式碼快速且安全地部署至各種環境。近年來，隨著代理程式版本的演進，功能與安全性也大幅提升，特別是在 3.x 與 4.x 之間有諸多關鍵差異，本文將介紹 Azure Pipelines Agents 的基本概念、版本比較、更新方式與工作目錄結構。<br>
<br></p>
<span id="more"></span>
<br>
<h2 id="什麼是-Azure-Pipelines-Agents">什麼是 Azure Pipelines Agents</h2>
<p>Azure Pipelines Agents 代理程式是負責執行 Azure Pipelines 工作（如建置、測試、部署）的運算節點。當您在 Azure DevOps 中建立 CI/CD 流程時，實際負責操作指令、拉取程式碼、執行腳本與產生建置產物的，就是這些代理程式。</p>
<p><strong>代理程式類型：</strong></p>
<ul>
<li><strong>Microsoft-Hosted</strong>：由微軟提供與維護，適合雲端開發。</li>
<li><strong>Self-Hosted</strong>：由使用者自行安裝於 VM、實體機或容器，適合需要存取內部資源或自訂環境的需求。</li>
<li><strong>Managed DevOps Pool</strong>：Azure 提供的完全受控虛擬機或容器資源。</li>
<li><strong>Azure Virtual Machine Scale Sets</strong>：可自動擴展的自我託管代理程式，適合彈性需求。</li>
</ul>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/06/update-azure-pipelines-agents/agent-topologies-tfs.png"
                        class=""
                 >
<p>不論是使用 Azure DevOps Services 或是自建 Azure DevOps Server，代理程式都是使用 HTTPS(443) 來進行下載作業、回報狀態，並確保敏感資訊透過加密方式傳輸。</p>
<div class="tips">
<font color="black">
<a class="link"   href="https://learn.microsoft.com/zh-tw/azure/devops/managed-devops-pools/architecture-overview?view=azure-devops"  target="_blank">⁍ Microsoft受控 DevOps 集區架構概觀
<i class="fas fa-external-link-alt"></i></a><br>
<a class="link"   href="https://learn.microsoft.com/zh-tw/azure/virtual-machine-scale-sets/overview"  target="_blank">⁍ 什麼是虛擬機器擴展集<i class="fas fa-external-link-alt"></i></a><br>
<a class="link"   href="https://learn.microsoft.com/zh-tw/azure/devops/managed-devops-pools/migrate-from-scale-set-agents?view=azure-devops"  target="_blank">⁍ 比較管理的 DevOps 群組與 Azure 虛擴展集的代理<i class="fas fa-external-link-alt"></i></a>
</font>
</div>
<br>
<h2 id="Azure-Pipelines-2-x、3-x、4-x-版本差異比較">Azure Pipelines 2.x、3.x、4.x 版本差異比較</h2>
<p>根據官方文件，Azure Pipelines Agents 2.x、3.x 與 4.x 版本在底層平台、作業系統支援範圍、安全性、升級策略等多方面皆有顯著差異。以下整理三個版本的主要比較：</p>
<table>
<thead>
<tr>
<th style="text-align:left">項目</th>
<th style="text-align:left">2.x 代理程式</th>
<th style="text-align:left">3.x 代理程式</th>
<th style="text-align:left">4.x 代理程式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">核心平台</td>
<td style="text-align:left">.NET Core 3.1</td>
<td style="text-align:left">.NET 6</td>
<td style="text-align:left">.NET 8</td>
</tr>
<tr>
<td style="text-align:left">發行時間</td>
<td style="text-align:left">2021 年以前</td>
<td style="text-align:left">2023 年 3 月</td>
<td style="text-align:left">2024 年 10 月</td>
</tr>
<tr>
<td style="text-align:left">作業系統支援</td>
<td style="text-align:left">支援較舊的作業系統</td>
<td style="text-align:left">支援較新 OS，淘汰部分舊版</td>
<td style="text-align:left">僅支援最新 OS，淘汰更多舊版</td>
</tr>
<tr>
<td style="text-align:left">主要支援 OS</td>
<td style="text-align:left">Windows 7/8.1、舊版 Linux</td>
<td style="text-align:left">Windows 10/11、Ubuntu 18+</td>
<td style="text-align:left">Windows 10/11、Ubuntu 20+</td>
</tr>
<tr>
<td style="text-align:left">macOS 支援</td>
<td style="text-align:left">macOS 10.15 及以上</td>
<td style="text-align:left">macOS 10.15~14 (含 ARM64)</td>
<td style="text-align:left">macOS 13~15 (含 ARM64)</td>
</tr>
<tr>
<td style="text-align:left">Linux 支援</td>
<td style="text-align:left">舊版 Linux (Debian 10 等)</td>
<td style="text-align:left">Debian 10+、Ubuntu 16+</td>
<td style="text-align:left">Debian 12、Ubuntu 20+</td>
</tr>
<tr>
<td style="text-align:left">安全性維護</td>
<td style="text-align:left">僅針對重大問題個案處理</td>
<td style="text-align:left">僅針對 3.x 修補</td>
<td style="text-align:left">僅針對 4.x 修補</td>
</tr>
<tr>
<td style="text-align:left">依賴平台</td>
<td style="text-align:left">需安裝 .NET Core 3.1</td>
<td style="text-align:left">.NET 6 已內建於代理程式中</td>
<td style="text-align:left">.NET 8 已內建於代理程式中</td>
</tr>
</tbody>
</table>
<h3 id="升級與相容性注意事項">升級與相容性注意事項</h3>
<p>2.x、3.x、4.x 代理程式的主要差異在於底層 .NET 平台、支援的作業系統範圍、相容性與維護策略，若代理程式執行於不支援的作業系統，將無法升級至新版，且執行管線時會出現錯誤提示，需先升級作業系統才能繼續。每一代代理程式僅針對自身版本進行安全性修補，建議維運團隊定期檢查代理程式與作業系統版本，確保 DevOps 流程穩定且安全。</p>
<div class="tips">
<font color="black">
<a class="link"   href="https://learn.microsoft.com/zh-tw/azure/devops/pipelines/agents/agents?view=azure-devops-2022&tabs=yaml%2Cbrowser#can-i-update-my-agents-that-are-part-of-an-azure-devops-server-pool"  target="_blank">⁍ Azure Pipelines 代理程式<i class="fas fa-external-link-alt"></i></a><br>
<a class="link"   href="https://learn.microsoft.com/zh-tw/azure/devops/pipelines/agents/v3-agent?view=azure-devops"  target="_blank">⁍ 代理程式軟體第 3 版<i class="fas fa-external-link-alt"></i></a><br>
<a class="link"   href="https://learn.microsoft.com/zh-tw/azure/devops/pipelines/agents/v4-agent?view=azure-devops#upgrade-to-4x-agent-on-supported-operating-systems"  target="_blank">⁍ 代理程式軟體第 4 版<i class="fas fa-external-link-alt"></i></a>
</font>
</div>
<br>
<h2 id="Azure-DevOps-Server-更新代理程式來源方式">Azure DevOps Server 更新代理程式來源方式</h2>
<p>若您在地端環境 Azure DevOps Server 中管理 Self-Hosted Agent，除了透過網路自動更新外，也可以手動指定代理程式的安裝來源。只需將新版代理程式的壓縮檔（.zip）放置於伺服器的 <strong><code>%ProgramData%\Microsoft\Azure DevOps\Agents</code></strong> 目錄內，代理程式便會自動從該路徑取得更新檔案（如下圖 4.258.1）；若將目錄中的檔案清空，則會顯示目前 Azure DevOps Server 預設的下載版本，例如：Azure DevOps Server 2022.2 預設版本是 3.240.0。</p>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/06/update-azure-pipelines-agents/agents_folder.png"
                        class=""
                 >
<br>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/06/update-azure-pipelines-agents/get_the_agent.png"
                        class=""
                 >
<blockquote>
<p>若要更新 Azure DevOps Server 的代理程式，請將新版本壓縮檔放到 <mark><strong>%ProgramData%\Microsoft\Azure DevOps\Agents</strong></mark> 資料夾，代理程式會自動偵測並完成更新</p>
</blockquote>
<p>關於 Azure Pipelines Agent 發行過的所有版本都可以在 GitHub 的 Release 紀錄中找到，可以參考下列連結。</p>
<div class="tips">
<font color="black">
<a class="link"   href="https://github.com/microsoft/azure-pipelines-agent/releases"  target="_blank">⁍ GitHub | Azure Pipelines Agent 🚀<i class="fas fa-external-link-alt"></i></a>
</font>
</div>
<br>
<h2 id="Azure-Pipelines-Agents-工作目錄結構">Azure Pipelines Agents 工作目錄結構</h2>
<p>代理程式在執行 pipeline 作業時，會建立一套標準化的目錄結構，用於儲存原始碼、建置產物、測試結果等資料。以下為主要目錄說明：</p>
<table>
<thead>
<tr>
<th style="text-align:left">目錄名稱</th>
<th style="text-align:left">說明</th>
<th style="text-align:left">範例（Windows）</th>
<th style="text-align:left">預設變數</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">代理主目錄</td>
<td style="text-align:left">代理程式安裝位置</td>
<td style="text-align:left"><strong><mark>C:\agent</mark></strong></td>
<td style="text-align:left">Agent.HomeDirectory</td>
</tr>
<tr>
<td style="text-align:left">工作目錄</td>
<td style="text-align:left">儲存原始碼、建置產物、專案等</td>
<td style="text-align:left">C:\agent\ <strong><mark>_work</mark></strong></td>
<td style="text-align:left">Agent.WorkFolder</td>
</tr>
<tr>
<td style="text-align:left">建置目錄/工作區</td>
<td style="text-align:left">管線作業執行位置</td>
<td style="text-align:left">C:\agent_work\ <strong><mark>1</mark></strong></td>
<td style="text-align:left">Agent.BuildDirectory</td>
</tr>
<tr>
<td style="text-align:left">s 目錄</td>
<td style="text-align:left">檢出後的原始碼目錄</td>
<td style="text-align:left">C:\agent_work\1\ <strong><mark>s</mark></strong></td>
<td style="text-align:left">Build.SourcesDirectory</td>
</tr>
<tr>
<td style="text-align:left">b 目錄</td>
<td style="text-align:left">建置產物目錄</td>
<td style="text-align:left">C:\agent_work\1\ <strong><mark>b</mark></strong></td>
<td style="text-align:left">Build.BinariesDirectory</td>
</tr>
<tr>
<td style="text-align:left">a 目錄</td>
<td style="text-align:left">工件暫存目錄</td>
<td style="text-align:left">C:\agent_work\1\ <strong><mark>a</mark></strong></td>
<td style="text-align:left">Build.StagingDirectory</td>
</tr>
<tr>
<td style="text-align:left">TestResults</td>
<td style="text-align:left">測試結果目錄</td>
<td style="text-align:left">C:\agent_work\1\ <strong><mark>TestResults</mark></strong></td>
<td style="text-align:left">Common.TestResultsDirectory</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>代理主目錄</strong>：安裝代理程式的根目錄。</li>
<li><strong>工作目錄</strong>：所有作業的儲存空間，會依每次執行建立子目錄。</li>
<li><strong>建置/工作區目錄</strong>：每次 pipeline 執行時的專屬目錄。</li>
<li><strong>s/b/a/TestResults</strong>：分別對應原始碼、建置產物、工件暫存與測試結果。</li>
</ul>
<p>在 Self-Hosted 執行環境，這些目錄會在每次執行間保留，僅暫存與測試結果目錄會自動清理；若為 Microsoft-Hosted 則每次皆為全新環境，瞭解各目錄的用途與預設變數名稱對於後續的 pipeline 撰寫有很大的助益，在 Azure Pipelines 中預先定義的變數可以參考下列連結。</p>
<div class="tips">
<font color="black">
<a class="link"   href="https://learn.microsoft.com/zh-tw/azure/devops/pipelines/build/variables?view=azure-devops&tabs=yaml"  target="_blank">⁍ 使用預先定義的變數<i class="fas fa-external-link-alt"></i></a>
</font>
</div>
<br>
<h2 id="結語">結語</h2>
<p>Azure Pipelines Agents 是實現現代 DevOps 流程的關鍵，無論是雲端或地端部署，選擇合適的代理程式版本與管理方式，能大幅提升自動化流程的安全性與效率，維運團隊可以持續關注代理程式版本更新，並善用官方提供的更新機制，打造穩健且高效的 CI/CD 環境。</p>
<h2 id="後續更新">後續更新</h2>
<p>今天剛好有客戶詢問如何更新 Azure Pipelines Agent 版本，實務上如前文所述，只需先從 GitHub 下載所需的代理程式版本，放到 Azure DevOps Server 指定的資料夾，接著在 Web 介面點選 <strong><code>Update all agents</code></strong> 按鈕，即可批次更新指定 pool 內所有狀態為 Online 的 Agent。整個更新過程無需停機，Agent 會自動收到更新指令、下載並安裝新版本，完成後會自動重啟服務（大約僅離線 10 秒），即可輕鬆完成批次更新作業。</p>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/06/update-azure-pipelines-agents/update_agent.png"
                        class=""
                 >]]></content>
      <tags>
        <tag>Azure DevOps</tag>
        <tag>Azure Pipelines Agents</tag>
      </tags>
  </entry>
  <entry>
    <title>程式部署的最佳幫手 - 使用 WinRM 建立 PSSession</title>
    <url>/post/2025/12/winrm-pssession/</url>
    <content><![CDATA[<img    
                       lazyload
                       alt="image"
                       data-src="/post/2025/12/winrm-pssession/winrm-pssession.jpg"
                         align="left" style="margin-right: 10px; width: 125px; border: 1px solid gray;"
                 > 
<p>在 Windows 世界裡，只要談到「遠端執行 PowerShell 指令」或是「從 CI/CD Pipeline 自動把程式丟到伺服器」，幾乎都會遇到兩個名詞：<strong>WinRM</strong> 跟 <strong>PSSession</strong>。這兩個其實不是競爭關係，而是分層合作：WinRM 負責提供底層遠端通訊通道，PSSession 則是在這個通道上建立起來的 PowerShell 遠端工作階段。本篇先說明兩者的概念與關係，再示範如何在 Azure Pipelines 的 CD 階段，透過 WinRM/PSSession 把 .NET 10 應用程式的部署包複製到目標主機。</p>
<span id="more"></span>
<br>
<br>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/12/winrm-pssession/process.jpg"
                        class=""
                 >
<br>
<h2 id="什麼是-WinRM？">什麼是 WinRM？</h2>
<p><strong>WinRM (Windows Remote Management)</strong> 是微軟實作的遠端管理服務，它是基於 <strong>WS-Management 協定</strong>（走 HTTP/HTTPS + SOAP）的一層管理通道。啟用 WinRM 之後，目標主機會在預設的連接埠上等待遠端要求：</p>
<ul>
<li>HTTP：TCP 5985</li>
<li>HTTPS：TCP 5986</li>
</ul>
<p>WinRM 的角色可以想像成「遠端管理郵局」：</p>
<ol>
<li>Client 把要執行的遠端指令封裝成 SOAP 訊息，送到 WinRM Listener。</li>
<li>WinRM 收到訊息後，根據 Endpoint 設定，啟動對應的提供者 (Provider)。</li>
<li>對 PowerShell 而言，WinRM 會啟動像 <strong><code>wsmprovhost.exe</code></strong> 這類的處理程序，負責實際執行 PowerShell 指令。</li>
</ol>
<p>也因為 WinRM 是通用的管理通道，所以除了 PowerShell 之外，其他管理應用程式也可以透過 WinRM 來接收與處理遠端要求。</p>
<h2 id="什麼是-PSSession？">什麼是 PSSession？</h2>
<p><strong>PSSession</strong> 則是 PowerShell 提供的「遠端工作階段物件」，你可以把它想成是在遠端主機上開了一個持續存在的 PowerShell 視窗，只是畫面沒有顯示在你前面而已。</p>
<p>幾個常見的 cmdlet：</p>
<ul>
<li><strong><code>New-PSSession</code></strong>：建立遠端工作階段物件。</li>
<li><strong><code>Enter-PSSession</code></strong>：進入互動式遠端 Shell。</li>
<li><strong><code>Invoke-Command -Session</code></strong>：在既有的 PSSession 裡執行指令或 ScriptBlock。</li>
<li><strong><code>Remove-PSSession</code></strong>：關閉遠端工作階段，釋放資源。</li>
</ul>
<p>使用 PSSession 的好處：</p>
<ul>
<li>同一個 Session 中可以連續執行多個指令，重複利用連線與驗證結果。</li>
<li>可以在 Session 內保留變數、已載入的模組、目前路徑等狀態。</li>
<li>在大量部署或需要多次互動的情境下，效率會比一次性的 <strong><code>Invoke-Command -ComputerName</code></strong> 好很多。</li>
</ul>
<h2 id="WinRM-與-PSSession-之間的關係">WinRM 與 PSSession 之間的關係</h2>
<p>在典型的 Windows 環境中，<strong>PowerShell Remoting 預設是透過 WinRM 當作傳輸層</strong> 來建立 PSSession，也就是說：</p>
<ul>
<li>WinRM：負責「如何把封包從 Client 送到 Server」。</li>
<li>PSSession：負責「在 Server 上開一個 PowerShell 遠端工作階段」。</li>
</ul>
<p>所以大家可以這麼理解：</p>
<blockquote>
<p>WinRM 提供管道，PSSession 就是在這條管道上跑 PowerShell 的列車。</p>
</blockquote>
<p>如果 WinRM 沒有啟用或設定有問題（例如：防火牆沒開、Listener 沒建立、憑證或 TrustedHosts 沒設好），那 <strong><code>New-PSSession</code></strong> 或 <strong><code>Enter-PSSession</code></strong> 這類指令就會直接報錯，常見錯誤訊息像是：「<strong>WinRM 用戶端無法處理該要求</strong>」。</p>
<p>從協定層次來看，WinRM 是一個通用的遠端管理協定，而 PowerShell Remoting（包含 PSSession）只是跑在其上的其中一種應用層實作。在較新的 PowerShell 版本中，也可以改用 SSH 當作傳輸層，不過在多數 Windows AD 企業環境裡，WinRM 仍然是最常見、整合度也最高的選項。</p>
<h2 id="WinRM-PSSession-架構概念">WinRM / PSSession 架構概念</h2>
<p>從 Client 發出一個遠端 PowerShell 指令，到 Server 端執行完成，中間大致會經過這幾個步驟：</p>
<ol>
<li>使用者在 Client 上執行 <strong><code>New-PSSession</code></strong> 或 <strong><code>Enter-PSSession</code></strong>。</li>
<li>PowerShell 呼叫 WinRM Client，將 ScriptBlock / 指令內容包成 SOAP 訊息。</li>
<li>SOAP 訊息透過 TCP 5985/5986 穿過防火牆，送到遠端主機上的 WinRM Listener。</li>
<li>WinRM Listener 驗證身分、檢查授權後，將要求派送給對應的 Endpoint（例如 PowerShell）。</li>
<li>PowerShell Provider 啟動處理程序（例如 <strong><code>wsmprovhost.exe</code></strong>），在遠端建立 / 維護 PSSession。</li>
<li>遠端 PowerShell 執行完指令後，把結果再透過同一條通道包成 SOAP 回傳給 Client。</li>
</ol>
<p>就像文章最上面的 WinRM 示意圖，可以把中間那個「Firewll + WS-Management 協定」想成一座橋，橋兩端分別是執行 PowerShell 的 Client 和 Server，WinRM 就是在橋上來回搬運 SOAP 訊息的工人，而 PSSession 則是工人幫你在對岸搭好的工作站。</p>
<h2 id="實作：在兩台電腦之間建立-PSSession">實作：在兩台電腦之間建立 PSSession</h2>
<p>以下假設情境：</p>
<ul>
<li>Client：本地開發環境 / Build Agent，一般使用者帳號 <code>DOMAIN\deployuser</code>。</li>
<li>Server：IIS Web Server，主機名稱 <code>WEB01</code>。</li>
<li>兩台機器在同一個 AD 網域，網路上互通，防火牆允許 5985（或 5986）。</li>
</ul>
<h3 id="1-在-Server-上啟用與設定-WinRM">1. 在 Server 上啟用與設定 WinRM</h3>
<p>在 Server（WEB01）以系統管理員身分開啟 PowerShell，先確認 WinRM 服務與 PowerShell Remoting：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 啟用 WinRM 基本設定（服務、Listener、防火牆）</span></span><br><span class="line">winrm quickconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 啟用 PowerShell Remoting（會幫你建立預設 WinRM Endpoint）</span></span><br><span class="line"><span class="built_in">Enable-PSRemoting</span> <span class="literal">-Force</span></span><br></pre></td></tr></table></figure>
<p>如果是第一次執行 <code>winrm quickconfig</code>，系統會詢問是否：</p>
<ul>
<li>啟用 WinRM 服務並設為自動啟動。</li>
<li>建立預設 Listener。</li>
<li>開啟對應的防火牆規則。</li>
</ul>
<p>依照提示輸入 <code>Y</code> 即可完成基本設定。接著可以用下列指令確認目前的 Listener 狀態：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">winrm e winrm/config/listener</span><br></pre></td></tr></table></figure>
<p>在一般 AD 網域環境，使用 HTTP + Kerberos 驗證就足夠；如果需要跨網段、跨網域或是走 HTTPS，可以再另外建立 HTTPS Listener 並匯入憑證。</p>
<h4 id="常見錯誤：Public-網路導致-Enable-PSRemoting-失敗">常見錯誤：Public 網路導致 Enable-PSRemoting 失敗</h4>
<br>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/12/winrm-pssession/error.jpg"
                        class=""
                 >
<br>
<p>有時候在執行 <code>Enable-PSRemoting -Force</code> 會看到類似下列錯誤訊息：</p>
<blockquote>
<p>WinRM 防火牆例外無法啟用，因為此機器上的某個網路連線其網路類型是 Public，請先改成 Domain 或 Private 再重試。</p>
</blockquote>
<p>這是因為 <code>Enable-PSRemoting</code> 內部會呼叫 <code>Set-WSManQuickConfig</code>，預設只會在 <strong>Domain / Private 網路</strong> 上自動開啟 WinRM 的防火牆規則；只要偵測到有任何一張網卡被標成 Public，就會視為不安全環境而中止。常見情境包括：</p>
<ul>
<li>除了實體網卡之外，還有 Wi‑Fi、VPN、虛擬機器 vSwitch 等虛擬介面。</li>
<li>其中至少一個連線的 NetworkCategory 是 Public。</li>
</ul>
<p>這時可以依照情況選擇下面兩種處理方式：</p>
<p><strong>方式一：把 Public 改成 Private / Domain（建議）</strong></p>
<ol>
<li>
<p>先列出目前所有連線的網路類型：</p>
 <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Get-NetConnectionProfile</span></span><br></pre></td></tr></table></figure>
<p>找出 <code>NetworkCategory</code> 為 <code>Public</code> 的介面（通常會看到 InterfaceIndex）。</p>
</li>
</ol>
<br>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/12/winrm-pssession/step1.jpg"
                        class=""
                 >
<br>
<ol start="2">
<li>
<p>將需要啟用 WinRM 的那個連線改成 Private：</p>
 <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set-NetConnectionProfile</span> <span class="literal">-InterfaceIndex</span> &lt;InterfaceIndex的值&gt; <span class="literal">-NetworkCategory</span> Private</span><br></pre></td></tr></table></figure>
<p>或者在「設定 → 網路和網際網路 → 以太網路 / Wi‑Fi → 該連線 → 網路設定檔」中，手動改為「私人」。</p>
</li>
</ol>
<br>
<img  
                       lazyload
                       alt="image"
                       data-src="/post/2025/12/winrm-pssession/step2.jpg"
                        class=""
                 >
<br>
<ol start="3">
<li>
<p>調整完成後再重新執行：</p>
 <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Enable-PSRemoting</span> <span class="literal">-Force</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>方式二：略過網路類型檢查（風險較高）</strong></p>
<p>若確認目前環境是受控網路，暫時無法改變連線類型，也可以選擇直接略過這個檢查：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Enable-PSRemoting</span> <span class="literal">-SkipNetworkProfileCheck</span> <span class="literal">-Force</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或使用底層指令</span></span><br><span class="line"><span class="built_in">Set-WSManQuickConfig</span> <span class="literal">-SkipNetworkProfileCheck</span> <span class="literal">-Force</span></span><br></pre></td></tr></table></figure>
<p>這樣會在目前的網路設定下直接啟用 WinRM，之後建議再搭配防火牆規則，限制允許存取 WinRM 的來源 IP 或子網，以降低暴露風險。特別是在 Notebook / 多網卡環境，更要注意不要對公共網路無限制開放。</p>
<h3 id="2-在-Client-端啟用與設定-WinRM">2. 在 Client 端啟用與設定 WinRM</h3>
<p>多數新版 Windows 在當作「Client 端」時，其實不需要太多額外設定，只要能透過網路連到 Server 的 5985/5986 連接埠即可。不過在某些情境下（例如：Workgroup、跨信任網域），你會需要多做幾件事：</p>
<ol>
<li>
<p>確認 WinRM 服務狀態：</p>
 <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Get-Service</span> winrm</span><br></pre></td></tr></table></figure>
<p>若狀態不是 Running，可以用：</p>
 <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set-Service</span> winrm <span class="literal">-StartupType</span> Automatic</span><br><span class="line"><span class="built_in">Start-Service</span> winrm</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果 Client 與 Server 不在同一個 AD 網域，或是 Workgroup 環境，就要在 Client 上把 Server 加到 TrustedHosts，允許連線：</p>
 <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 將單一主機加入 TrustedHosts</span></span><br><span class="line"><span class="built_in">Set-Item</span> WSMan:\localhost\Client\TrustedHosts <span class="literal">-Value</span> <span class="string">&#x27;WEB01&#x27;</span> <span class="literal">-Force</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果有多台，可以用逗號分隔</span></span><br><span class="line"><span class="built_in">Set-Item</span> WSMan:\localhost\Client\TrustedHosts <span class="literal">-Value</span> <span class="string">&#x27;WEB01,WEB02&#x27;</span> <span class="literal">-Force</span></span><br></pre></td></tr></table></figure>
<p>也可以用 <code>*</code> 允許所有主機，但風險較高，通常建議只在測試環境使用。</p>
</li>
<li>
<p>最後用下列指令檢查目前的 Client 端設定：</p>
 <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">winrm get winrm/config/client</span><br></pre></td></tr></table></figure>
<p>確認 <code>TrustedHosts</code> 是否包含目標主機名稱，以及是否有符合安全政策的驗證方式（例如：只啟用 Kerberos，不開 Basic + AllowUnencrypted）。</p>
</li>
</ol>
<h3 id="3-測試從-Client-建立-PSSession">3. 測試從 Client 建立 PSSession</h3>
<p>在 Client 端 PowerShell，先用目前登入帳號嘗試連線：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$session</span> = <span class="built_in">New-PSSession</span> <span class="literal">-ComputerName</span> WEB01</span><br><span class="line"><span class="built_in">Invoke-Command</span> <span class="literal">-Session</span> <span class="variable">$session</span> <span class="literal">-ScriptBlock</span> &#123; <span class="string">&quot;Hello from <span class="variable">$env:COMPUTERNAME</span>&quot;</span> &#125;</span><br><span class="line"><span class="built_in">Remove-PSSession</span> <span class="variable">$session</span></span><br></pre></td></tr></table></figure>
<p>如果一切順利，畫面上會印出來自 WEB01 的訊息，代表 WinRM 與 PSSession 都已經可以正常使用。</p>
<p>若需要指定其他認證，可以這樣寫：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$cred</span>    = <span class="built_in">Get-Credential</span> <span class="literal">-UserName</span> <span class="string">&#x27;DOMAIN\\deployuser&#x27;</span> <span class="literal">-Message</span> <span class="string">&#x27;輸入部署帳號密碼&#x27;</span></span><br><span class="line"><span class="variable">$session</span> = <span class="built_in">New-PSSession</span> <span class="literal">-ComputerName</span> WEB01 <span class="literal">-Credential</span> <span class="variable">$cred</span></span><br></pre></td></tr></table></figure>
<p>在非網域環境、或需跨信任邊界連線時，還會用到 TrustedHosts、HTTPS Listener 等額外設定，這部分可以再參考 WinRM 相關文章的進階設定說明。</p>
<h2 id="Azure-Pipelines-CD-範例：用-PSSession-複製-drop-zip-到-IIS-Web-Server">Azure Pipelines CD 範例：用 PSSession 複製 drop.zip 到 IIS Web Server</h2>
<p>前面都在講觀念，接下來用一個實際情境來說明：</p>
<blockquote>
<p>使用 Azure Pipelines CD，把 .NET 10 應用程式建置完成的 <code>drop.zip</code> 部署到 <code>WEB01</code> 伺服器的 <code>C:\inetpub\wwwroot</code> 目錄。</p>
</blockquote>
<h3 id="前置條件">前置條件</h3>
<ul>
<li>已經有一條 Build Pipeline，產出 <code>drop.zip</code> 並發佈成 Artifacts。</li>
<li>CD 使用的是 <strong>Self-hosted agent</strong>，且這台 Agent 機器可以透過 WinRM 連到 <code>WEB01</code>。</li>
<li>WEB01 已依前面步驟啟用並設定好 WinRM。</li>
</ul>
<h3 id="1-在-Release-CD-階段下載-Artifacts">1. 在 Release/CD 階段下載 Artifacts</h3>
<p>在 YAML Pipeline 的部署 Stage 中，先把 Build Artifacts 下載回 Agent：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">steps:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">task:</span> <span class="string">DownloadPipelineArtifact@2</span></span><br><span class="line">	<span class="attr">inputs:</span></span><br><span class="line">		<span class="attr">artifact:</span> <span class="string">drop</span></span><br><span class="line">		<span class="attr">path:</span> <span class="string">&#x27;$(Pipeline.Workspace)/drop&#x27;</span></span><br></pre></td></tr></table></figure>
<p>假設 <code>drop.zip</code> 會出現在 <code>$(Pipeline.Workspace)/drop/drop.zip</code>。</p>
<h3 id="2-使用-PowerShell-Task-建立-PSSession-並複製檔案">2. 使用 PowerShell Task 建立 PSSession 並複製檔案</h3>
<p>接著新增一個 PowerShell@2 工作，在裡面用 WinRM / PSSession 把 <code>drop.zip</code> 複製到 WEB01：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">task:</span> <span class="string">PowerShell@2</span></span><br><span class="line">	<span class="attr">displayName:</span> <span class="string">部署到</span> <span class="string">WEB01</span> <span class="string">(WinRM</span> <span class="string">+</span> <span class="string">PSSession)</span></span><br><span class="line">	<span class="attr">inputs:</span></span><br><span class="line">		<span class="attr">targetType:</span> <span class="string">&#x27;inline&#x27;</span></span><br><span class="line">		<span class="attr">pwsh:</span> <span class="literal">true</span></span><br><span class="line">		<span class="attr">script:</span> <span class="string">|</span></span><br><span class="line">			<span class="string">$serverName</span>   <span class="string">=</span> <span class="string">&#x27;WEB01&#x27;</span></span><br><span class="line">			<span class="string">$remotePath</span>   <span class="string">=</span> <span class="string">&#x27;C:\\inetpub\\wwwroot&#x27;</span></span><br><span class="line">			<span class="string">$localPackage</span> <span class="string">=</span> <span class="string">&#x27;$(Pipeline.Workspace)/drop/drop.zip&#x27;</span></span><br><span class="line"></span><br><span class="line">			<span class="comment"># 建構認證物件，密碼建議存放在 Variable / Variable group 或 Key Vault</span></span><br><span class="line">			<span class="string">$securePassword</span> <span class="string">=</span> <span class="string">ConvertTo-SecureString</span> <span class="string">&#x27;$(deployPassword)&#x27;</span> <span class="string">-AsPlainText</span> <span class="string">-Force</span></span><br><span class="line">			<span class="string">$cred</span> <span class="string">=</span> <span class="string">New-Object</span> <span class="string">System.Management.Automation.PSCredential(&#x27;DOMAIN\\deployuser&#x27;,</span> <span class="string">$securePassword)</span></span><br><span class="line"></span><br><span class="line">			<span class="string">Write-Host</span> <span class="string">&quot;[INFO] 建立到 $serverName 的 PSSession…&quot;</span></span><br><span class="line">			<span class="string">$session</span> <span class="string">=</span> <span class="string">New-PSSession</span> <span class="string">-ComputerName</span> <span class="string">$serverName</span> <span class="string">-Credential</span> <span class="string">$cred</span></span><br><span class="line"></span><br><span class="line">			<span class="string">try</span> &#123;</span><br><span class="line">				<span class="string">Write-Host</span> <span class="string">&quot;[INFO] 複製 drop.zip 到遠端 $remotePath…&quot;</span></span><br><span class="line">				<span class="string">Copy-Item</span> <span class="string">-Path</span> <span class="string">$localPackage</span> <span class="string">-Destination</span> <span class="string">$remotePath</span> <span class="string">-ToSession</span> <span class="string">$session</span> <span class="string">-Force</span></span><br><span class="line"></span><br><span class="line">				<span class="string">Write-Host</span> <span class="string">&quot;[INFO] 在遠端解壓縮並整理部署目錄…&quot;</span></span><br><span class="line">				<span class="string">Invoke-Command</span> <span class="string">-Session</span> <span class="string">$session</span> <span class="string">-ScriptBlock</span> &#123;</span><br><span class="line">					<span class="string">param($zipPath</span>, <span class="string">$siteRoot)</span></span><br><span class="line"></span><br><span class="line">					<span class="string">$expandPath</span> <span class="string">=</span> <span class="string">Join-Path</span> <span class="string">$siteRoot</span> <span class="string">&#x27;_deploy_tmp&#x27;</span></span><br><span class="line"></span><br><span class="line">					<span class="string">if</span> <span class="string">(Test-Path</span> <span class="string">$expandPath)</span> &#123; <span class="string">Remove-Item</span> <span class="string">$expandPath</span> <span class="string">-Recurse</span> <span class="string">-Force</span> &#125;</span><br><span class="line">					<span class="string">New-Item</span> <span class="string">-ItemType</span> <span class="string">Directory</span> <span class="string">-Path</span> <span class="string">$expandPath</span> <span class="string">|</span> <span class="string">Out-Null</span></span><br><span class="line"></span><br><span class="line">					<span class="string">Add-Type</span> <span class="string">-AssemblyName</span> <span class="string">System.IO.Compression.FileSystem</span></span><br><span class="line">					[<span class="string">System.IO.Compression.ZipFile</span>]<span class="string">::ExtractToDirectory($zipPath</span>, <span class="string">$expandPath)</span></span><br><span class="line"></span><br><span class="line">					<span class="comment"># 視專案需要，可以先備份舊站台內容</span></span><br><span class="line">					<span class="string">$backupPath</span> <span class="string">=</span> <span class="string">Join-Path</span> <span class="string">$siteRoot</span> <span class="string">(&quot;backup_&quot;</span> <span class="string">+</span> <span class="string">(Get-Date</span> <span class="string">-Format</span> <span class="string">&#x27;yyyyMMddHHmmss&#x27;</span><span class="string">))</span></span><br><span class="line">					<span class="string">if</span> <span class="string">(Test-Path</span> <span class="string">$siteRoot)</span> &#123;</span><br><span class="line">						<span class="string">New-Item</span> <span class="string">-ItemType</span> <span class="string">Directory</span> <span class="string">-Path</span> <span class="string">$backupPath</span> <span class="string">|</span> <span class="string">Out-Null</span></span><br><span class="line">						<span class="string">Get-ChildItem</span> <span class="string">$siteRoot</span> <span class="string">-Exclude</span> <span class="string">&#x27;backup_*&#x27;</span> <span class="string">|</span> <span class="string">Move-Item</span> <span class="string">-Destination</span> <span class="string">$backupPath</span></span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					<span class="string">Get-ChildItem</span> <span class="string">$expandPath</span> <span class="string">|</span> <span class="string">Move-Item</span> <span class="string">-Destination</span> <span class="string">$siteRoot</span></span><br><span class="line">					<span class="string">Remove-Item</span> <span class="string">$expandPath</span> <span class="string">-Recurse</span> <span class="string">-Force</span></span><br><span class="line">				&#125; <span class="string">-ArgumentList</span> <span class="string">&quot;$(Join-Path &#x27;C:\\inetpub\\wwwroot&#x27; &#x27;drop.zip&#x27;)&quot;</span>, <span class="string">&#x27;C:\\inetpub\\wwwroot&#x27;</span></span><br><span class="line"></span><br><span class="line">				<span class="string">Write-Host</span> <span class="string">&quot;[INFO] 部署完成。&quot;</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="string">finally</span> &#123;</span><br><span class="line">				<span class="string">if</span> <span class="string">($session)</span> &#123; <span class="string">Remove-PSSession</span> <span class="string">$session</span> &#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面示範的流程概要是：</p>
<ol>
<li>在 Agent 上下載 <strong><code>drop.zip</code></strong>。</li>
<li>透過 <strong><code>New-PSSession</code></strong> 連線到 WEB01。</li>
<li>使用 <strong><code>Copy-Item -ToSession</code></strong> 把 <strong><code>drop.zip</code></strong> 複製到 <strong><code>C:\inetpub\wwwroot</code></strong>。</li>
<li>在遠端透過 <strong><code>Invoke-Command -Session</code></strong> 解壓縮 zip、備份舊版網站、覆蓋成新版內容。</li>
<li>最後關閉 PSSession，釋放資源。</li>
</ol>
<p>實務上建議再搭配：</p>
<ul>
<li>把部署帳號與密碼改存放在 <strong>Secret Variable / Variable Group / Key Vault</strong>，避免出現在 YAML 明文。</li>
<li>加上更多錯誤處理與 Log，方便日後在 Pipeline 失敗時快速排查。</li>
<li>若需要同時部署到多台 Web Server，可以使用多個 PSSession，搭配 <strong><code>Invoke-Command -Session</code></strong> 的陣列呼叫方式一次下達指令。</li>
</ul>
<h2 id="小結">小結</h2>
<p>如果把部署流程拆解，會發現 WinRM 和 PSSession 負責的其實就是最關鍵的那一段：</p>
<ul>
<li>WinRM：讓 Build/Release Agent 可以安全、可控地連到目標主機。</li>
<li>PSSession：讓我們在遠端主機上，像本機一樣連續執行多個 PowerShell 指令，完成檔案傳輸、解壓縮、備份與切換等工作。</li>
</ul>
<p>了解這兩層的角色之後，不只在 Azure Pipelines，未來不管是其他 CI/CD 工具，或單純寫一隻自動化部署 Script，都可以用同樣的概念把 WinRM + PSSession 當成程式部署的最佳幫手。</p>
]]></content>
      <tags>
        <tag>PowerShell</tag>
        <tag>WinRM</tag>
        <tag>PSSession</tag>
      </tags>
  </entry>
</search>
