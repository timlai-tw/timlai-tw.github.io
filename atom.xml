<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>漫步在雲端</title>
  
  <subtitle>Strolling Through the Clouds</subtitle>
  <link href="https://timlai.dev/atom.xml" rel="self"/>
  
  <link href="https://timlai.dev/"/>
  <updated>2025-10-28T14:34:03.441Z</updated>
  <id>https://timlai.dev/</id>
  
  <author>
    <name>Tim Lai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Devdays Asia 2025 簡報下載</title>
    <link href="https://timlai.dev/post/2025/10/devdays-asia-2025/"/>
    <id>https://timlai.dev/post/2025/10/devdays-asia-2025/</id>
    <published>2025-10-28T13:04:05.000Z</published>
    <updated>2025-10-28T14:34:03.441Z</updated>
    
    <content type="html"><![CDATA[<img                           lazyload                       alt="image"                       data-src="/post/2025/10/devdays-asia-2025/DevdaysAsia2025.jpg"                         align="left" style="margin-right: 10px; width: 125px; border: 1px solid gray;"                 > <p>今年是微軟 50 週年、DevDays 10 週年，話題大多圍繞在 Agentic AI，考量多數企業還是有 On-Premises 需求，所以這次我將主題訂在如何使用 Azure DevOps + GitHub Copilot 重新打造 SDLC，讓大家瞭解不是雲原生環境還可以有哪些應用，以及賦與 LLM 更多 Tools 後，可以讓我們的軟體開發過程產生多大的助益和改變，雖然主題是 Azure DevOps 與 GitHub Copilot，但基本上套在任何軟體開發流程概念都是一樣的，提供給大家參考，有任何想討論交流也歡迎大家留言或直接與我聯繫。</p><span id="more"></span><br><div class="tips"><font color="black"><a href="/post/2025/10/devdays-asia-2025/0925_Track A 1330-1400_DevDaysAsia_20250925_精誠軟體.pdf" target="_blank">⁍ Azure DevOps 與 GitHub Copilot：AI 驅動的團隊協作新時代</a><br><a class="link"   href="https://www.digitimes.com.tw/Seminar/DevDaysAsia2025/index.html"  target="_blank">⁍ DevDays Asia 2025 亞太技術年會 | 議程介紹<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://onedrive.live.com/?redeem=aHR0cHM6Ly8xZHJ2Lm1zL2YvYy85NmJjZGNhMWVkYWIwZmMyL0VvUncyR1ZIaVRaUG1NNW1Ib0hPeWxFQlpvSW5aOU55ckY1QVJsOU5wbGpYWXc_ZT01VlhkMXQ&id=96BCDCA1EDAB0FC2%21s65d8708489474f3698ce661e81ceca51&cid=96BCDCA1EDAB0FC2"  target="_blank">⁍ DevDays Asia 2025 亞太技術年會 | 所有簡報下載 (OneDrive)<i class="fas fa-external-link-alt"></i></a><br></font></div>]]></content>
    
    
    <summary type="html">&lt;img    
                       lazyload
                       alt=&quot;image&quot;
                       data-src=&quot;/post/2025/10/devdays-asia-2025/DevdaysAsia2025.jpg&quot;
                         align=&quot;left&quot; style=&quot;margin-right: 10px; width: 125px; border: 1px solid gray;&quot;
                 &gt; 
&lt;p&gt;今年是微軟 50 週年、DevDays 10 週年，話題大多圍繞在 Agentic AI，考量多數企業還是有 On-Premises 需求，所以這次我將主題訂在如何使用 Azure DevOps + GitHub Copilot 重新打造 SDLC，讓大家瞭解不是雲原生環境還可以有哪些應用，以及賦與 LLM 更多 Tools 後，可以讓我們的軟體開發過程產生多大的助益和改變，雖然主題是 Azure DevOps 與 GitHub Copilot，但基本上套在任何軟體開發流程概念都是一樣的，提供給大家參考，有任何想討論交流也歡迎大家留言或直接與我聯繫。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Azure DevOps" scheme="https://timlai.dev/tags/Azure-DevOps/"/>
    
    <category term="Devdays Asia 2025" scheme="https://timlai.dev/tags/Devdays-Asia-2025/"/>
    
    <category term="GitHub Copilot" scheme="https://timlai.dev/tags/GitHub-Copilot/"/>
    
  </entry>
  
  <entry>
    <title>整理 context 的利器 — MarkItDown 與 Docling</title>
    <link href="https://timlai.dev/post/2025/10/docling-to-markdown/"/>
    <id>https://timlai.dev/post/2025/10/docling-to-markdown/</id>
    <published>2025-10-22T13:42:10.000Z</published>
    <updated>2025-10-24T13:08:47.839Z</updated>
    
    <content type="html"><![CDATA[<img                           lazyload                       alt="image"                       data-src="/post/2025/10/docling-to-markdown/logo.png"                         align="left" style="margin-right: 10px; width: 125px; border: 1px solid gray;"                 > <p>在 Agentic AI 的各式應用場景中，提供正確且良好品質的上下文來源是至關重要的環結，實務上我們可能透過 RAG 從外部檢索資料，或是從手邊的各種檔案格式轉換成 markdown 來提供 LLM 作為上下文參考資料以便展開執行後續的任務，若以輕量、快速上手為考量，可以試試 MarkItDown，但若只能在純地端環境執行，或是對於文件內容(例如：表格、版面)有更高的解析需求不妨試試 Docling，本文以實務角度比較兩者設計取向、支援格式與優缺點，以及提供不同應用場景的建議。</p><span id="more"></span><h2 id="為什麼要把文件「轉成-Markdown-結構化格式」？">為什麼要把文件「轉成 Markdown / 結構化格式」？</h2><p>在建立知識庫、資料前處理或把企業文件提供給 LLM 時，原始文件往往可能是 PDF、各種 Office 文件格式、圖片或音訊，而真正要給 LLM 使用時，需要：</p><ul><li>保留語意與結構（標題、段落、表格…等）。</li><li>去除雜訊並以 token 使用效率高的格式呈現（例如：Markdown）。</li><li>在有需要時，保留更結構化的表示（例如：JSON）以便後續自動化處理。</li></ul><p>MarkItDown 與 Docling 都致力於把各種來源轉成容易被 LLM 或檢索系統消化的輸出，但設計側重與功能集合有明顯差異，下面我們直接比較。</p><h2 id="MarkItDown">MarkItDown</h2><ul><li>出處：由 Microsoft AutoGen 團隊維護（Python）。</li><li>設計取向：把各式檔案轉成「結構化 Markdown」；以 LLM 與文本分析為取向。</li><li>優勢：<ul><li>直接產生適合 LLM 的 Markdown（標題、列表、表格、內嵌程式碼等）。</li><li>支援多媒體（圖片 OCR、音訊轉錄、YouTube 字幕抓取）。</li><li>可用作 MCP 伺服器，利於 AI Agent／LLM 整合。</li></ul></li><li>限制：<ul><li>對於複雜的 PDF 版面（精細表格、多欄佈局、複雜閱讀順序），解析深度稍嫌不足。</li><li>若要取得更高階 PDF 能力，可能會依賴 Azure Document Intelligence（雲端）。</li></ul></li></ul><p>若要使用 MarkItDown MCP 現在可以在 GitHub MCP Registry(https://github.com/mcp) 列表找到，也可以 docker 方式或 clone 整個專案在本地端以 STDIO 的方式執行，參考微軟官方 GitHub 說明。</p><div class="tips"><font color="black"><a class="link"   href="https://github.com/mcp"  target="_blank">⁍ GitHub MCP Registry<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://github.com/microsoft/markitdown?tab=readme-ov-file"  target="_blank">⁍ GitHub | MarkItDown<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://github.com/microsoft/markitdown/tree/main/packages/markitdown-mcp"  target="_blank">⁍ GitHub | MarkItDown MCP<i class="fas fa-external-link-alt"></i></a><br></font></div><h2 id="Docling">Docling</h2><ul><li>出處：由 Docling Project（原起始於 IBM Research Zurich，目前管於 LF AI &amp; Data）維護。</li><li>設計取向：專注於文件理解，特別是進階 PDF 解析（版面、閱讀順序、表格結構、公式、程式碼、影像分類），並提供統一的 DoclingDocument 表示與多種匯出選項。</li><li>優勢：<ul><li>在複雜 PDF（掃描文件、排版、多欄表格）與表格重構上表現優異，使用自家模型（DocLayNet、TableFormer）提升解析品質。</li><li>支援本地執行（適合敏感資料或隔離環境），也有 VLM / ASR 整合能力。</li><li>輸出豐富：Markdown / HTML / JSON / DocTags 等，便於後續分析或顯示詳細資訊。</li><li>與 LangChain、LlamaIndex、Haystack 等生態系可以直接整合，便於搭建 RAG pipeline。</li></ul></li><li>限制：<ul><li>因為功能較廣、選項較多，學習曲線會比 MarkItDown 高。</li><li>Docling 會完全在本地環境執行，需要考量相關系統資源 (是優點也是缺點)。</li></ul></li></ul><p>如何取得並建置 Docling 環境可以參考 GitHub 專案，它一樣有支援 MCP 但要在它的官網才找得到說明，如同前面說的，它是完全在本地端執行，所以 MCP 是由 uvx 來執行啟動。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;servers&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;docling&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;uvx&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;--from=docling-mcp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;docling-mcp-server&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><div class="tips"><font color="black"><a class="link"   href="https://github.com/docling-project/docling"  target="_blank">⁍ GitHub | Docling <i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://docling-project.github.io/docling/"  target="_blank">⁍ Docling<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://docling-project.github.io/docling/usage/mcp/"  target="_blank">⁍ Docling MCP<i class="fas fa-external-link-alt"></i></a><br></font></div><h2 id="支援格式與各面向比較">支援格式與各面向比較</h2><table><thead><tr><th>格式</th><th>MarkItDown</th><th>Docling</th><th>備註</th></tr></thead><tbody><tr><td>PDF</td><td>良好</td><td>優秀（尤其是複雜/掃描文件）</td><td>MarkItDown 對一般 PDF 處理良好；若需高保真解析或掃描 OCR 建議用 Docling</td></tr><tr><td>DOCX / PPTX / XLSX</td><td>支援</td><td>支援</td><td>兩者皆可處理 Office 文件</td></tr><tr><td>Images</td><td>OCR、EXIF 支援</td><td>OCR + VLM（視覺語言模型）分類支援</td><td>Docling 在影像分類與 VLM 整合上較強</td></tr><tr><td>Audio (WAV / MP3)</td><td>支援音訊轉錄</td><td>ASR 支援</td><td>兩者皆支援轉錄；可串接不同模型以改善品質</td></tr><tr><td>HTML</td><td>支援</td><td>支援</td><td>皆可匯入網頁內容</td></tr><tr><td>Markdown</td><td>原生支援</td><td>支援匯入/匯出</td><td></td></tr><tr><td>CSV / JSON / XML</td><td>文字格式支援</td><td>支援</td><td>適合結構化文字資料</td></tr><tr><td>YouTube</td><td>可抓取與轉錄</td><td>可處理 WebVTT / 影片字幕</td><td>MarkItDown 偏向抓取與轉錄；Docling 處理字幕檔更完整</td></tr><tr><td>EPUB / ZIP</td><td>支援</td><td>支援</td><td>支援程度依內容與封裝方式而異</td></tr><tr><td>VTT / WebVTT</td><td>支援</td><td>支援</td><td>若以字幕為主，Docling 支援度較好</td></tr></tbody></table><ul><li><p>設計目標：</p><ul><li>MarkItDown：以「快速把各類來源轉成 LLM-friendly Markdown」為核心，偏重 token 效率與多媒體前處理。</li><li>Docling：以「高保真文件理解」為核心，強調版面/表格/閱讀順序的精確還原與 lossless 結構化。</li></ul></li><li><p>解析深度與還原度：</p><ul><li>MarkItDown：輸出以可讀且可索引的 Markdown 為主，對一般文件足夠；遇到跨欄或複雜表格時可能會犧牲部分細節。</li><li>Docling：使用版面模型與表格重建，保留更多區塊座標與結構資訊，適合需精準抽取或重現原始排版的情境。</li></ul></li><li><p>多媒體支援：</p><ul><li>MarkItDown：支援音訊轉錄、YouTube 字幕抓取、圖片 OCR 等，偏向 LLM 前處理工作流。</li><li>Docling：也支援 OCR/ASR/VLM，但更強調影像分類、表格語意重構與公式/程式碼片段的解析。</li></ul></li><li><p>本地化 vs 雲端依賴：</p><ul><li>MarkItDown：可本地執行，但在某些高階 PDF 能力上會建議採用雲端 Azure Document Intelligence 作為選項。</li><li>Docling：設計上強調本地端運行，適合敏感資料或離線環境。</li></ul></li><li><p>效能與資源需求：</p><ul><li>MarkItDown：輕量、上手快，適合大量快速預處理。</li><li>Docling：依賴模型與較高運算資源，單檔處理時間較長但輸出更精確。</li></ul></li><li><p>整合生態與可擴充性：</p><ul><li>MarkItDown：以 plugin 與 MCP 為導向，容易接入 AI Agent / LLM pipeline。</li><li>Docling：提供豐富的 JSON / Markdown / HTML 匯出，與 LangChain、LlamaIndex 等檢索生態整合良好，利於深度資料工程。</li></ul></li><li><p>可驗證性與審核：</p><ul><li>MarkItDown：輸出簡潔，人工檢視方便，但在表格或版面細節需抽樣驗證。</li><li>Docling：提供中間結構（座標、區塊、表格邊界），便於自動化驗證與回溯修正。</li></ul></li><li><p>學習曲線與運維成本：</p><ul><li>MarkItDown：學習低、文件少、運維簡單。</li><li>Docling：功能與選項多，需時間調校模型與處理參數，運維成本較高。</li></ul><h2 id="總結">總結</h2><p>MarkItDown 與 Docling 均可將各類原始文件轉為 LLM 友好的結構化格式，但設計取向與適用場景不同：MarkItDown 輕量且易上手，輸出以節省 token 的 Markdown 為主，適合大量快速預處理與整合至 AI Agent / LLM pipeline；Docling 則強調高保真文件理解與版面還原，擅長複雜 PDF、表格重建及本地化運行，適用於需精準解析或資安敏感的情境。實務上如果是遇到比較複雜的文件內容，例如像論文有分左右兩欄、各式表格，或是有圖片需要 OCR 辨識、流程圖想要轉換成 Mermaid，使用 Docling 產出的結果都蠻不錯的，強力推薦給大家!</p><!-- 實務上建議依文件類型、解析精度、處理量與可用資源做選擇，並透過抽樣驗證或混合流程（以 MarkItDown 做批次預處理、以 Docling 處理關鍵或需人工驗證的檔案）來兼顧效率與精確性。 --></li></ul>]]></content>
    
    
    <summary type="html">&lt;img    
                       lazyload
                       alt=&quot;image&quot;
                       data-src=&quot;/post/2025/10/docling-to-markdown/logo.png&quot;
                         align=&quot;left&quot; style=&quot;margin-right: 10px; width: 125px; border: 1px solid gray;&quot;
                 &gt; 
&lt;p&gt;在 Agentic AI 的各式應用場景中，提供正確且良好品質的上下文來源是至關重要的環結，實務上我們可能透過 RAG 從外部檢索資料，或是從手邊的各種檔案格式轉換成 markdown 來提供 LLM 作為上下文參考資料以便展開執行後續的任務，若以輕量、快速上手為考量，可以試試 MarkItDown，但若只能在純地端環境執行，或是對於文件內容(例如：表格、版面)有更高的解析需求不妨試試 Docling，本文以實務角度比較兩者設計取向、支援格式與優缺點，以及提供不同應用場景的建議。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Docling" scheme="https://timlai.dev/tags/Docling/"/>
    
    <category term="MarkItDown" scheme="https://timlai.dev/tags/MarkItDown/"/>
    
    <category term="文件處理" scheme="https://timlai.dev/tags/%E6%96%87%E4%BB%B6%E8%99%95%E7%90%86/"/>
    
    <category term="RAG" scheme="https://timlai.dev/tags/RAG/"/>
    
  </entry>
  
  <entry>
    <title>Chrome DevTools MCP</title>
    <link href="https://timlai.dev/post/2025/10/chrome-devtools-mcp/"/>
    <id>https://timlai.dev/post/2025/10/chrome-devtools-mcp/</id>
    <published>2025-10-09T08:13:48.000Z</published>
    <updated>2025-10-10T13:30:14.748Z</updated>
    
    <content type="html"><![CDATA[<img                           lazyload                       alt="image"                       data-src="/post/2025/10/chrome-devtools-mcp/ChromeDevTools.jpg"                         align="left" style="margin-right: 10px; width: 125px; border: 1px solid gray;"                 > <p>無論是前端或後端開發工程師，相信大家都經常在瀏覽器中按下 <strong><code>F12</code></strong> 使用 Developer Tool。這個開發者工具不僅能檢視與調整頁面上的 HTML 元素，也能協助測試與偵錯前端 JavaScript。此外，還可以模擬各種裝置的瀏覽情境，或限制網路速度以模擬極端的使用狀況。這些功能都包含在 Chrome DevTools MCP 提供的工具清單中，本文將帶大家快速了解這些工具在實際開發場景中的應用方式。</p><span id="more"></span><br><h2 id="主要特色">主要特色</h2><p>透過 MCP 提供的多元服務串接，我們可以以自然語言對話的方式，為 LLMs 帶來更多應用可能。目前 Chrome DevTools MCP 主要涵蓋三大面向：<strong>自動化操作</strong>、<strong>效能洞察</strong>，以及<strong>瀏覽器操作與偵錯</strong>。不論是頁面上的 HTML 元素、操作過程的截圖，或是網路請求的詳細資訊，都能作為上下文 (Context) 的來源，協助我們運用 LLMs 執行各種任務。</p><p>環境需求：</p><ul><li>Node.js v20.19 以上</li><li>Chrome 瀏覽器</li><li>npm</li></ul><p>MCP 設定：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;mcpServers&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;chrome-devtools&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npx&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;-y&quot;</span><span class="punctuation">,</span> <span class="string">&quot;chrome-devtools-mcp@latest&quot;</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>Chrome DevTools MCP 目前分為 6 個類別，提供如下列 26 個工具：</p><h3 id="Input-automation">Input automation</h3><table><thead><tr><th style="text-align:left">工具名稱</th><th style="text-align:left">功能簡介</th></tr></thead><tbody><tr><td style="text-align:left">click</td><td style="text-align:left">點擊指定元素</td></tr><tr><td style="text-align:left">drag</td><td style="text-align:left">拖曳元素到指定位置</td></tr><tr><td style="text-align:left">fill</td><td style="text-align:left">填入欄位或選取項目</td></tr><tr><td style="text-align:left">fill_form</td><td style="text-align:left">批量填寫多個表單元素</td></tr><tr><td style="text-align:left">handle_dialog</td><td style="text-align:left">處理彈出對話框</td></tr><tr><td style="text-align:left">hover</td><td style="text-align:left">滑鼠懸停於元素上</td></tr><tr><td style="text-align:left">upload_file</td><td style="text-align:left">於檔案欄位上傳檔案</td></tr></tbody></table><p>使用 Input automation 可以讓我們操作鍵盤 (<strong><code>fill</code></strong> , <strong><code>fill_form</code></strong>)、滑鼠 (<strong><code>click</code></strong> , <strong><code>drag</code></strong> , <strong><code>hover</code></strong>) 在頁面上的各種行為，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">開啟 https://www.tenlong.com.tw/ 在 keyword 欄位輸入 &quot;ai agent&quot; 並送出 search 查詢動作。</span><br></pre></td></tr></table></figure><img                         lazyload                       alt="image"                       data-src="/post/2025/10/chrome-devtools-mcp/example01.jpg"                        class=""                 ><p>在上面截圖的執行過程可以看到 LLMs 理解我們所輸入的自然語言後，打開了 Chrome 瀏覽器自動使用了 <strong><code>fill</code></strong> 和 <strong><code>click</code></strong> 這兩個工作來達成任務，除此之外，因為 prompt 內容其實並沒有講得很清楚(沒有明確指定頁面元素ID)，所以它自己調用了 <strong><code>take_snapshot</code></strong> 截圖識別頁面內容來判斷下一步該如何進行，並回傳結果。</p><h3 id="Navigation-automation">Navigation automation</h3><table><thead><tr><th style="text-align:left">工具名稱</th><th style="text-align:left">功能簡介</th></tr></thead><tbody><tr><td style="text-align:left">close_page</td><td style="text-align:left">關閉分頁</td></tr><tr><td style="text-align:left">list_pages</td><td style="text-align:left">列出所有分頁</td></tr><tr><td style="text-align:left">navigate_page</td><td style="text-align:left">跳轉至指定網址</td></tr><tr><td style="text-align:left">navigate_page_history</td><td style="text-align:left">分頁歷史紀錄</td></tr><tr><td style="text-align:left">new_page</td><td style="text-align:left">開啟新分頁</td></tr><tr><td style="text-align:left">select_page</td><td style="text-align:left">設定操作目標分頁</td></tr><tr><td style="text-align:left">wait_for</td><td style="text-align:left">等待頁面出現指定文字</td></tr></tbody></table><p>透過 Navigation automation 可以協助我們管理操作多個分頁、控制分頁歷程以及在適當時機等待頁面內容出現，常見應用包括自動化測試流程、抓取需要登入或多頁互動的資料，以及在多分頁工作流程中切換操作目標。此類工具可讓 LLMs 以自然語言指令完成跨分頁的步驟：開啟新分頁、在目標分頁中等待特定文字出現、切換回原分頁或關閉不再需要的分頁，確保後續動作的執行，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.開啟 https://www.books.com.tw 並在 id 為 &quot;key&quot; 的文字方塊中輸入 &quot;ai agent&quot;，按下 title 為 &quot;搜尋&quot; 的按鈕。</span><br><span class="line">2.在新分頁開啟查詢列表第一筆的連結，回傳：書名、作者、出版日期、定價、優惠價。</span><br></pre></td></tr></table></figure><img                         lazyload                       alt="image"                       data-src="/post/2025/10/chrome-devtools-mcp/example02-1.jpg"                        class=""                 ><br><img                         lazyload                       alt="image"                       data-src="/post/2025/10/chrome-devtools-mcp/example02-2.jpg"                        class=""                 ><h3 id="Emulation">Emulation</h3><table><thead><tr><th style="text-align:left">工具名稱</th><th style="text-align:left">功能簡介</th></tr></thead><tbody><tr><td style="text-align:left">emulate_cpu</td><td style="text-align:left">模擬 CPU 效能/限速</td></tr><tr><td style="text-align:left">emulate_network</td><td style="text-align:left">模擬網路狀況</td></tr><tr><td style="text-align:left">resize_page</td><td style="text-align:left">調整頁面視窗尺寸</td></tr></tbody></table><p>我們在前端開發時常會需要模擬不同裝置(解析度)來確認版型是否正確顯示，以往我們會需要手動切換，甚至建一個新的裝置設定來配合測試，現在就可以用自然語言表達，並讓 LLMs 來幫我們 snapshot 截圖。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用 iPhone 13 Pro、iPad 6、FullHD 三種檢視方式打開 https://developer.chrome.com/blog/chrome-devtools-mcp?hl=zh-tw </span><br><span class="line">並截圖儲存在目前工作目錄中，檔名使用 yyyyMMdd-裝置名稱.jpg。</span><br></pre></td></tr></table></figure><img                         lazyload                       alt="image"                       data-src="/post/2025/10/chrome-devtools-mcp/example03.jpg"                        class=""                 ><h3 id="Performance">Performance</h3><table><thead><tr><th style="text-align:left">工具名稱</th><th style="text-align:left">功能簡介</th></tr></thead><tbody><tr><td style="text-align:left">performance_analyze_insight</td><td style="text-align:left">詳細分析效能洞見</td></tr><tr><td style="text-align:left">performance_start_trace</td><td style="text-align:left">開始頁面效能記錄</td></tr><tr><td style="text-align:left">performance_stop_trace</td><td style="text-align:left">停止頁面效能記錄</td></tr></tbody></table><p>上面有一個模擬網路狀況 <strong><code>emulate_network</code></strong> 在實務上也蠻常使用的，可以模擬在網路傳輸速度不佳或是特定的網路傳輸情境，以確認我們的頁面呈現或是功能互動會不會因為傳輸過久而造成什麼問題，再搭配 <strong><code>performance_start_trace</code></strong> 和 <strong><code>performance_stop_trace</code></strong> 就可以很輕易的就達成測試並記錄數值的需求。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">模擬以 &quot;Fast 4G&quot; 開啟 https://developer.chrome.com/blog/chrome-devtools-mcp?hl=zh-tw </span><br><span class="line">確認整頁載入需要花費多少時間，不需要設定 timeout 時間，直到整頁載入完成為止。</span><br></pre></td></tr></table></figure><img                         lazyload                       alt="image"                       data-src="/post/2025/10/chrome-devtools-mcp/example04_05.jpg"                        class=""                 ><h3 id="Network">Network</h3><table><thead><tr><th style="text-align:left">工具名稱</th><th style="text-align:left">功能簡介</th></tr></thead><tbody><tr><td style="text-align:left">get_network_request</td><td style="text-align:left">取得指定的請求資訊</td></tr><tr><td style="text-align:left">list_network_requests</td><td style="text-align:left">列出當前頁面網路請求</td></tr></tbody></table><p>程式開發人員工具中的 Network 可以看到頁面載入的所有資訊，在介面上也可以透過各種條件篩選或是排序來找到我們想要分析的目標，現在 Chrome DevTools MCP 也提供了對應的單筆、多筆查詢，應用上可以像是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">打開 https://www.momoshop.com.tw/ 分析頁面中哪一個項目的 response time 最久?</span><br><span class="line">整個頁面載入使用多少傳輸量、多少時間?</span><br></pre></td></tr></table></figure><img                         lazyload                       alt="image"                       data-src="/post/2025/10/chrome-devtools-mcp/example06.jpg"                        class=""                 ><h3 id="Debugging">Debugging</h3><table><thead><tr><th style="text-align:left">工具名稱</th><th style="text-align:left">功能簡介</th></tr></thead><tbody><tr><td style="text-align:left">evaluate_script</td><td style="text-align:left">執行 JavaScript 程式片段</td></tr><tr><td style="text-align:left">list_console_messages</td><td style="text-align:left">列出 console 訊息</td></tr><tr><td style="text-align:left">take_screenshot</td><td style="text-align:left">擷取頁面螢幕截圖</td></tr><tr><td style="text-align:left">take_snapshot</td><td style="text-align:left">取得當前頁面元素快照</td></tr></tbody></table><p>前面幾張執行過程截圖當中都有穿插呼叫 <strong><code>evaluate_script</code></strong>，它主要是注入 JavaScript 程式片段執行並讀取回傳結果，內容當然可以自己撰寫提供給 LLMs 呼叫，但比較多數的情況可能會是 LLMs 理解完我們所提供的上下文(Context)後，為了達到最終任務目的自己加上的。這裡有兩個名稱很像的 tool：</p><ul><li><strong><code>take_screenshot</code></strong>：就是把目前呈現的畫面內容截圖，可以儲存成 PNG、JPEG、WebP。</li><li><strong><code>take_snapshot</code></strong>：將目前畫面元素以記錄 uid 的方式將所有相關屬性記錄下來，這個適合用來作為上下文提供給 LLMs 使用，不適合人工閱讀。</li></ul><img                         lazyload                       alt="image"                       data-src="/post/2025/10/chrome-devtools-mcp/example07.jpg"                        class=""                 ><h2 id="總結">總結</h2><p>Chrome DevTools MCP 讓自然語言操控瀏覽器自動化、效能分析與偵錯成為可能，將原本需要撰寫程式或熟悉工具操作的流程，轉化為直覺、可被人類語句驅動的工作流程。透過 Input / Navigation / Emulation / Performance / Network / Debugging 等工具組合，LLMs 能理解任務意圖、自動擷取頁面上下文並執行相應操作，極大地降低了自動化門檻。<br><br>對一般使用者來說，要更容易達成自動化需求可以採取幾個實用做法：</p><ul><li>以明確且分步的自然語言描述任務，將複雜流程拆成小步驟（例如：導航 → 填表 → 等待 → 截圖）。</li><li>善用快照與截圖作為上下文回饋，讓 LLM 有更精準的操作依據。</li><li>建立常用 prompt 與範本（templates），將成功流程模組化、重複使用。</li><li>先從小範圍任務切入（如：自動化登入或資料擷取），驗證後再串接更複雜的操作或流程。</li><li>為關鍵步驟加入驗證與錯誤處理（檢查元素存在、逾時重試），確保穩定性與安全性。</li></ul><p><br>結合自然語言與 Chrome DevTools MCP，可以讓更多人不論工程背景與否，更快速地做到瀏覽器自動化與偵錯，提升開發效率並把重複性工作交給工具處理，讓團隊專注在更具價值的設計與判斷。<br><br></p><div class="tips"><font color="black"><a class="link"   href="https://developer.chrome.com/blog/chrome-devtools-mcp?hl=zh-tw"  target="_blank">⁍ AI 代理程式適用的 Chrome 開發人員工具 (MCP)<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://github.com/ChromeDevTools/chrome-devtools-mcp"  target="_blank">⁍ GitHub | ChromeDevTools MCP<i class="fas fa-external-link-alt"></i></a><br></font></div>]]></content>
    
    
    <summary type="html">&lt;img    
                       lazyload
                       alt=&quot;image&quot;
                       data-src=&quot;/post/2025/10/chrome-devtools-mcp/ChromeDevTools.jpg&quot;
                         align=&quot;left&quot; style=&quot;margin-right: 10px; width: 125px; border: 1px solid gray;&quot;
                 &gt; 
&lt;p&gt;無論是前端或後端開發工程師，相信大家都經常在瀏覽器中按下 &lt;strong&gt;&lt;code&gt;F12&lt;/code&gt;&lt;/strong&gt; 使用 Developer Tool。這個開發者工具不僅能檢視與調整頁面上的 HTML 元素，也能協助測試與偵錯前端 JavaScript。此外，還可以模擬各種裝置的瀏覽情境，或限制網路速度以模擬極端的使用狀況。這些功能都包含在 Chrome DevTools MCP 提供的工具清單中，本文將帶大家快速了解這些工具在實際開發場景中的應用方式。&lt;/p&gt;</summary>
    
    
    
    
    <category term="MCP" scheme="https://timlai.dev/tags/MCP/"/>
    
  </entry>
  
  <entry>
    <title>關於 MCP 的 Capability Negotiation</title>
    <link href="https://timlai.dev/post/2025/07/mcp-capability-negotiation/"/>
    <id>https://timlai.dev/post/2025/07/mcp-capability-negotiation/</id>
    <published>2025-07-05T03:40:09.000Z</published>
    <updated>2025-07-08T14:33:38.690Z</updated>
    
    <content type="html"><![CDATA[<img                           lazyload                       alt="image"                       data-src="/post/2025/07/mcp-capability-negotiation/robot.jpg"                         align="left" style="margin-right: 10px; width: 125px; border: 1px solid gray;"                 > <p>在當前 AI 技術快速發展的時代，MCP (Model Context Protocol) 為大型語言模型帶來更多元且強大的擴展能力。透過 MCP 讓開發者能使 IDE 工具與語言模型自然結合，實現語意驅動的互動體驗。MCP 架構中包含 MCP Server、MCP Host 與 MCP Client 三大核心角色，彼此協同合作並透過能力協商（Capability Negotiation）機制，確保雙方能根據自身能力與需求，協調出最佳的功能組合與協作方式。本文將以<a href="/post/2025/06/azure-devops-mcp-server/">上一篇文章</a>為例，說明其背景運作流程。</p><span id="more"></span><br><h2 id="Core-Components-核心組件">Core Components 核心組件</h2><p>MCP 採用 client-host-server 的架構設計，其中一個 host 可以同時管理多個 client instance，並與 MCP Server 建立一對一的連線，藉此維持安全邊界並隔離各自的關注點。以 VSCode 安裝 GitHub Copilot Extension 並連接 Azure DevOps MCP Server 為例，VSCode 扮演 host 角色，而 GitHub Copilot 則是 client，而 Azure DevOps MCP Server 則是 server。每個 client 透過 host 啟動並與 server 進行能力協商，確保各自的功能與需求能被正確識別與協調，進而實現安全且高效的協作。</p><p>正如 MCP 官方文件所示意的架構圖，我們可以在 VSCode 中透過 GitHub Copilot 與不同的模型進行互動。只要註冊並設定不同的 MCP Server，就能根據需求取得各式各樣的工具，進一步擴展大型語言模型的應用範圍與處理能力。目前要開發 MCP Server 的門檻已經大幅降低，在 Python / Node.js / Java / Kotlin / C# 都有很豐富的實作範例可以參考，可以參考下列整理連結。</p><img                         lazyload                       alt="image"                       data-src="/post/2025/07/mcp-capability-negotiation/core_components.png"                        class=""                 ><br><div class="tips"><font color="black"><a class="link"   href="https://modelcontextprotocol.io/quickstart/server"  target="_blank">⁍ Quickstart - For MCP Server Developers<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://github.com/modelcontextprotocol/csharp-sdk"  target="_blank">⁍ GitHub | csharp-sdk<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://learn.microsoft.com/zh-tw/dotnet/ai/get-started-mcp"  target="_blank">⁍ 開始使用 .NET AI 和模型內容通訊協定<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://learn.microsoft.com/zh-tw/dotnet/ai/quickstarts/build-mcp-server"  target="_blank">⁍ 使用 .NET 建立並連線到最小的 MCP 伺服器<i class="fas fa-external-link-alt"></i></a><br></font></div><h2 id="Capability-Negotiation-能力協商">Capability Negotiation 能力協商</h2><p>在 MCP 官方說明文件裡有一張關於 Capability Negotiation 的循序圖畫得很詳細，大家想要瞭解可以參考下方連結，這邊我就以上次的情境舉例：描述使用者透過 VSCode 及 GitHub Copilot 選擇使用 gpt-4o 模型，透過 Azure DevOps MCP Server 與 Azure DevOps Services 溝通，查詢組織專案列表的完整流程。大家可以先看一下循序圖中有哪些角色，再試著由上往下依序閱讀，完整說明在圖片下面。</p><div class="tips"><font color="black"><a class="link"   href="https://modelcontextprotocol.io/specification/2025-06-18/architecture#capability-negotiation"  target="_blank">⁍ MCP - Architecture | Capacity Negotiation<i class="fas fa-external-link-alt"></i></a><br></font></div><br><img                         lazyload                       alt="image"                       data-src="/post/2025/07/mcp-capability-negotiation/capability_negotiation.png"                        class=""                 ><h3 id="角色說明">角色說明</h3><ul><li>User（使用者）：在 VSCode 輸入查詢指令的人。</li><li>MCP Host（VSCode）：負責接收使用者指令，與其他元件溝通的 IDE 工具。</li><li>MCP Client（GitHub Copilot）：協助分析指令、整合工具，並與 AI 互動的中介。</li><li>gpt-4o：負責理解指令、產生工具操作建議與自然語言回應的 AI 模型。</li><li>Azure DevOps MCP Server：負責與 Azure DevOps 溝通的 MCP 伺服器。</li><li>Azure DevOps：實際儲存專案資料的雲端平台 (Azure DevOps Services)。</li></ul><h3 id="步驟流程說明">步驟流程說明</h3><h4 id="1-建立工具清單（首次連線時）">1. 建立工具清單（首次連線時）</h4><ul><li>MCP Client 會先建立一份工具清單（例如：有哪些查詢指令可用），並把這些資訊傳給 gpt-4o。</li><li>gpt-4o 準備好解析工具需求，回傳每個工具的詳細資料（名稱、參數、用途等）給 MCP Client。</li><li>MCP Client 把這些工具相關資料暫存下來，方便後續使用。</li></ul><h4 id="2-使用者輸入查詢">2. 使用者輸入查詢</h4><ul><li>User 在 VSCode 輸入像「組織有哪些專案？」這樣的問題。</li><li>MCP Host 把這個問題傳給 MCP Client。</li></ul><h4 id="3-問題分析與轉換">3. 問題分析與轉換</h4><ul><li>MCP Client 將指令及上下文資訊傳送給 gpt-4o。</li><li>gpt-4o 解析後發現需要查詢 Azure DevOps 的資料，於是產生對應的 MCP 指令（例如 list_projects）。</li></ul><h4 id="4-發送查詢請求">4. 發送查詢請求</h4><ul><li>MCP Client 把 list_projects 的請求發送給 MCP Host。</li><li>MCP Host 再把這個請求傳給 MCP Server。</li></ul><h4 id="5-與-Azure-DevOps-溝通">5. 與 Azure DevOps 溝通</h4><ul><li>MCP Server 收到請求後，轉換成 Azure DevOps 的 REST API 呼叫。</li><li>Azure DevOps 回傳專案列表資料給 MCP Server。</li></ul><h4 id="6-結果回傳與整合">6. 結果回傳與整合</h4><ul><li>MCP Server 將查詢結果回傳給 MCP Host。</li><li>MCP Host 把結果傳給 MCP Client。</li><li>MCP Client 整合資料，並將查詢結果及相關內容傳給 gpt-4o。</li></ul><h4 id="7-生成自然語言回應">7. 生成自然語言回應</h4><ul><li>gpt-4o 把查詢到的專案資料，轉換成自然語言答案。</li><li>MCP Client 將這個答案封裝好，傳回 MCP Host。</li><li>MCP Host 最後把結果顯示在 VSCode 介面上，讓 User 看到。</li></ul><p>整個流程就是：</p><p><mark>使用者發問 → VSCode 接收 → GitHub Copilot 分析 → gpt-4o 理解並產生查詢指令 → Azure DevOps 查詢 → 回傳結果 → gpt-4o 產生易懂的自然語言回應 → 顯示在 VSCode</mark><br>每個角色都扮演特定溝通橋樑，確保使用者的問題能被正確理解並得到回覆。</p><h2 id="總結">總結</h2><p>MCP 的能力協商機制讓各個元件能根據自身特性協調最佳合作方式，確保安全、彈性與高效的互動體驗。透過明確的角色分工與標準化流程，開發者能更容易串接多元工具與服務，擴展 AI 應用場景。未來隨著 MCP 生態系持續發展，將有助於推動語意驅動開發與 AI 協作的普及。</p>]]></content>
    
    
    <summary type="html">&lt;img    
                       lazyload
                       alt=&quot;image&quot;
                       data-src=&quot;/post/2025/07/mcp-capability-negotiation/robot.jpg&quot;
                         align=&quot;left&quot; style=&quot;margin-right: 10px; width: 125px; border: 1px solid gray;&quot;
                 &gt; 
&lt;p&gt;在當前 AI 技術快速發展的時代，MCP (Model Context Protocol) 為大型語言模型帶來更多元且強大的擴展能力。透過 MCP 讓開發者能使 IDE 工具與語言模型自然結合，實現語意驅動的互動體驗。MCP 架構中包含 MCP Server、MCP Host 與 MCP Client 三大核心角色，彼此協同合作並透過能力協商（Capability Negotiation）機制，確保雙方能根據自身能力與需求，協調出最佳的功能組合與協作方式。本文將以&lt;a href=&quot;/post/2025/06/azure-devops-mcp-server/&quot;&gt;上一篇文章&lt;/a&gt;為例，說明其背景運作流程。&lt;/p&gt;</summary>
    
    
    
    
    <category term="MCP" scheme="https://timlai.dev/tags/MCP/"/>
    
  </entry>
  
  <entry>
    <title>Azure DevOps MCP Server</title>
    <link href="https://timlai.dev/post/2025/06/azure-devops-mcp-server/"/>
    <id>https://timlai.dev/post/2025/06/azure-devops-mcp-server/</id>
    <published>2025-06-18T00:39:23.000Z</published>
    <updated>2025-06-22T09:04:18.321Z</updated>
    
    <content type="html"><![CDATA[<img                           lazyload                       alt="image"                       data-src="/post/2025/06/azure-devops-mcp-server/mcp.png"                         align="left" style="margin-right: 10px; width: 125px; border: 1px solid gray;"                 > <p>隨著 AI 技術的蓬勃發展，軟體開發與運維 (DevOps) 流程正迎來一場革命性的轉變。傳統的 DevOps 強調自動化、持續整合與持續交付，但在面對日益複雜的專案協作與工具整合時，團隊仍需投入大量人力進行手動操作與跨系統協調。這時，AI 驅動的自動化與智慧化流程成為新一代 DevOps 的核心訴求。Model Context Protocol（MCP，模型上下文協議）正是在這樣的背景下誕生，為大型語言模型（LLM）與外部工具之間建立一套安全、模組化且可擴充的溝通標準。自微軟在上個月 Microsoft Build 2025 開發者大會宣佈會加入對 MCP 的支援，這個月 Azure DevOps MCP Server 也已公開預覽 (Public Preview)，本文將介紹 Azure DevOps MCP Server 提供了哪些工具。</p><!-- 結合 MCP 的 Azure DevOps MCP Server，讓 AI 助理（如 GitHub Copilot）能直接理解專案脈絡、查詢與操作 DevOps 資源，甚至根據自然語言指令自動執行工作，徹底改變開發者與工具的互動模式。本文將介紹 MCP 的由來、Azure DevOps MCP 的分類與工具，並詳細說明各工具的實際用途，協助你掌握這項前瞻技術如何為團隊帶來更高的生產力與協作效率。 --><br><span id="more"></span><br><h2 id="MCP-的由來">MCP 的由來</h2><p>MCP（Model Context Protocol）最初由 Anthropic 在 2024 年 11 月提出，是一套專為大型語言模型設計的開放式標準協議。其核心目標在於讓 LLM 能夠安全、模組化且可擴充地存取外部工具與資料來源。MCP 的設計理念類似於 API，但傳統 API 是給開發者使用，強調結構化資料與嚴謹格式；而 MCP 則是為 AI 模型量身打造，讓模型能用自然語言理解上下文，並以「對話」方式與外部系統互動。對使用者而言，整個過程更貼近人類溝通習慣，MCP 讓 LLM 不只是資訊生成者，更能成為任務執行者，推動開發流程從「使用工具」進化為「與工具對話」。</p><h2 id="MCP-和-Function-Calling-的不同">MCP 和 Function Calling 的不同</h2><table><thead><tr><th style="text-align:left">功能</th><th style="text-align:left">Function Calling</th><th style="text-align:left">MCP</th></tr></thead><tbody><tr><td style="text-align:left">主要目的</td><td style="text-align:left">把自然語言請求轉成結構化函數呼叫，由應用程式執行</td><td style="text-align:left">標準化 LLM 與外部工具/資料源的連接與執行流程</td></tr><tr><td style="text-align:left">控制權</td><td style="text-align:left">LLM 供應商（如：OpenAI、Anthropic）</td><td style="text-align:left">外部系統（MCP Server/Client）</td></tr><tr><td style="text-align:left">輸出格式</td><td style="text-align:left">不同 LLM 廠商格式各異（通常為 JSON）</td><td style="text-align:left">統一採用標準協議（如：JSON-RPC）</td></tr><tr><td style="text-align:left">擴展性/互通性</td><td style="text-align:left">需為每個工具自訂整合，跨平台困難</td><td style="text-align:left">一次整合，多方兼容，工具可被多個 LLM 共用</td></tr><tr><td style="text-align:left">標準化</td><td style="text-align:left">無統一標準，各家 LLM 格式不同</td><td style="text-align:left">統一協議，保證跨工具、跨平台一致性</td></tr><tr><td style="text-align:left">適用場景</td><td style="text-align:left">單一應用、簡單任務、需嚴格控制副作用</td><td style="text-align:left">多工具、多平台、大規模協作與自動化</td></tr></tbody></table><p>MCP 並非為了取代 Function Calling 而推出，兩者是互補關係：</p><ul><li><strong>Function Calling</strong>：讓 LLM 能夠「決定」要做什麼（下訂單）。</li><li><strong>MCP</strong>：讓這些決策能夠在不同工具、平台間「被執行」且流程標準化（執行訂單）。</li></ul><p>實際應用中，LLM 會先用 Function Calling 決定要呼叫哪個工具、什麼參數，然後 MCP 負責將這個請求標準化、分發到對應的 MCP Server 執行，並將結果回傳。其他關於 MCP 更多的詳細資訊，可以參考下列 Anthropic 官網內容：</p><div class="tips"><font color="black"><a class="link"   href="https://docs.anthropic.com/zh-TW/docs/agents-and-tools/mcp"  target="_blank">⁍ 模型上下文協議 (MCP)<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://github.com/modelcontextprotocol"  target="_blank">⁍ GitHub | Model Context Protocol<i class="fas fa-external-link-alt"></i></a></font></div><h2 id="Azure-DevOps-MCP-Server">Azure DevOps MCP Server</h2><p>Azure DevOps MCP Server 以 MCP 為基礎，提供一套可由 AI 助手（如：GitHub Copilot）透過自然語言存取與操作 Azure DevOps 相關服務的工具集合。這些工具依功能可分類如下幾種：</p><h2 id="🧿-核心-Core">🧿 核心 (Core)</h2><table><thead><tr><th style="text-align:left">工具名稱</th><th style="text-align:left">功能描述</th></tr></thead><tbody><tr><td style="text-align:left">core_list_project_teams</td><td style="text-align:left">取得指定專案的團隊清單</td></tr><tr><td style="text-align:left">core_list_projects</td><td style="text-align:left">取得組織下所有專案清單</td></tr></tbody></table><h2 id="⚒️-工作-Work">⚒️ 工作 (Work)</h2><table><thead><tr><th style="text-align:left">工具名稱</th><th style="text-align:left">功能描述</th></tr></thead><tbody><tr><td style="text-align:left">work_list_team_iterations</td><td style="text-align:left">取得專案中某團隊的所有迭代清單</td></tr><tr><td style="text-align:left">work_create_iterations</td><td style="text-align:left">在指定專案中建立新迭代</td></tr><tr><td style="text-align:left">work_assign_iterations</td><td style="text-align:left">將既有迭代指派給專案中的團隊</td></tr></tbody></table><h2 id="📅-工作項目-Work-Items">📅 工作項目 (Work Items)</h2><table><thead><tr><th style="text-align:left">工具名稱</th><th style="text-align:left">功能描述</th></tr></thead><tbody><tr><td style="text-align:left">wit_my_work_items</td><td style="text-align:left">取得目前使用者相關的工作項目</td></tr><tr><td style="text-align:left">wit_list_backlogs</td><td style="text-align:left">取得專案與團隊的待辦清單</td></tr><tr><td style="text-align:left">wit_list_backlog_work_items</td><td style="text-align:left">取得指定專案、團隊及類別的待辦工作項目</td></tr><tr><td style="text-align:left">wit_get_work_item</td><td style="text-align:left">依 ID 取得單一工作項目</td></tr><tr><td style="text-align:left">wit_get_work_items_batch_by_ids</td><td style="text-align:left">批次取得多個工作項目</td></tr><tr><td style="text-align:left">wit_update_work_item</td><td style="text-align:left">依 ID 更新工作項目欄位</td></tr><tr><td style="text-align:left">wit_create_work_item</td><td style="text-align:left">在指定專案建立新工作項目</td></tr><tr><td style="text-align:left">wit_list_work_item_comments</td><td style="text-align:left">取得指定工作項目的留言</td></tr><tr><td style="text-align:left">wit_get_work_items_for_iteration</td><td style="text-align:left">取得指定迭代的所有工作項目</td></tr><tr><td style="text-align:left">wit_add_work_item_comment</td><td style="text-align:left">為指定工作項目新增留言</td></tr><tr><td style="text-align:left">wit_add_child_work_item</td><td style="text-align:left">由父項目建立子工作項目</td></tr><tr><td style="text-align:left">wit_link_work_item_to_pull_request</td><td style="text-align:left">將工作項目連結至現有 Pull Request</td></tr><tr><td style="text-align:left">wit_get_work_item_type</td><td style="text-align:left">取得指定工作項目類型</td></tr><tr><td style="text-align:left">wit_get_query</td><td style="text-align:left">依 ID 或路徑取得查詢</td></tr><tr><td style="text-align:left">wit_get_query_results_by_id</td><td style="text-align:left">依查詢 ID 取得查詢結果</td></tr><tr><td style="text-align:left">wit_update_work_items_batch</td><td style="text-align:left">批次更新多個工作項目</td></tr><tr><td style="text-align:left">wit_close_and_link_workitem_duplicates</td><td style="text-align:left">關閉重複的工作項目</td></tr><tr><td style="text-align:left">wit_work_items_link</td><td style="text-align:left">批次連結多個工作項目</td></tr></tbody></table><h2 id="📁-原始碼儲存庫-Repositories">📁 原始碼儲存庫 (Repositories)</h2><table><thead><tr><th style="text-align:left">工具名稱</th><th style="text-align:left">功能描述</th></tr></thead><tbody><tr><td style="text-align:left">repo_list_repos_by_project</td><td style="text-align:left">取得專案下所有儲存庫</td></tr><tr><td style="text-align:left">repo_list_pull_requests_by_repo</td><td style="text-align:left">取得指定儲存庫的 Pull Requests</td></tr><tr><td style="text-align:left">repo_list_pull_requests_by_project</td><td style="text-align:left">取得專案下所有 Pull Requests</td></tr><tr><td style="text-align:left">repo_list_branches_by_repo</td><td style="text-align:left">取得指定儲存庫的分支</td></tr><tr><td style="text-align:left">repo_list_my_branches_by_repo</td><td style="text-align:left">取得指定儲存庫中屬於自己的分支</td></tr><tr><td style="text-align:left">repo_list_pull_request_threads</td><td style="text-align:left">取得 Pull Request 的討論串</td></tr><tr><td style="text-align:left">repo_list_pull_request_thread_comments</td><td style="text-align:left">取得討論串中的留言</td></tr><tr><td style="text-align:left">repo_get_repo_by_name_or_id</td><td style="text-align:left">依名稱或 ID 取得儲存庫</td></tr><tr><td style="text-align:left">repo_get_branch_by_name</td><td style="text-align:left">依名稱取得分支</td></tr><tr><td style="text-align:left">repo_get_pull_request_by_id</td><td style="text-align:left">依 ID 取得 Pull Request</td></tr><tr><td style="text-align:left">repo_create_pull_request</td><td style="text-align:left">建立新的 Pull Request</td></tr><tr><td style="text-align:left">repo_update_pull_request_status</td><td style="text-align:left">更新 Pull Request 狀態（啟用或放棄）</td></tr><tr><td style="text-align:left">repo_reply_to_comment</td><td style="text-align:left">回覆 Pull Request 的指定留言</td></tr><tr><td style="text-align:left">repo_resolve_comment</td><td style="text-align:left">解決 Pull Request 討論串中的留言</td></tr></tbody></table><h2 id="🛰️-建置-Builds">🛰️ 建置 (Builds)</h2><table><thead><tr><th style="text-align:left">工具名稱</th><th style="text-align:left">功能描述</th></tr></thead><tbody><tr><td style="text-align:left">build_get_definitions</td><td style="text-align:left">取得專案的建置定義清單</td></tr><tr><td style="text-align:left">build_get_definition_revisions</td><td style="text-align:left">取得指定建置定義的歷史版本</td></tr><tr><td style="text-align:left">build_get_builds</td><td style="text-align:left">取得專案的建置清單</td></tr><tr><td style="text-align:left">build_get_log</td><td style="text-align:left">取得指定建置的日誌</td></tr><tr><td style="text-align:left">build_get_log_by_id</td><td style="text-align:left">依日誌 ID 取得建置日誌</td></tr><tr><td style="text-align:left">build_get_changes</td><td style="text-align:left">取得指定建置的異動</td></tr><tr><td style="text-align:left">build_run_build</td><td style="text-align:left">觸發指定定義的新建置</td></tr><tr><td style="text-align:left">build_get_status</td><td style="text-align:left">取得指定建置的狀態</td></tr></tbody></table><h2 id="🚀-發行-Releases">🚀 發行 (Releases)</h2><table><thead><tr><th style="text-align:left">工具名稱</th><th style="text-align:left">功能描述</th></tr></thead><tbody><tr><td style="text-align:left">release_get_definitions</td><td style="text-align:left">取得專案的發行定義清單</td></tr><tr><td style="text-align:left">release_get_releases</td><td style="text-align:left">取得專案的發行清單</td></tr></tbody></table><h2 id="🧪-測試計畫-Test-Plans">🧪 測試計畫 (Test Plans)</h2><table><thead><tr><th style="text-align:left">工具名稱</th><th style="text-align:left">功能描述</th></tr></thead><tbody><tr><td style="text-align:left">testplan_create_test_plan</td><td style="text-align:left">建立新的測試計畫</td></tr><tr><td style="text-align:left">testplan_create_test_case</td><td style="text-align:left">建立新的測試案例</td></tr><tr><td style="text-align:left">testplan_add_test_cases_to_suite</td><td style="text-align:left">將既有測試案例加入測試套件</td></tr><tr><td style="text-align:left">testplan_list_test_plans</td><td style="text-align:left">分頁取得專案的測試計畫清單，可過濾啟用狀態及細節</td></tr><tr><td style="text-align:left">testplan_list_test_cases</td><td style="text-align:left">取得測試計畫中的測試案例</td></tr><tr><td style="text-align:left">testplan_show_test_results_from_build_id</td><td style="text-align:left">依建置 ID 取得測試結果</td></tr></tbody></table><h2 id="🔎-搜尋-Search">🔎 搜尋 (Search)</h2><table><thead><tr><th style="text-align:left">工具名稱</th><th style="text-align:left">功能描述</th></tr></thead><tbody><tr><td style="text-align:left">search_code</td><td style="text-align:left">依關鍵字搜尋原始碼</td></tr><tr><td style="text-align:left">search_wiki</td><td style="text-align:left">依關鍵字搜尋 Wiki</td></tr><tr><td style="text-align:left">search_workitem</td><td style="text-align:left">依關鍵字搜尋工作項目</td></tr></tbody></table><h2 id="VSCode-的-MCP-設定">VSCode 的 MCP 設定</h2><p>在 VSCode 中要設定 MCP Server 可以按 <strong><code>Ctrl + ,</code></strong> 打開 Settings 畫面，然後點選右上角 Open Settings 圖示，加入下列設定區塊即可，其中 ado_org 代表 Azure DevOps Services 的 Orgnization 名稱，運行 MCP Server 時會提示在 VSCode 上方讓使用者輸入設定。</p><img                         lazyload                       alt="image"                       data-src="/post/2025/06/azure-devops-mcp-server/open_settings.png"                        class=""                 ><br><img                         lazyload                       alt="image"                       data-src="/post/2025/06/azure-devops-mcp-server/mcp_setting.png"                        class=""                 ><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;inputs&quot;:</span> [</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="attr">&quot;id&quot;:</span> <span class="string">&quot;ado_org&quot;</span>,</span><br><span class="line">         <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;promptString&quot;</span>,</span><br><span class="line">         <span class="attr">&quot;description&quot;:</span> <span class="string">&quot;Azure DevOps organization name  (e.g. &#x27;contoso&#x27;)&quot;</span></span><br><span class="line">     &#125;</span><br><span class="line">   ],</span><br><span class="line">   <span class="attr">&quot;servers&quot;:</span> &#123;</span><br><span class="line">     <span class="attr">&quot;ado&quot;:</span> &#123;</span><br><span class="line">         <span class="attr">&quot;type&quot;:</span> <span class="string">&quot;stdio&quot;</span>,</span><br><span class="line">         <span class="attr">&quot;command&quot;:</span> <span class="string">&quot;npx&quot;</span>,</span><br><span class="line">         <span class="attr">&quot;args&quot;:</span> [</span><br><span class="line">             <span class="string">&quot;-y&quot;</span>,</span><br><span class="line">             <span class="string">&quot;@azure-devops/mcp&quot;</span>,</span><br><span class="line">             <span class="string">&quot;$&#123;input:ado_org&#125;&quot;</span></span><br><span class="line">         ]</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>而在使用前也必需先以 <strong><code>az login</code></strong> 登入帳號取得使用權限，才能讓 Azure DevOps MCP Server 正常存取資源，要運行或停止設定檔的 MCP Server 僅需要在存檔後，每個 MCP Server 名稱上方就會出現 Start/Stop 的字樣可以點選。</p><br><img                         lazyload                       alt="image"                       data-src="/post/2025/06/azure-devops-mcp-server/az_login.png"                        class=""                 ><br><img                         lazyload                       alt="image"                       data-src="/post/2025/06/azure-devops-mcp-server/start_mcp.png"                        class=""                 ><br>完成 settings.json 的設定並啟動 ado 這個 MCP Server 後，我們就可以在 GitHub Copilot 的 Agent mode 中調用前述整理的各項工具。在對話過程中，GitHub Copilot 會同時列出目前可用的工具清單，讓所選用的模型 (如：GPT-4o) 能根據指令調用相關工具，並將執行結果回傳給使用者，協助回覆各類查詢。<br><img                         lazyload                       alt="image"                       data-src="/post/2025/06/azure-devops-mcp-server/agent_mode.png"                        class=""                 ><h2 id="結語">結語</h2><p>有了 Azure DevOps MCP Server 提供的工具後，我們就可以透過對話的方式來互動取得 Azure DevOps Services 相關資訊，並自動執行各種開發、協作與運維任務，讓 AI 助理真正成為團隊的智慧夥伴。MCP 標準的導入不僅大幅降低了跨系統整合的門檻，也讓開發流程更具彈性與擴展性，目前 Azure DevOps MCP Server 僅支援雲端的 Azure DevOps Services，尚不支援地端 Azure DevOps Server 的存取方式 (依目前得知的消息，未來幾個月內也不會提供)，但其實要實作 MCP Server 來自己串接這一段也不是太困難的問題，後續有機會再開一篇文章向大家說明。</p><div class="tips"><font color="black"><a class="link"   href="https://github.com/microsoft/mcp"  target="_blank">⁍ GitHub | mcp<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://github.com/microsoft/azure-devops-mcp"  target="_blank">⁍ GitHub | azure-devops-mcp<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://learn.microsoft.com/en-us/azure/developer/azure-mcp-server/tools/"  target="_blank">⁍ What are the Azure MCP Server tools?<i class="fas fa-external-link-alt"></i></a></font></div>]]></content>
    
    
    <summary type="html">&lt;img    
                       lazyload
                       alt=&quot;image&quot;
                       data-src=&quot;/post/2025/06/azure-devops-mcp-server/mcp.png&quot;
                         align=&quot;left&quot; style=&quot;margin-right: 10px; width: 125px; border: 1px solid gray;&quot;
                 &gt; 
&lt;p&gt;隨著 AI 技術的蓬勃發展，軟體開發與運維 (DevOps) 流程正迎來一場革命性的轉變。傳統的 DevOps 強調自動化、持續整合與持續交付，但在面對日益複雜的專案協作與工具整合時，團隊仍需投入大量人力進行手動操作與跨系統協調。這時，AI 驅動的自動化與智慧化流程成為新一代 DevOps 的核心訴求。Model Context Protocol（MCP，模型上下文協議）正是在這樣的背景下誕生，為大型語言模型（LLM）與外部工具之間建立一套安全、模組化且可擴充的溝通標準。自微軟在上個月 Microsoft Build 2025 開發者大會宣佈會加入對 MCP 的支援，這個月 Azure DevOps MCP Server 也已公開預覽 (Public Preview)，本文將介紹 Azure DevOps MCP Server 提供了哪些工具。&lt;/p&gt;
&lt;!-- 結合 MCP 的 Azure DevOps MCP Server，讓 AI 助理（如 GitHub Copilot）能直接理解專案脈絡、查詢與操作 DevOps 資源，甚至根據自然語言指令自動執行工作，徹底改變開發者與工具的互動模式。本文將介紹 MCP 的由來、Azure DevOps MCP 的分類與工具，並詳細說明各工具的實際用途，協助你掌握這項前瞻技術如何為團隊帶來更高的生產力與協作效率。 --&gt;
&lt;br&gt;</summary>
    
    
    
    
    <category term="Azure DevOps" scheme="https://timlai.dev/tags/Azure-DevOps/"/>
    
    <category term="MCP" scheme="https://timlai.dev/tags/MCP/"/>
    
  </entry>
  
  <entry>
    <title>Azure Pipelines Agents 代理程式</title>
    <link href="https://timlai.dev/post/2025/06/update-azure-pipelines-agents/"/>
    <id>https://timlai.dev/post/2025/06/update-azure-pipelines-agents/</id>
    <published>2025-06-08T15:05:46.000Z</published>
    <updated>2025-07-08T14:31:20.861Z</updated>
    
    <content type="html"><![CDATA[<img                           lazyload                       alt="image"                       data-src="/post/2025/06/update-azure-pipelines-agents/azure_pipelines_agents.png"                         align="left" style="margin-right: 10px; width: 125px; border: 1px solid gray;"                 > <p>Azure Pipelines Agents 是現代 DevOps 流程中不可或缺的基礎組件。隨著企業加速數位轉型，持續整合（CI）與持續交付（CD）成為團隊自動化建置、測試與部署的重要手段。Azure Pipelines 做為 Azure DevOps 的核心服務之一，透過代理程式（Agent）來執行各式自動化工作。無論是雲端託管或自我託管，代理程式皆負責與 Azure DevOps Server 或 Azure DevOps Services 溝通，協助團隊將程式碼快速且安全地部署至各種環境。近年來，隨著代理程式版本的演進，功能與安全性也大幅提升，特別是在 3.x 與 4.x 之間有諸多關鍵差異，本文將介紹 Azure Pipelines Agents 的基本概念、版本比較、更新方式與工作目錄結構。<br><br></p><span id="more"></span><br><h2 id="什麼是-Azure-Pipelines-Agents">什麼是 Azure Pipelines Agents</h2><p>Azure Pipelines Agents 代理程式是負責執行 Azure Pipelines 工作（如建置、測試、部署）的運算節點。當您在 Azure DevOps 中建立 CI/CD 流程時，實際負責操作指令、拉取程式碼、執行腳本與產生建置產物的，就是這些代理程式。</p><p><strong>代理程式類型：</strong></p><ul><li><strong>Microsoft-Hosted</strong>：由微軟提供與維護，適合雲端開發。</li><li><strong>Self-Hosted</strong>：由使用者自行安裝於 VM、實體機或容器，適合需要存取內部資源或自訂環境的需求。</li><li><strong>Managed DevOps Pool</strong>：Azure 提供的完全受控虛擬機或容器資源。</li><li><strong>Azure Virtual Machine Scale Sets</strong>：可自動擴展的自我託管代理程式，適合彈性需求。</li></ul><img                         lazyload                       alt="image"                       data-src="/post/2025/06/update-azure-pipelines-agents/agent-topologies-tfs.png"                        class=""                 ><p>不論是使用 Azure DevOps Services 或是自建 Azure DevOps Server，代理程式都是使用 HTTPS(443) 來進行下載作業、回報狀態，並確保敏感資訊透過加密方式傳輸。</p><div class="tips"><font color="black"><a class="link"   href="https://learn.microsoft.com/zh-tw/azure/devops/managed-devops-pools/architecture-overview?view=azure-devops"  target="_blank">⁍ Microsoft受控 DevOps 集區架構概觀<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://learn.microsoft.com/zh-tw/azure/virtual-machine-scale-sets/overview"  target="_blank">⁍ 什麼是虛擬機器擴展集<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://learn.microsoft.com/zh-tw/azure/devops/managed-devops-pools/migrate-from-scale-set-agents?view=azure-devops"  target="_blank">⁍ 比較管理的 DevOps 群組與 Azure 虛擴展集的代理<i class="fas fa-external-link-alt"></i></a></font></div><br><h2 id="Azure-Pipelines-2-x、3-x、4-x-版本差異比較">Azure Pipelines 2.x、3.x、4.x 版本差異比較</h2><p>根據官方文件，Azure Pipelines Agents 2.x、3.x 與 4.x 版本在底層平台、作業系統支援範圍、安全性、升級策略等多方面皆有顯著差異。以下整理三個版本的主要比較：</p><table><thead><tr><th style="text-align:left">項目</th><th style="text-align:left">2.x 代理程式</th><th style="text-align:left">3.x 代理程式</th><th style="text-align:left">4.x 代理程式</th></tr></thead><tbody><tr><td style="text-align:left">核心平台</td><td style="text-align:left">.NET Core 3.1</td><td style="text-align:left">.NET 6</td><td style="text-align:left">.NET 8</td></tr><tr><td style="text-align:left">發行時間</td><td style="text-align:left">2021 年以前</td><td style="text-align:left">2023 年 3 月</td><td style="text-align:left">2024 年 10 月</td></tr><tr><td style="text-align:left">作業系統支援</td><td style="text-align:left">支援較舊的作業系統</td><td style="text-align:left">支援較新 OS，淘汰部分舊版</td><td style="text-align:left">僅支援最新 OS，淘汰更多舊版</td></tr><tr><td style="text-align:left">主要支援 OS</td><td style="text-align:left">Windows 7/8.1、舊版 Linux</td><td style="text-align:left">Windows 10/11、Ubuntu 18+</td><td style="text-align:left">Windows 10/11、Ubuntu 20+</td></tr><tr><td style="text-align:left">macOS 支援</td><td style="text-align:left">macOS 10.15 及以上</td><td style="text-align:left">macOS 10.15~14 (含 ARM64)</td><td style="text-align:left">macOS 13~15 (含 ARM64)</td></tr><tr><td style="text-align:left">Linux 支援</td><td style="text-align:left">舊版 Linux (Debian 10 等)</td><td style="text-align:left">Debian 10+、Ubuntu 16+</td><td style="text-align:left">Debian 12、Ubuntu 20+</td></tr><tr><td style="text-align:left">安全性維護</td><td style="text-align:left">僅針對重大問題個案處理</td><td style="text-align:left">僅針對 3.x 修補</td><td style="text-align:left">僅針對 4.x 修補</td></tr><tr><td style="text-align:left">依賴平台</td><td style="text-align:left">需安裝 .NET Core 3.1</td><td style="text-align:left">.NET 6 已內建於代理程式中</td><td style="text-align:left">.NET 8 已內建於代理程式中</td></tr></tbody></table><h3 id="升級與相容性注意事項">升級與相容性注意事項</h3><p>2.x、3.x、4.x 代理程式的主要差異在於底層 .NET 平台、支援的作業系統範圍、相容性與維護策略，若代理程式執行於不支援的作業系統，將無法升級至新版，且執行管線時會出現錯誤提示，需先升級作業系統才能繼續。每一代代理程式僅針對自身版本進行安全性修補，建議維運團隊定期檢查代理程式與作業系統版本，確保 DevOps 流程穩定且安全。</p><div class="tips"><font color="black"><a class="link"   href="https://learn.microsoft.com/zh-tw/azure/devops/pipelines/agents/agents?view=azure-devops-2022&tabs=yaml%2Cbrowser#can-i-update-my-agents-that-are-part-of-an-azure-devops-server-pool"  target="_blank">⁍ Azure Pipelines 代理程式<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://learn.microsoft.com/zh-tw/azure/devops/pipelines/agents/v3-agent?view=azure-devops"  target="_blank">⁍ 代理程式軟體第 3 版<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://learn.microsoft.com/zh-tw/azure/devops/pipelines/agents/v4-agent?view=azure-devops#upgrade-to-4x-agent-on-supported-operating-systems"  target="_blank">⁍ 代理程式軟體第 4 版<i class="fas fa-external-link-alt"></i></a></font></div><br><h2 id="Azure-DevOps-Server-更新代理程式來源方式">Azure DevOps Server 更新代理程式來源方式</h2><p>若您在地端環境 Azure DevOps Server 中管理 Self-Hosted Agent，除了透過網路自動更新外，也可以手動指定代理程式的安裝來源。只需將新版代理程式的壓縮檔（.zip）放置於伺服器的 <strong><code>%ProgramData%\Microsoft\Azure DevOps\Agents</code></strong> 目錄內，代理程式便會自動從該路徑取得更新檔案（如下圖 4.258.1）；若將目錄中的檔案清空，則會顯示目前 Azure DevOps Server 預設的下載版本，例如：Azure DevOps Server 2022.2 預設版本是 3.240.0。</p><img                         lazyload                       alt="image"                       data-src="/post/2025/06/update-azure-pipelines-agents/agents_folder.png"                        class=""                 ><br><img                         lazyload                       alt="image"                       data-src="/post/2025/06/update-azure-pipelines-agents/get_the_agent.png"                        class=""                 ><blockquote><p>若要更新 Azure DevOps Server 的代理程式，請將新版本壓縮檔放到 <mark><strong>%ProgramData%\Microsoft\Azure DevOps\Agents</strong></mark> 資料夾，代理程式會自動偵測並完成更新</p></blockquote><p>關於 Azure Pipelines Agent 發行過的所有版本都可以在 GitHub 的 Release 紀錄中找到，可以參考下列連結。</p><div class="tips"><font color="black"><a class="link"   href="https://github.com/microsoft/azure-pipelines-agent/releases"  target="_blank">⁍ GitHub | Azure Pipelines Agent 🚀<i class="fas fa-external-link-alt"></i></a></font></div><br><h2 id="Azure-Pipelines-Agents-工作目錄結構">Azure Pipelines Agents 工作目錄結構</h2><p>代理程式在執行 pipeline 作業時，會建立一套標準化的目錄結構，用於儲存原始碼、建置產物、測試結果等資料。以下為主要目錄說明：</p><table><thead><tr><th style="text-align:left">目錄名稱</th><th style="text-align:left">說明</th><th style="text-align:left">範例（Windows）</th><th style="text-align:left">預設變數</th></tr></thead><tbody><tr><td style="text-align:left">代理主目錄</td><td style="text-align:left">代理程式安裝位置</td><td style="text-align:left"><strong><mark>C:\agent</mark></strong></td><td style="text-align:left">Agent.HomeDirectory</td></tr><tr><td style="text-align:left">工作目錄</td><td style="text-align:left">儲存原始碼、建置產物、專案等</td><td style="text-align:left">C:\agent\ <strong><mark>_work</mark></strong></td><td style="text-align:left">Agent.WorkFolder</td></tr><tr><td style="text-align:left">建置目錄/工作區</td><td style="text-align:left">管線作業執行位置</td><td style="text-align:left">C:\agent_work\ <strong><mark>1</mark></strong></td><td style="text-align:left">Agent.BuildDirectory</td></tr><tr><td style="text-align:left">s 目錄</td><td style="text-align:left">檢出後的原始碼目錄</td><td style="text-align:left">C:\agent_work\1\ <strong><mark>s</mark></strong></td><td style="text-align:left">Build.SourcesDirectory</td></tr><tr><td style="text-align:left">b 目錄</td><td style="text-align:left">建置產物目錄</td><td style="text-align:left">C:\agent_work\1\ <strong><mark>b</mark></strong></td><td style="text-align:left">Build.BinariesDirectory</td></tr><tr><td style="text-align:left">a 目錄</td><td style="text-align:left">工件暫存目錄</td><td style="text-align:left">C:\agent_work\1\ <strong><mark>a</mark></strong></td><td style="text-align:left">Build.StagingDirectory</td></tr><tr><td style="text-align:left">TestResults</td><td style="text-align:left">測試結果目錄</td><td style="text-align:left">C:\agent_work\1\ <strong><mark>TestResults</mark></strong></td><td style="text-align:left">Common.TestResultsDirectory</td></tr></tbody></table><ul><li><strong>代理主目錄</strong>：安裝代理程式的根目錄。</li><li><strong>工作目錄</strong>：所有作業的儲存空間，會依每次執行建立子目錄。</li><li><strong>建置/工作區目錄</strong>：每次 pipeline 執行時的專屬目錄。</li><li><strong>s/b/a/TestResults</strong>：分別對應原始碼、建置產物、工件暫存與測試結果。</li></ul><p>在 Self-Hosted 執行環境，這些目錄會在每次執行間保留，僅暫存與測試結果目錄會自動清理；若為 Microsoft-Hosted 則每次皆為全新環境，瞭解各目錄的用途與預設變數名稱對於後續的 pipeline 撰寫有很大的助益，在 Azure Pipelines 中預先定義的變數可以參考下列連結。</p><div class="tips"><font color="black"><a class="link"   href="https://learn.microsoft.com/zh-tw/azure/devops/pipelines/build/variables?view=azure-devops&tabs=yaml"  target="_blank">⁍ 使用預先定義的變數<i class="fas fa-external-link-alt"></i></a></font></div><br><h2 id="結語">結語</h2><p>Azure Pipelines Agents 是實現現代 DevOps 流程的關鍵，無論是雲端或地端部署，選擇合適的代理程式版本與管理方式，能大幅提升自動化流程的安全性與效率，維運團隊可以持續關注代理程式版本更新，並善用官方提供的更新機制，打造穩健且高效的 CI/CD 環境。</p><h2 id="後續更新">後續更新</h2><p>今天剛好有客戶詢問如何更新 Azure Pipelines Agent 版本，實務上如前文所述，只需先從 GitHub 下載所需的代理程式版本，放到 Azure DevOps Server 指定的資料夾，接著在 Web 介面點選 <strong><code>Update all agents</code></strong> 按鈕，即可批次更新指定 pool 內所有狀態為 Online 的 Agent。整個更新過程無需停機，Agent 會自動收到更新指令、下載並安裝新版本，完成後會自動重啟服務（大約僅離線 10 秒），即可輕鬆完成批次更新作業。</p><img                         lazyload                       alt="image"                       data-src="/post/2025/06/update-azure-pipelines-agents/update_agent.png"                        class=""                 >]]></content>
    
    
    <summary type="html">&lt;img    
                       lazyload
                       alt=&quot;image&quot;
                       data-src=&quot;/post/2025/06/update-azure-pipelines-agents/azure_pipelines_agents.png&quot;
                         align=&quot;left&quot; style=&quot;margin-right: 10px; width: 125px; border: 1px solid gray;&quot;
                 &gt; 
&lt;p&gt;Azure Pipelines Agents 是現代 DevOps 流程中不可或缺的基礎組件。隨著企業加速數位轉型，持續整合（CI）與持續交付（CD）成為團隊自動化建置、測試與部署的重要手段。Azure Pipelines 做為 Azure DevOps 的核心服務之一，透過代理程式（Agent）來執行各式自動化工作。無論是雲端託管或自我託管，代理程式皆負責與 Azure DevOps Server 或 Azure DevOps Services 溝通，協助團隊將程式碼快速且安全地部署至各種環境。近年來，隨著代理程式版本的演進，功能與安全性也大幅提升，特別是在 3.x 與 4.x 之間有諸多關鍵差異，本文將介紹 Azure Pipelines Agents 的基本概念、版本比較、更新方式與工作目錄結構。&lt;br&gt;
&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Azure DevOps" scheme="https://timlai.dev/tags/Azure-DevOps/"/>
    
    <category term="Azure Pipelines Agents" scheme="https://timlai.dev/tags/Azure-Pipelines-Agents/"/>
    
  </entry>
  
  <entry>
    <title>使用 Playwright 測試框架 - 執行階段 (.NET)</title>
    <link href="https://timlai.dev/post/2025/05/how-to-use-playwright-2/"/>
    <id>https://timlai.dev/post/2025/05/how-to-use-playwright-2/</id>
    <published>2025-05-27T11:20:14.000Z</published>
    <updated>2025-05-28T06:09:20.807Z</updated>
    
    <content type="html"><![CDATA[<img                           lazyload                       alt="image"                       data-src="/post/2025/05/how-to-use-playwright-1/playwright.png"                         align="left" style="margin-right: 10px; width: 125px; border: 1px solid gray;"                 > <p><a href="/post/2024/11/how-to-use-playwright-1">上一篇文章</a>提到了如何使用 Playwright 的測試產生器(codegen) 錄製腳本，除了可以運用在自動化測試之外，舉凡想要透過程式來自動執行的一連串行為，都可以透過 Playwright 來完成，本篇文章使用 Windows Sandbox 全新環境來執行由 .NET 8 撰寫的 Console 程式，讓大家知道建置產生執行檔後，還需要哪些必要的環境設定才可以正常讓程式運作。<br><br></p><span id="more"></span><br><h2 id="安裝-NET-Runtime">安裝 .NET Runtime</h2><p>不論是以前的 .NET Framework 或是現在的 .NET Core，在執行時都需要安裝 .NET Runtime 才能順利運行開發好的程式，以下圖 Console 專案建置後的執行檔為例，畫面還會很貼心的指引我們目前的需求版本和下載路徑，完成安裝後便可順利執行 Console 程式。</p><img                         lazyload                       alt="image"                       data-src="/post/2025/05/how-to-use-playwright-2/dotnet8.png"                        class=""                 ><br><div class="tips"><font color="black"><a class="link"   href="https://dotnet.microsoft.com/download"  target="_blank">⁍ 下載 .NET<i class="fas fa-external-link-alt"></i></a></font></div><h2 id="安裝-PowerShell">安裝 PowerShell</h2><p>如果是全新的環境，安裝完 .NET Runtime 後應該還會出現如下圖的錯誤，主要原因是：</p><ul><li>pwsh 找不到路徑 (或是沒有安裝 PowerShell)</li><li>缺少 WebDriver (Edge/Chrome/Firefox)</li></ul><img                         lazyload                       alt="image"                       data-src="/post/2025/05/how-to-use-playwright-2/pwsh.png"                        class=""                 ><br>若要安裝 PowerShell 可以依據自己的作業系統參考下列連結：<div class="tips"><font color="black"><a class="link"   href="https://learn.microsoft.com/zh-tw/powershell/scripting/install/installing-powershell-on-windows?view=powershell-7.5"  target="_blank">⁍ 在 Windows 上安裝 PowerShell<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://learn.microsoft.com/zh-tw/powershell/scripting/install/installing-powershell-on-linux?view=powershell-7.5"  target="_blank">⁍ 在 Linux 上安裝 PowerShell<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://learn.microsoft.com/zh-tw/powershell/scripting/install/installing-powershell-on-macos?view=powershell-7.5"  target="_blank">⁍ 在 macOS 上安裝 PowerShell<i class="fas fa-external-link-alt"></i></a></font></div><h2 id="安裝-WebDriver">安裝 WebDriver</h2><p>在上圖的錯誤訊息中有提到如下指令，路徑中的 <strong><mark>netX</mark></strong> 要替換為自己使用的版本路徑，而其中的 playwright.ps1 會存在於 .NET 程式建置後的 bin 目錄中，這個 .ps1 的主要用途是在 Windows 環境下執行 Playwright 測試，讓它可以正確找到 Playwright 主程式和相關驅動程式，確認 pwsh 指令可以運作後，就可以接著安裝 WebDriver 了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwsh bin/Debug/netX/playwright.ps1 install</span><br></pre></td></tr></table></figure><img                         lazyload                       alt="image"                       data-src="/post/2025/05/how-to-use-playwright-2/playwright.png"                        class=""                 ><br>若在 install 之後沒有加上任何參數，則會安裝下列預設項目：<ul><li>Chromium</li><li>Chromium Headless Shell</li><li>Firefox</li><li>Webkit</li><li>FFMPEG</li></ul><img                         lazyload                       alt="image"                       data-src="/post/2025/05/how-to-use-playwright-2/install.png"                        class=""                 ><br>也可以依自己的需求安裝指定項目，可使用 install -h 查看相關資訊：<img                         lazyload                       alt="image"                       data-src="/post/2025/05/how-to-use-playwright-2/custom.png"                        class=""                 ><h2 id="總結">總結</h2><p>本文介紹了在全新環境下，如何讓 .NET 8 撰寫的 Playwright 測試程式順利執行，包含安裝 .NET Runtime、PowerShell 及 WebDriver 等必要步驟。只要依照上述流程完成環境設定，就能避免常見的錯誤訊息，順利執行自動化測試。希望這些說明能幫助你在不同平台上快速部署與運行 Playwright 測試專案。</p>]]></content>
    
    
    <summary type="html">&lt;img    
                       lazyload
                       alt=&quot;image&quot;
                       data-src=&quot;/post/2025/05/how-to-use-playwright-1/playwright.png&quot;
                         align=&quot;left&quot; style=&quot;margin-right: 10px; width: 125px; border: 1px solid gray;&quot;
                 &gt; 
&lt;p&gt;&lt;a href=&quot;/post/2024/11/how-to-use-playwright-1&quot;&gt;上一篇文章&lt;/a&gt;提到了如何使用 Playwright 的測試產生器(codegen) 錄製腳本，除了可以運用在自動化測試之外，舉凡想要透過程式來自動執行的一連串行為，都可以透過 Playwright 來完成，本篇文章使用 Windows Sandbox 全新環境來執行由 .NET 8 撰寫的 Console 程式，讓大家知道建置產生執行檔後，還需要哪些必要的環境設定才可以正常讓程式運作。&lt;br&gt;
&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Playwright" scheme="https://timlai.dev/tags/Playwright/"/>
    
  </entry>
  
  <entry>
    <title>使用 Playwright 測試框架 - 環境準備 (.NET)</title>
    <link href="https://timlai.dev/post/2025/05/how-to-use-playwright-1/"/>
    <id>https://timlai.dev/post/2025/05/how-to-use-playwright-1/</id>
    <published>2025-05-19T09:40:54.000Z</published>
    <updated>2025-05-28T06:09:20.805Z</updated>
    
    <content type="html"><![CDATA[<img                           lazyload                       alt="image"                       data-src="/post/2025/05/how-to-use-playwright-1/playwright.png"                         align="left" style="margin-right: 10px; width: 125px; border: 1px solid gray;"                 > <p>在現代軟體開發中，自動化測試已成為確保程式碼品質的重要一環，Playwright 是一個強大的自動化測試框架，支援 Chromium / Firefox / WebKit 瀏覽器，搭配測試產生器(codegen)讓開發者能夠輕鬆撰寫可靠且高效的測試腳本。本篇文章將介紹如何在 .NET 開發環境中設置和使用 Playwright，從安裝必要的套件到撰寫基本的測試案例，幫助大家快速上手這個工具。<br><br></p><span id="more"></span><br><h2 id="使用-Visual-Studio">使用 Visual Studio</h2><p>如果是慣用地表最強開發工具，打開 Visual Studio 建立一個新的 <strong><code>MSTest 測試專案</code></strong>，讓我們有一個基本測試環境可以開始撰寫 Playwright 測試。</p><img                         lazyload                       alt="image"                       data-src="/post/2025/05/how-to-use-playwright-1/vs-01.png"                        class=""                 ><br><p>要在 MSTest 使用 Playwright 必需要安裝 <strong><code>Microsoft.Playwright.MSTest</code></strong> 套件，這個套件會將 Playwright 與 MSTest 整合，使我們能夠在 MSTest 測試過程中使用 Playwright 功能。</p><img                         lazyload                       alt="image"                       data-src="/post/2025/05/how-to-use-playwright-1/vs-02.png"                        class=""                 ><h2 id="使用-NET-CLI">使用 .NET CLI</h2><p>若是使用 VSCode 開發工具，我們可以用 <strong>dotnet new</strong> 指令新增一個 PlaywrightTests 專案，預設內容會包含一個 UnitTest1.cs 檔案。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dotnet new mstest -n PlaywrightTests</span><br><span class="line">cd PlaywrightTests</span><br></pre></td></tr></table></figure><p>安裝必要的 Playwright 相依套件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet add package Microsoft.Playwright.MSTest</span><br></pre></td></tr></table></figure><img                         lazyload                       alt="image"                       data-src="/post/2025/05/how-to-use-playwright-1/cli-01.png"                        class=""                 ><br><p>建置程式碼，確認環境準備是否有異常。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet build</span><br></pre></td></tr></table></figure><img                         lazyload                       alt="image"                       data-src="/post/2025/05/how-to-use-playwright-1/cli-02.png"                        class=""                 ><br><h2 id="安裝-Playwright-CLI">安裝 Playwright CLI</h2><p>在 .NET 開發環境中，雖然 <strong>playwright.exe</strong> 指令沒有像 <strong>npx playwright</strong> 那麼多參數與功能，但我們在錄製網頁操作過程來產生測試程式碼 (codegen)，或是開啟追蹤檔 (show-trace) 時仍會使用到，可以透過下列指令來安裝 <strong><code>Microsoft.Playwright.CLI</code></strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet tool install --global Microsoft.Playwright.CLI</span><br></pre></td></tr></table></figure><p>上述套件預設會被安裝到目前的使用者範圍內的 .NET 全局工具路徑中，具體安裝位置會因作業系統而異：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Windows</span><br><span class="line">C:\Users\&lt;你的用戶名&gt;\.dotnet\tools\</span><br><span class="line"></span><br><span class="line">Linux / macOS</span><br><span class="line">/home/&lt;你的用戶名&gt;/.dotnet/tools/</span><br></pre></td></tr></table></figure><img                         lazyload                       alt="image"                       data-src="/post/2025/05/how-to-use-playwright-1/cli-03.png"                        class=""                 ><p>我們可以直接開啟目錄確認工具是否安裝成功，或是使用以下指令來列出所有安裝的 .NET 工具：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet tool list --global</span><br></pre></td></tr></table></figure><p>例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Package Id                    Version      Commands</span><br><span class="line">-----------------------------------------------------</span><br><span class="line">dotnet-ef                     8.0.8        dotnet-ef</span><br><span class="line">microsoft.playwright.cli      1.2.3        playwright</span><br></pre></td></tr></table></figure><h2 id="移除-Playwright-CLI">移除 Playwright CLI</h2><p>若需要移除已安裝的套件，可以使用下列指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dotnet tool uninstall microsoft.playwright.cli</span><br></pre></td></tr></table></figure><h2 id="安裝-Playwright-支援的瀏覽器">安裝 Playwright 支援的瀏覽器</h2><p>Playwright 支援 Chromium、WebKit 和 Firefox 瀏覽器，我們可以使用 <strong>playwright install</strong> 指令來安裝預設瀏覽器，這個動作會將瀏覽器安裝到 <strong><mark>%LOCALAPPDATA%\ms-playwright</mark></strong> 目錄下，若想要自訂安裝的項目，可以透過 <strong>playwright help install</strong> 來瞭解所有的選項。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">playwright install</span><br></pre></td></tr></table></figure><img                         lazyload                       alt="image"                       data-src="/post/2025/05/how-to-use-playwright-1/cli-04.png"                        class=""                 ><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">playwright help install</span><br></pre></td></tr></table></figure><img                         lazyload                       alt="image"                       data-src="/post/2025/05/how-to-use-playwright-1/cli-05.png"                        class=""                 ><h2 id="小試身手">小試身手</h2><p>以上 Playwright 環境設定都完成後，我們就可以直接用官網的第一個範例來小試身手：</p><ul><li><p><code>HasTitle()</code><br>打開 Playwright 官方網站，檢查網站的標題是否包含特定的字串，確認網頁標題中是否包含 “Playwright” 這個字。</p></li><li><p><code>GetStartedLink()</code><br>一樣是打開 Playwright 官方網站，點擊一個名為 “Get started” 的連結，然後檢查點擊後的頁面是否有一個名為 “Installation” 的標題，以確保連結正確導向到預期的頁面。</p></li></ul><p>大家應該不難發現 Playwright 的程式碼很直覺易讀，通常也不太需要夾雜 CSS class 或 style 來尋找定位網頁上的元素，除此之外還提供了豐富的 API 來進行各種操作，如：點擊、輸入文字、截圖等，之後再陸續向大家介紹各項重點特色，希望大家也都能快速上手 Playwright，並在日常開發中提升測試效率與程式碼品質。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Text.RegularExpressions;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Playwright;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Playwright.MSTest;</span><br><span class="line"><span class="keyword">using</span> Microsoft.VisualStudio.TestTools.UnitTesting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">PlaywrightTests</span>;</span><br><span class="line"></span><br><span class="line">[<span class="meta">TestClass</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ExampleTest</span> : <span class="title">PageTest</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">TestMethod</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">HasTitle</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> Page.GotoAsync(<span class="string">&quot;https://playwright.dev&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Expect a title &quot;to contain&quot; a substring.</span></span><br><span class="line">        <span class="keyword">await</span> Expect(Page).ToHaveTitleAsync(<span class="keyword">new</span> Regex(<span class="string">&quot;Playwright&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">TestMethod</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">GetStartedLink</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">await</span> Page.GotoAsync(<span class="string">&quot;https://playwright.dev&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Click the get started link.</span></span><br><span class="line">        <span class="keyword">await</span> Page.GetByRole(AriaRole.Link, <span class="keyword">new</span>() &#123; Name = <span class="string">&quot;Get started&quot;</span> &#125;).ClickAsync();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Expects page to have a heading with the name of Installation.</span></span><br><span class="line">        <span class="keyword">await</span> Expect(Page.GetByRole(AriaRole.Heading, <span class="keyword">new</span>() &#123; Name = <span class="string">&quot;Installation&quot;</span> &#125;)).ToBeVisibleAsync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;img    
                       lazyload
                       alt=&quot;image&quot;
                       data-src=&quot;/post/2025/05/how-to-use-playwright-1/playwright.png&quot;
                         align=&quot;left&quot; style=&quot;margin-right: 10px; width: 125px; border: 1px solid gray;&quot;
                 &gt; 
&lt;p&gt;在現代軟體開發中，自動化測試已成為確保程式碼品質的重要一環，Playwright 是一個強大的自動化測試框架，支援 Chromium / Firefox / WebKit 瀏覽器，搭配測試產生器(codegen)讓開發者能夠輕鬆撰寫可靠且高效的測試腳本。本篇文章將介紹如何在 .NET 開發環境中設置和使用 Playwright，從安裝必要的套件到撰寫基本的測試案例，幫助大家快速上手這個工具。&lt;br&gt;
&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Playwright" scheme="https://timlai.dev/tags/Playwright/"/>
    
    <category term="Unit Test" scheme="https://timlai.dev/tags/Unit-Test/"/>
    
  </entry>
  
  <entry>
    <title>MSTest 生命週期與常用屬性</title>
    <link href="https://timlai.dev/post/2025/04/mstest-attribute-lifecycle/"/>
    <id>https://timlai.dev/post/2025/04/mstest-attribute-lifecycle/</id>
    <published>2025-04-28T06:27:44.000Z</published>
    <updated>2025-05-28T06:09:20.807Z</updated>
    
    <content type="html"><![CDATA[<img                           lazyload                       alt="image"                       data-src="/post/2025/04/mstest-attribute-lifecycle/MSTest.png"                         align="left" style="margin-right: 10px; width: 125px; border: 1px solid gray;"                 > <p>在軟體開發過程中，妥善進行測試可以協助我們確保程式碼的功能性與可靠性，不論是最小範圍的<strong>單元測試 (Unit Tests)</strong> 或是模擬實際用戶的<strong>端對端測試(E2E Tests)</strong>，都是品質把關的重要防線，而 MSTest 除了被整合在 Visual Studio 中，簡化了 .NET 應用程式建立和執行單元測試的過程，也可以透過 Azure Pipelines 將既有的測試專案整合到 CI 流程裡，這篇主要帶大家瞭解 MSTest 生命週期以及常用屬性，以便大家更能掌握自己的測試流程。</p><span id="more"></span><br><h2 id="前言">前言</h2><p><strong>測試類別(TestClass)</strong> 和 <strong>測試方法(TestMethod)</strong> 是 MSTest 核心要素，一個 TestClass 可以包含一個或多個 TestMethod，而我們實際要執行測試的內容就是寫在每個 TestMethod 裡，一般大家比較熟知的 3A Principle (<strong>A</strong>rrange-<strong>A</strong>ct-<strong>A</strong>ssert) 可以幫助我們快速聚焦測試方法裡面該撰寫的內容，簡單範例如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">TestClass</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyTestClass</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">TestMethod</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestMethod1</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Arrange: 初始化測試過程中所需要的變數、物件或其他設定。</span></span><br><span class="line">        <span class="built_in">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> b = <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Act: 實際測試操作、內容。</span></span><br><span class="line">        <span class="built_in">int</span> ans = a + b;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Assert: 驗證操作是否產生預期結果。</span></span><br><span class="line">        <span class="built_in">int</span> excepted = <span class="number">3</span>;</span><br><span class="line">        Assert.AreEqual(expected, actual);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="測試組件">測試組件</h2><p>一個 MSTest 專案建置完成後會產生一個組件(Assembly)，白話來說就是 bin 目錄的 dll 檔案，其中可以包含多個 TestClass，而一個 TestClass 裡可以有各自的 TestMethod (層級如下圖)，此外，我們會使用 <strong><code>[TestClass]</code></strong> 和 <strong><code>[TestMethod]</code></strong> 屬性項目在 MSTest 專案標記程式碼中哪些是測試類別與測試方法，下列四種寫法都代表相同的意思：</p><ul><li>[TestClass()]</li><li>[TestClassAttribute()]</li><li>[TestClass]</li><li>[TestClassAttribute]</li></ul><div style="max-width: 800px; text-align:center;"><pre class="mermaid">flowchart LR  subgraph 測試組件 Assembly     subgraph 測試類別 TestClass         subgraph 測試方法 TestMethod             Test1 --> Test2 --> TestN        end    end      end</pre></div><h2 id="生命週期">生命週期</h2><p>當我們實際在撰寫或執行多個測試時，經常需要在不同情境時初始化或清除測試資料，而上述提到的 <strong>組件層級</strong> / <strong>類別層級</strong> / <strong>測試層級</strong> 都提供了 <mark>Initialize</mark> 和 <mark>Cleanup</mark> 屬性讓我們可以在適當的時機會處理對應的邏輯。在下列範例程式中：TestProject1 組件中包含了兩個類別：Calculator(加法、減法運算)，CaculatorTests(測試類別)，在測試類別中撰寫了兩個 TestMethod (Test_AddMethod 和 Test_SubtractMethod)，同時也加上了 Constructor / Dispose、AssemblyInit / AssemblyCleanup、ClassInit / Cleanup、TestInit / TestCleanup，大家應該不難發現，這些函式都是成對的，可以直接參考下列範例程式碼與執行結果，瞭解一個測試組件從開始執行到結束歷經了哪些階段。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Diagnostics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">TestProject1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Calculator</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a + b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Subtract</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a - b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">TestClass</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CalculatorTests</span> : <span class="title">IDisposable</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Calculator calculator;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CalculatorTests</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.WriteLine(<span class="string">&quot;CalculatorTests - Constructor&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在整個測試程序集開始時執行一次</span></span><br><span class="line">        [<span class="meta">AssemblyInitialize</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AssemblyInit</span>(<span class="params">TestContext context</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.WriteLine(<span class="string">&quot;AssemblyInitialize: 測試程序集初始化。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在所有測試執行前初始化，只執行一次</span></span><br><span class="line">        [<span class="meta">ClassInitialize</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ClassInit</span>(<span class="params">TestContext context</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.WriteLine(<span class="string">&quot;ClassInitialize: 初始化 Calculator 類別實例。&quot;</span>);</span><br><span class="line">            calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在每個測試方法執行前調用</span></span><br><span class="line">        [<span class="meta">TestInitialize</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestInit</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.WriteLine(<span class="string">&quot;TestInitialize: 開始執行新的測試。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 測試加法功能</span></span><br><span class="line">        [<span class="meta">TestMethod</span>]</span><br><span class="line">        [<span class="meta">TestCategory(<span class="string">&quot;CalculatorTests&quot;</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test_AddMethod</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.WriteLine(<span class="string">&quot;Test_AddMethod: 測試加法運算。&quot;</span>);</span><br><span class="line">            <span class="built_in">int</span> result = calculator.Add(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">            Assert.AreEqual(<span class="number">8</span>, result, <span class="string">&quot;加法結果不正確&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 測試減法功能</span></span><br><span class="line">        [<span class="meta">TestMethod</span>]</span><br><span class="line">        [<span class="meta">TestCategory(<span class="string">&quot;CalculatorTests&quot;</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test_SubtractMethod</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.WriteLine(<span class="string">&quot;Test_SubtractMethod: 測試減法運算。&quot;</span>);</span><br><span class="line">            <span class="built_in">int</span> result = calculator.Subtract(<span class="number">10</span>, <span class="number">5</span>);</span><br><span class="line">            Assert.AreEqual(<span class="number">5</span>, result, <span class="string">&quot;減法結果不正確&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在每個測試方法執行後調用</span></span><br><span class="line">        [<span class="meta">TestCleanup</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestCleanup</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.WriteLine(<span class="string">&quot;TestCleanup: 測試完成，清理測試上下文。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在所有測試執行完畢後清理，只執行一次</span></span><br><span class="line">        [<span class="meta">ClassCleanup</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ClassCleanup</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.WriteLine(<span class="string">&quot;ClassCleanup: 清理 Calculator 類別實例。&quot;</span>);</span><br><span class="line">            <span class="comment">//calculator = null;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在整個測試程序集結束時執行一次</span></span><br><span class="line">        [<span class="meta">AssemblyCleanup</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AssemblyCleanup</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.WriteLine(<span class="string">&quot;AssemblyCleanup: 測試程序集清理。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.WriteLine(<span class="string">&quot;CalculatorTests - Dispose&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img                         lazyload                       alt="image"                       data-src="/post/2025/04/mstest-attribute-lifecycle/console-run-test.png"                        class=""                 ><h2 id="常用屬性">常用屬性</h2><h3 id="逾時設定-TimeoutAttribute">逾時設定 TimeoutAttribute</h3><p><strong><code>TimeoutAttribute</code></strong> 用於設定測試方法的最大執行時間（以<strong>毫秒</strong>為單位）。如果執行測試超過指定的時間限制，測試則會失敗，這個屬性可以讓我們避免測試執行時間過長，或是為某些測試情境設定一個逾時期限，如下範例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.VisualStudio.TestTools.UnitTesting;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">TestProject1</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">TestClass</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TimeoutExampleTests</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 這個測試會在 500 毫秒內完成，所以它會通過</span></span><br><span class="line">        [<span class="meta">TestMethod</span>]</span><br><span class="line">        [<span class="meta">Timeout(1000)</span>]  <span class="comment">// 設置 1 秒的超時</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestMethod_WithSufficientTime</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Thread.Sleep(<span class="number">500</span>);  <span class="comment">// 模擬較短的處理時間</span></span><br><span class="line">            Assert.AreEqual(<span class="number">4</span>, <span class="number">2</span> + <span class="number">2</span>);  <span class="comment">// 假設這是測試邏輯</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 這個測試會因為超時而失敗</span></span><br><span class="line">        [<span class="meta">TestMethod</span>]</span><br><span class="line">        [<span class="meta">Timeout(1000)</span>]  <span class="comment">// 設置 1 秒的超時</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestMethod_WithTimeout</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Thread.Sleep(<span class="number">1500</span>);  <span class="comment">// 模擬超過1秒的處理時間</span></span><br><span class="line">            Assert.AreEqual(<span class="number">4</span>, <span class="number">2</span> + <span class="number">2</span>);  <span class="comment">// 假設這是測試邏輯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="平行測試-ParallelizeAttribute">平行測試 ParallelizeAttribute</h3><p>自 MSTest v2 起，提供了兩個關於平行測試的屬性：</p><ul><li><strong><code>ParallelizeAttribute</code></strong>：可以應用於類別或測試集來啟用平行測試。</li><li><strong><code>DoNotParallelizeAttribute</code></strong>：可以應用於個別測試方法來<mark>禁止</mark>它與其他測試並行執行。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.VisualStudio.TestTools.UnitTesting;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">TestProject1</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">TestClass</span>]</span><br><span class="line">    [<span class="meta">Parallelize(Workers = 2, Scope = ExecutionScope.MethodLevel)</span>]  <span class="comment">// 啟用並行，指定最多兩個工作線程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ParallelTests</span></span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="meta">TestMethod</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestMethod1</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Thread.Sleep(<span class="number">1000</span>);  <span class="comment">// 模擬工作</span></span><br><span class="line">            Assert.AreEqual(<span class="number">4</span>, <span class="number">2</span> + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">TestMethod</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestMethod2</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Thread.Sleep(<span class="number">1000</span>);  <span class="comment">// 模擬工作</span></span><br><span class="line">            Assert.AreEqual(<span class="number">9</span>, <span class="number">3</span> * <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 禁止這個方法與其他測試並行執行</span></span><br><span class="line">        [<span class="meta">TestMethod</span>]</span><br><span class="line">        [<span class="meta">DoNotParallelize</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestMethod3_DoNotParallelize</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Thread.Sleep(<span class="number">1000</span>);  <span class="comment">// 模擬工作</span></span><br><span class="line">            Assert.AreEqual(<span class="number">15</span>, <span class="number">5</span> * <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>[Parallelize(Workers = 2, Scope = ExecutionScope.MethodLevel)]</code></strong>：<ul><li>Workers = 2 表示最多使用 2 個執行緒來執行平行測試。</li><li>Scope = ExecutionScope.MethodLevel 表示在方法層級平行測試，代表每個測試方法可以平行執行；如果想要在類別層級，可以設定為 ExecutionScope.ClassLevel。</li></ul></li><li>TestMethod1 和 TestMethod2：<br>因為類別層級已經使用 Parallelize 屬性，並且設定 Workers = 2 表示這兩個測試方法會在執行緒池裡平行執行。</li><li>TestMethod3_DoNotParallelize：<br>這個方法加了 <strong><code>[DoNotParallelize]</code></strong>，所以它<mark>不會</mark>與其他方法同時執行，當 TestMethod3_DoNotParallelize 執行時，其他平行測試會暫停，直到這個測試完成。</li></ul><h2 id="後記">後記</h2><p>MSTest 從推出至今已經來到了 v3，從一開始只能在 Windows 平台上運作，隨著 .NET Framework 的演進，也逐步支援跨平台運行，特別是在 .NET Core 和 .NET 5 之後，MSTest 成為了 .NET 生態系中一個可靠且簡單易用的測試框架。它不僅適合快速撰寫單元測試，還能與多種持續整合和部署工具無縫結合，例如：Azure DevOps 和 GitHub Actions。</p><p>由於應用程式複雜度日益提高，MSTest 從 v2 開始也提供了平行測試，允許多個測試同時執行，這不僅加快了測試速度，也提高了 CI/CD 的效能。平行測試使開發人員能夠在不影響測試完整性的前提下，顯著縮短測試週期，對大型專案尤為重要。此外，MSTest 也包含：數據驅動測試、生命週期管理、異常處理測試等，這讓我們能夠更全面地驗證應用程式的功能和效能。</p><p>MSTest 的易用性使得它適合不同規模的專案，加上 Visual Studio 開發工具與 Azure DevOps Services 的支援，不論是小型開發團隊或是大型企業應用，都能輕鬆採用，為軟體開發專案品質把關，也讓整個 DevOps 流程更加完善。</p><div class="tips"><font color="black"><a class="link"   href="https://github.com/microsoft/testfx"  target="_blank">⁍ Microsoft Test Framework<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://learn.microsoft.com/zh-tw/dotnet/core/testing/unit-testing-with-mstest?source=recommendations"  target="_blank">⁍ 使用 MSTest 和 .NET 進行 C# 單元測試<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://learn.microsoft.com/zh-tw/dotnet/core/testing/unit-testing-mstest-writing-tests-attributes"  target="_blank">⁍ MSTest 屬性<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://www.meziantou.net/mstest-v2-setup-a-test-project-and-run-tests.htm"  target="_blank">⁍ MSTest v2: Setup a test project and run tests<i class="fas fa-external-link-alt"></i></a></font></div>]]></content>
    
    
    <summary type="html">&lt;img    
                       lazyload
                       alt=&quot;image&quot;
                       data-src=&quot;/post/2025/04/mstest-attribute-lifecycle/MSTest.png&quot;
                         align=&quot;left&quot; style=&quot;margin-right: 10px; width: 125px; border: 1px solid gray;&quot;
                 &gt; 
&lt;p&gt;在軟體開發過程中，妥善進行測試可以協助我們確保程式碼的功能性與可靠性，不論是最小範圍的&lt;strong&gt;單元測試 (Unit Tests)&lt;/strong&gt; 或是模擬實際用戶的&lt;strong&gt;端對端測試(E2E Tests)&lt;/strong&gt;，都是品質把關的重要防線，而 MSTest 除了被整合在 Visual Studio 中，簡化了 .NET 應用程式建立和執行單元測試的過程，也可以透過 Azure Pipelines 將既有的測試專案整合到 CI 流程裡，這篇主要帶大家瞭解 MSTest 生命週期以及常用屬性，以便大家更能掌握自己的測試流程。&lt;/p&gt;</summary>
    
    
    
    
    <category term="MSTest" scheme="https://timlai.dev/tags/MSTest/"/>
    
  </entry>
  
  <entry>
    <title>使用 VB5/VB6 連線至 Azure DevOps Server 2022 (TFVC)</title>
    <link href="https://timlai.dev/post/2025/04/vb-connect-to-azure-devops/"/>
    <id>https://timlai.dev/post/2025/04/vb-connect-to-azure-devops/</id>
    <published>2025-04-17T02:45:13.000Z</published>
    <updated>2025-05-28T06:09:20.805Z</updated>
    
    <content type="html"><![CDATA[<img                           lazyload                       alt="image"                       data-src="/post/2025/04/vb-connect-to-azure-devops/VS_TFS.png"                         align="left" style="margin-right: 10px; width: 125px; border: 1px solid gray;"                 > <p>Visual Studio 從 97 發展到現在的 2022 號稱地表最強開發工具，能夠與 TFS 或 Git 版控連線自然不是問題，最近剛好遇到客戶還有許多 VB5/VB6 開發的 Winform 程式需要維護，而且版控伺服器也從 TFS 2013 升級至 Azure DevOps Server 2022，藉此機會向大家整理說明 Visual Studio 各版本與 TFS / Azure DevOps 連線的需求與設定。<br><br></p><span id="more"></span><br><h2 id="前言">前言</h2><p>我們使用 Visual Studio 開發工具能夠與 TFS 連線是因為它的功能包含了 <strong><code>Team Explorer</code></strong>，明確來說是從 Visual Studio 2005 首次引入 TFS (Team Foundation Server) 起才開始包含此功能，在這個版本之前則需要額外安裝 <strong>Team Explorer</strong> 和 <strong>MSSCCI Provider</strong> (Microsoft Source Code Control Integration) 才能夠在開發工具中與 TFS 進行整合。</p><h2 id="版本相依性">版本相依性</h2><p>作業系統、開發工具與版控伺服器彼此間有一定的版本相依性，Windows XP 無法安裝 Team Explorer 2013，只能安裝 Team Explorer 2010，搭配 MSSCCI Provider 2010 可以連線的版本有：TFS 2005 ~ 2018 和 Azure DevOps Server 2019/2020 <mark>(不包含2022)</mark>，若舊開發環境 (Visual Studio 2013 以前) 想要與 Azure DevOps Server 2022 連線，必要最低門檻可以參考下列配置：</p><ul><li><strong>Windows 7 以上</strong></li><li><strong>Team Explorer 2013</strong></li><li><strong>MSSCCI Provider 2013</strong></li></ul><p>Visual Studio 97/6/2003~2008 搭配 Team Explorer 2010 + MSSCCI Provider 2010 可以從開發工具連線至 TFS 2010~2017 和 Azure DevOps Server 2019/2020，若要連線至 Azure DevOps Server 2022 則需要搭配 Team Explorer 2013 + MSSCCI Provider 2013 才行，各版本 MSSCCI Provider 可以自 Visual Studio | Marketplace 取得：</p><div class="tips"><font color="black"><a class="link"   href="https://marketplace.visualstudio.com/items?itemName=TFSPowerToolsTeam.MicrosoftVisualStudioTeamFoundationServer2010MSSCC"  target="_blank">⁍ Microsoft Visual Studio Team Foundation Server 2010 MSSCCI Provider 32-bit<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://marketplace.visualstudio.com/items?itemName=TFSPowerToolsTeam.MicrosoftVisualStudioTeamFoundationServer2012MSSCC"  target="_blank">⁍ Microsoft Visual Studio Team Foundation Server 2012 MSSCCI Provider 32-bit<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://marketplace.visualstudio.com/items?itemName=TFSPowerToolsTeam.MicrosoftVisualStudioTeamFoundationServer20132015M"  target="_blank">⁍ Microsoft Visual Studio Team Foundation Server 2013&2015 MSSCCI Provider 32-bit<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://marketplace.visualstudio.com/items?itemName=TFSPowerToolsTeam.TeamFoundationServerMSSCCIProvider201064-bit"  target="_blank">⁍ Team Foundation Server MSSCCI Provider 2010 64-bit<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://marketplace.visualstudio.com/items?itemName=TFSPowerToolsTeam.MicrosoftVisualStudioTeamFoundationServer2012MSSCC-9956"  target="_blank">⁍ Microsoft Visual Studio Team Foundation Server 2012 MSSCCI Provider 64-bit<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://marketplace.visualstudio.com/items?itemName=TFSPowerToolsTeam.MicrosoftVisualStudioTeamFoundationServer20132015M-11387"  target="_blank">⁍ Microsoft Visual Studio Team Foundation Server 2013&2015 MSSCCI Provider 64-bit<i class="fas fa-external-link-alt"></i></a><br></font></div><h2 id="VB5-VB6">VB5/VB6</h2><p>在 VB5/VB6 的工具列需要額外安裝上述提到的 MSSCCI Provider 2010/2013 才會出現 <strong>Team Foundation</strong> 選項，讓我們在開發工具中將程式碼與版控伺服器整合。</p><img                         lazyload                       alt="image"                       data-src="/post/2025/04/vb-connect-to-azure-devops/create-project-from-tfs.png"                        class=""                 ><p>若出現下列錯誤訊息，就是 MSSCCI Provider 版本太舊了，無法連線到新的版控伺服器，例如：安裝 MSSCCI Provider 2010 但想要與 Azure DevOps Server 2022 連線，唯一解法就是安裝 Team Explorer 2013 + MSSCCI Provider 2013。</p><blockquote><p>TF14045: The identity 主機名稱\2ffd15ae-91e4-4df8-a346-e5be57e1340e is not a recognized identity.</p></blockquote><img                         lazyload                       alt="image"                       data-src="/post/2025/04/vb-connect-to-azure-devops/not-a-recognized-identity.png"                        class=""                 ><p>在實務情境可能還會遇到其他各種版本組合，經此次嘗試後，確認 VB5/VB6 都還可以與 Azure DevOps Server 2022 的 TFVC 版控進行整合，這邊有篇文章將各種組合條列得很詳盡，也提供大家參考。</p><div class="tips"><font color="black"><a class="link"   href="https://jessehouwing.net/azure-devops-connect-any-visual-studio-version/"  target="_blank">⁍ Connect any version of Visual Studio to Azure DevOps or Azure DevOps Server<i class="fas fa-external-link-alt"></i></a><br></font></div>]]></content>
    
    
    <summary type="html">&lt;img    
                       lazyload
                       alt=&quot;image&quot;
                       data-src=&quot;/post/2025/04/vb-connect-to-azure-devops/VS_TFS.png&quot;
                         align=&quot;left&quot; style=&quot;margin-right: 10px; width: 125px; border: 1px solid gray;&quot;
                 &gt; 
&lt;p&gt;Visual Studio 從 97 發展到現在的 2022 號稱地表最強開發工具，能夠與 TFS 或 Git 版控連線自然不是問題，最近剛好遇到客戶還有許多 VB5/VB6 開發的 Winform 程式需要維護，而且版控伺服器也從 TFS 2013 升級至 Azure DevOps Server 2022，藉此機會向大家整理說明 Visual Studio 各版本與 TFS / Azure DevOps 連線的需求與設定。&lt;br&gt;
&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="VB5" scheme="https://timlai.dev/tags/VB5/"/>
    
    <category term="VB6" scheme="https://timlai.dev/tags/VB6/"/>
    
    <category term="TFS" scheme="https://timlai.dev/tags/TFS/"/>
    
    <category term="Team Explorer" scheme="https://timlai.dev/tags/Team-Explorer/"/>
    
    <category term="MSSCCI Provider" scheme="https://timlai.dev/tags/MSSCCI-Provider/"/>
    
  </entry>
  
  <entry>
    <title>使用 Azure DevOps REST API 建立專案</title>
    <link href="https://timlai.dev/post/2025/04/azure-devops-create-project/"/>
    <id>https://timlai.dev/post/2025/04/azure-devops-create-project/</id>
    <published>2025-04-13T01:30:58.000Z</published>
    <updated>2025-05-28T06:09:20.807Z</updated>
    
    <content type="html"><![CDATA[<img                           lazyload                       alt="image"                       data-src="/post/2025/04/azure-devops-create-project/create-project.png"                         align="left" style="margin-right: 10px; width: 125px; border: 1px solid gray;"                 > <p>要使用 Azure DevOps 各項功能之前，首先得先建立一個專案，同時必須選擇專案的版本控制是 <strong>TFVC</strong> (Team Fundation Version Control) 還是 <strong>git</strong>，以及專案要使用的流程範本 (Process template)，預設有 <strong>Basic / Agile / Scrum / CMMI</strong> 四種，這次我們就不透過網頁介面建立專案，直接使用 API 小試身手 🎣 。</p><br><span id="more"></span><br><h2 id="前言">前言</h2><p>當我們想要使用 <strong>Azure DevOps REST API</strong> 進行程式串接時，首先要確認使用情境是 <strong><code>雲端</code></strong> 還是 <strong><code>地端</code></strong>，因為兩者對於 API 的支援程度不盡相同，例如：<strong>Audit log</strong> 目前只有在雲端才能查詢、下載，地端還沒有支援，使用哪一版的 API 也要稍微留意(在<a href="/post/2024/09/azure-devops-rest-api">上一篇文章</a>有說明原因)，這些都可以在 API 說明頁面左上角透過下拉選單來快速切換檢視，以便我們確認 API 規格與差異。</p><img                         lazyload                       alt="image"                       data-src="/post/2025/04/azure-devops-create-project/version_dropdown.png"                        class=""                 ><br><div class="tips"><font color="black"><a class="link"   href="https://learn.microsoft.com/en-us/rest/api/azure/devops/?view=azure-devops-rest-7.2"  target="_blank">⁍ Azure DevOps Services REST API Reference<i class="fas fa-external-link-alt"></i></a></font></div><br><h2 id="API-規格確認">API 規格確認</h2><p>經由上面的參考連結，我們可以在 <strong>Core &gt; Projects &gt; Create</strong> 找到建立專案的 API 規格：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">雲端</span><br><span class="line">POST https://dev.azure.com/&#123;organization&#125;/_apis/projects?api-version=7.2-preview.4</span><br></pre></td></tr></table></figure><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">地端</span><br><span class="line">POST https://&#123;instance&#125;/&#123;collection&#125;/_apis/projects?api-version=7.0</span><br></pre></td></tr></table></figure><img                         lazyload                       alt="image"                       data-src="/post/2025/04/azure-devops-create-project/core_projects_create.png"                        class=""                 ><br><p>在頁面上對於 Request Body 的屬性和型別宣告都會逐一說明，但唯一美中不足的是我們看不出來哪些屬性是必要項目(Required)，比較簡便的方式是可以使用 Postman 填入 PAT 驗證後進行測試，通常在 Reponse 都會告訴我們缺少什麼必要欄位值，Postman 設定步驟如下：</p><br><ol><li>Authorization 的 Auth Type 選擇 <strong><code>Basic Auth</code></strong>，並將 PAT 填入 Password 欄位，Username 空白即可。(如何建立 PAT 可以參考：<a href="/post/2024/09/azure-devops-rest-api">上一篇文章</a>)</li></ol><img                         lazyload                       alt="image"                       data-src="/post/2025/04/azure-devops-create-project/basic_auth.png"                        class=""                 ><br><ol start="2"><li>Headers 的 Content-Type 設定 <strong><code>application/json</code></strong>。</li></ol><img                         lazyload                       alt="image"                       data-src="/post/2025/04/azure-devops-create-project/content_type.png"                        class=""                 ><br><ol start="3"><li>Body 格式選擇 <strong><code>raw</code></strong> 和 <strong><code>JSON</code></strong>，內容先輸入 <strong><code>&#123;&#125;</code></strong> 然後按下 <strong><code>Send</code></strong> 按鈕。</li></ol><img                         lazyload                       alt="image"                       data-src="/post/2025/04/azure-devops-create-project/400_bad.png"                        class=""                 ><br><p>由 message 回傳的資訊我們就可以得知，必要的屬性有：</p><ul><li><strong>name</strong> : 專案名稱</li><li><strong>description</strong>: 專案描述說明</li><li><strong>visibility</strong> : 專案可層級 (Public或Private，預設是Private)</li><li><strong>capabilities</strong> : 版控方式、流程範本是必要項目。</li></ul><p>完整的 Request Body 內容可以參考下列內容：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;MyNewProject&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;This is a new project created via API&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;capabilities&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;versioncontrol&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;sourceControlType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Git&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;processTemplate&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;templateTypeId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;6b724908-ef14-45cf-84f8-768b5384da45&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><br><p>送出 Request 成功後，可以得到如下訊息：</p><img                         lazyload                       alt="image"                       data-src="/post/2025/04/azure-devops-create-project/202_accepted.png"                        class=""                 ><br><p>開啟 Azure DevOps 畫面確認新增的專案是否有正常出現。</p><img                         lazyload                       alt="image"                       data-src="/post/2025/04/azure-devops-create-project/my_new_project.png"                        class=""                 ><h2 id="流程範本-Process-template">流程範本 (Process template)</h2><p>在 Azure DevOps 預設有 <strong>Basic / Agile / Scrum / CMMI</strong> 四種流程範本，一般我本幾乎不會去關心它的 templateTypeId (GUID) 是什麼，這邊需要透過另一支查詢 Process template 列表的 API 來取得資訊：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">雲端</span><br><span class="line">GET GET https://dev.azure.com/&#123;organization&#125;/_apis/process/processes?api-version=7.2-preview.1</span><br></pre></td></tr></table></figure><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">地端</span><br><span class="line">GET https://&#123;instance&#125;/&#123;collection&#125;/_apis/process/processes?api-version=7.0</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;count&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;adcc42ab-9882-485e-a3ed-7678f01f66bc&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;This template is flexible and will work great for most teams using Agile planning methods, including those practicing Scrum.&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;system&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://devopssrv/DefaultCollection/_apis/process/processes/adcc42ab-9882-485e-a3ed-7678f01f66bc&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Agile&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;27450541-8e31-4150-9947-dc59f998fc01&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;This template is for more formal projects requiring a framework for process improvement and an auditable record of decisions.&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;system&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://devopssrv/DefaultCollection/_apis/process/processes/27450541-8e31-4150-9947-dc59f998fc01&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;CMMI&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;b8a3a935-7e91-48b8-a94c-606d37c3e9f2&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;This template is flexible for any process and great for teams getting started with Azure DevOps.&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;system&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://devopssrv/DefaultCollection/_apis/process/processes/b8a3a935-7e91-48b8-a94c-606d37c3e9f2&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Basic&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;6b724908-ef14-45cf-84f8-768b5384da45&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;This template is for teams who follow the Scrum framework.&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;system&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://devopssrv/DefaultCollection/_apis/process/processes/6b724908-ef14-45cf-84f8-768b5384da45&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Scrum&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="後記">後記</h2><p>再回過頭來看，其實我們上面做的這些動作就是以 API 的方式送出畫面上建立專案的必要欄位而已：</p><img                         lazyload                       alt="image"                       data-src="/post/2025/04/azure-devops-create-project/new_project.png"                        class=""                 ><br><p>附帶一提，若是以 C# 實作，在 Header 傳遞 PAT 需要先以 <strong>Base64</strong> 編碼才行，可以參考下列完整範例呼叫範例(第31行)：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Net.Http;</span><br><span class="line"><span class="keyword">using</span> System.Net.Http.Headers;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> Newtonsoft.Json;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProcessTemplate</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProcessTemplatesResponse</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> List&lt;ProcessTemplate&gt; Value &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">string</span> pat = <span class="string">&quot;...&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> serverName = <span class="string">&quot;...&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> collectionName = <span class="string">&quot;...&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> url = <span class="string">$&quot;http://<span class="subst">&#123;serverName&#125;</span>/<span class="subst">&#123;collectionName&#125;</span>/_apis/process/processes?api-version=7.0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> (HttpClient client = <span class="keyword">new</span> HttpClient())</span><br><span class="line">&#123;</span><br><span class="line">client.DefaultRequestHeaders.Authorization = <span class="keyword">new</span> AuthenticationHeaderValue(<span class="string">&quot;Basic&quot;</span>, Convert.ToBase64String(Encoding.ASCII.GetBytes(<span class="string">$&quot;:<span class="subst">&#123;pat&#125;</span>&quot;</span>)));</span><br><span class="line">HttpResponseMessage response = <span class="keyword">await</span> client.GetAsync(url);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (response.IsSuccessStatusCode)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">string</span> result = <span class="keyword">await</span> response.Content.ReadAsStringAsync();</span><br><span class="line"><span class="keyword">var</span> processTemplates = JsonConvert.DeserializeObject&lt;ProcessTemplatesResponse&gt;(result);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> process <span class="keyword">in</span> processTemplates.Value)</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;Name: <span class="subst">&#123;process.Name&#125;</span>, ID: <span class="subst">&#123;process.Id&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;Failed to get process templates: <span class="subst">&#123;response.StatusCode&#125;</span>&quot;</span>);</span><br><span class="line"><span class="built_in">string</span> error = <span class="keyword">await</span> response.Content.ReadAsStringAsync();</span><br><span class="line">Console.WriteLine(error);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><div class="tips"><font color="black"><a class="link"   href="https://learn.microsoft.com/zh-tw/azure/devops/integrate/how-to/call-rest-api?view=azure-devops"  target="_blank">⁍ 開始使用 REST API<i class="fas fa-external-link-alt"></i></a></font></div>]]></content>
    
    
    <summary type="html">&lt;img    
                       lazyload
                       alt=&quot;image&quot;
                       data-src=&quot;/post/2025/04/azure-devops-create-project/create-project.png&quot;
                         align=&quot;left&quot; style=&quot;margin-right: 10px; width: 125px; border: 1px solid gray;&quot;
                 &gt; 
&lt;p&gt;要使用 Azure DevOps 各項功能之前，首先得先建立一個專案，同時必須選擇專案的版本控制是 &lt;strong&gt;TFVC&lt;/strong&gt; (Team Fundation Version Control) 還是 &lt;strong&gt;git&lt;/strong&gt;，以及專案要使用的流程範本 (Process template)，預設有 &lt;strong&gt;Basic / Agile / Scrum / CMMI&lt;/strong&gt; 四種，這次我們就不透過網頁介面建立專案，直接使用 API 小試身手 🎣 。&lt;/p&gt;
&lt;br&gt;</summary>
    
    
    
    
    <category term="Azure DevOps" scheme="https://timlai.dev/tags/Azure-DevOps/"/>
    
    <category term="Azure DevOps REST API" scheme="https://timlai.dev/tags/Azure-DevOps-REST-API/"/>
    
  </entry>
  
  <entry>
    <title>Azure DevOps REST API 說明</title>
    <link href="https://timlai.dev/post/2025/04/azure-devops-rest-api/"/>
    <id>https://timlai.dev/post/2025/04/azure-devops-rest-api/</id>
    <published>2025-04-10T02:38:44.000Z</published>
    <updated>2025-05-28T06:09:20.807Z</updated>
    
    <content type="html"><![CDATA[<img                           lazyload                       alt="image"                       data-src="/post/2025/04/azure-devops-rest-api/rest_api.jpg"                         align="left" style="margin-right: 10px; width: 125px; border: 1px solid gray;"                 > <p>當我們要自行擴充或串接 Azure DevOps Services / Server 功能時，可以透過 Azure DevOps REST API 來進行客制開發，例如：想要寫一支程式每天發送各專案在版控儲存庫的差異紀錄，或是想要在公司內部表單系統審核後，觸發執行指定的 pipeline … 族繁不及備載，使用 REST API 透過 HTTP 呼叫的好處是可以不用侷限於特定的程式語言，也方便用 Postman 之類的工具測試，這篇整理了呼叫 Azure DevOps REST API 的前置作業與相關說明，方便大家上手😁。</p><span id="more"></span><br><h2 id="REST-API">REST API</h2><p>使用 Azure DevOps REST API 時，其 URI 規格如下：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VERB https://&#123;instance&#125;/&#123;organization&#125;/&#123;project&#125;/_apis/&#123;area&#125;/&#123;resource&#125;?api-version=&#123;version&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>VERB</strong><br>與一般 RESTful API 相同，在串接 Azure DevOps 各種情境時， <strong><font color='green'>GET</font></strong> / <strong><font color='brown'>POST</font></strong> / <strong><font color='red'>DELETE</font></strong> / <strong><font color='purple'>PATCH</font></strong> 都有機會用到。</li><li><strong>instance</strong><br>如果是使用雲端的 Azure DevOps Services 指的就是 <span>dev.azure.com</span>，地端則是 Azure DevOps Server 所在的位址。</li><li><strong>organization/project</strong><br>取決於 API 作用的範圍，在 URI 裡會有 organization 或 organization/project，例如：使用 API 建立個人權杖 (PAT)，則會是：<br><strong><font color='brown'>POST</font></strong> https://vssps.dev.azure.com/<mark>{organization}</mark>/_apis/tokens/pats?api-version=7.2<br>或者像是用 API 建立一個工作項目，則是：<br><strong><font color='brown'>POST</font></strong> https://dev.azure.com/<mark>{organization}/{project}</mark>/_apis/wit/workitems/${type}?api-version=7.2</li><li><strong>{area}/{resource}</strong><br>從這邊大概可以看出呼叫的 API 是做哪方面的操作，以上面兩個例子 (建立 PAT、建立 Work item) 來說：<br><strong><font color='brown'>POST</font></strong> https://vssps.dev.azure.com/{organization}/_apis/<mark>tokens/pats</mark>?api-version=7.2<br><strong><font color='brown'>POST</font></strong> https://dev.azure.com/{organization}/{project}/_apis/<mark>wit/workitems/${type}</mark>?api-version=7.2</li><li><strong>version</strong><br>通常我們在串接 API 時會明確指定 version，因為每個 TFS / Azure DevOps 版本對於 API 支援的 api-version 也有所不同 (如下表)，如果不指定 api-version 則會自動選用目前產品最新的穩定版本，例如：在 Azure DevOps Server 2019 它會自動取用 5.0 來執行，在不加 api-version 的情況下，若日後升級到 Azure DevOps Server 2022，則會自動取用 7.0 來執行，為維持串接程式正常運作，不會因為 API 版本差異而造成異常，一般我們都會加上指定的 api-version 版號。</li></ul><blockquote><p>提醒大家：<br>如果是使用 preview 版本 (例如：<strong><code>7.2-preview.3</code></strong>)，該 preview 版本會在 <strong>12 週</strong> 後停用，被穩定的正式版本取代。</p></blockquote><table><thead><tr><th>Products</th><th style="text-align:center">1.0</th><th style="text-align:center">2.0</th><th style="text-align:center">3.0</th><th style="text-align:center">4.0</th><th style="text-align:center">5.0</th><th style="text-align:center">6.0</th><th style="text-align:center">7.0</th></tr></thead><tbody><tr><td>Azure DevOps Services</td><td style="text-align:center">V</td><td style="text-align:center">V</td><td style="text-align:center">V</td><td style="text-align:center">V</td><td style="text-align:center">V</td><td style="text-align:center">V</td><td style="text-align:center">V</td></tr><tr><td>Azure DevOps Server 2022</td><td style="text-align:center">V</td><td style="text-align:center">V</td><td style="text-align:center">V</td><td style="text-align:center">V</td><td style="text-align:center">V</td><td style="text-align:center">V</td><td style="text-align:center">V</td></tr><tr><td>Azure DevOps Server 2020</td><td style="text-align:center">V</td><td style="text-align:center">V</td><td style="text-align:center">V</td><td style="text-align:center">V</td><td style="text-align:center">V</td><td style="text-align:center">V</td><td style="text-align:center">-</td></tr><tr><td>Azure DevOps Server 2019</td><td style="text-align:center">V</td><td style="text-align:center">V</td><td style="text-align:center">V</td><td style="text-align:center">V</td><td style="text-align:center">V</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td>Team Foundation Server 2018</td><td style="text-align:center">V</td><td style="text-align:center">V</td><td style="text-align:center">V</td><td style="text-align:center">V</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td>Team Foundation Server 2017</td><td style="text-align:center">V</td><td style="text-align:center">V</td><td style="text-align:center">V</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td>Team Foundation Server 2015</td><td style="text-align:center">V</td><td style="text-align:center">V</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr></tbody></table><h2 id="PAT-Personal-Access-Token">PAT (Personal Access Token)</h2><p>要使用 Azure DevOps REST API 存取資源前都必需先經過驗證成功才行，建立 <strong><code>個人存取權杖 (PAT)</code></strong> 可以算是安全又簡便的方式，若想要實作 OAuth 2.0 或其他頁面驗證方式，可以參考下列連結：</p><div class="tips"><font color="black"><a class="link"   href="https://learn.microsoft.com/zh-tw/azure/devops/integrate/get-started/authentication/authentication-guidance?toc=%2Fazure%2Fdevops%2Fmarketplace-extensibility%2Ftoc.json&view=azure-devops"  target="_blank">⁍ 選擇正確的驗證機制<i class="fas fa-external-link-alt"></i></a></font></div><p>要建立一個 PAT 可以從 Azure DevOps 畫面右上角 <strong><code>User settings</code></strong> → <strong><code>Personal access tokens</code></strong> 進入。</p><img                         lazyload                       alt="image"                       data-src="/post/2025/04/azure-devops-rest-api/pat.png"                        class=""                 ><br><p>點選 <strong><code>+ New Token</code></strong> 按鈕。</p><img                         lazyload                       alt="image"                       data-src="/post/2025/04/azure-devops-rest-api/pat_1.png"                        class=""                 ><br><p>接著就是 PAT 存取期限、授權範圍等相關設定：</p><ul><li><strong>Organization</strong><br>選擇 <strong>特定的 Organization</strong> 或 <strong>All accessible organizations</strong> (允許存取全部組織)。</li><li><strong>Expiration (UTC)</strong><br>有效期限可以選擇 <strong>30 / 60 / 90 天</strong>，或是 <strong>Custom defined</strong> (<mark>最長只能一年</mark>)</li><li><strong>Scopes</strong><br>可以選擇 <strong>Full access</strong> (允許存取全部範圍) 或 <strong>Custom defined</strong> 針對各個功能進一步設定，基於最低權限原則，建議大家可以有意義的命名 token 名稱，並且只勾選必要的 <strong>Scopes</strong> 授權範圍。</li></ul><p>建立 PAT 後，僅能 <strong><code>Revoke</code></strong> (撤銷) 或是 <strong><code>Regenerate</code></strong> (重新產生)，沒有辦法再用任何方式檢視原本產生的 token 內容，大家記得要妥善保存。</p><img                         lazyload                       alt="image"                       data-src="/post/2025/04/azure-devops-rest-api/pat_2.png"                        class=""                 ><h2 id="NET-Client-Library">.NET Client Library</h2><p>如果是使用 .NET 進行程式開發，還有一個選擇是從 NuGet.org 下載 Client library 使用，套件相依關係如下圖。</p><img                         lazyload                       alt="image"                       data-src="/post/2025/04/azure-devops-rest-api/dotnet-client-libraries-dependancy-diagram.jpg"                        class=""                 ><br><p>最新版本可以由 NuGet.org 查詢結果找到： https://www.nuget.org/packages?q=azure+devops+.net ，套件和 Azure DevOps 版本一樣有相依性， 使用前要留意一下目前環境的 TFS / Azure DevOps Server 版本，例如：Azure DevOps Server 2019 只能使用到套件 16.143.x 版。</p><table><thead><tr><th>套件版本</th><th>Azure DevOps 版本</th></tr></thead><tbody><tr><td>16.205.x</td><td>versions &gt;= Azure DevOps Server 2022</td></tr><tr><td>16.170.x</td><td>versions &gt;= Azure DevOps Server 2020</td></tr><tr><td>16.153.x</td><td>versions &gt;= Azure DevOps Server 2019 Update 1</td></tr><tr><td>16.143.x</td><td>versions &gt;= Azure DevOps Server 2019</td></tr><tr><td>15.131.x</td><td>versions &gt;= TFS 2018 Update 1</td></tr><tr><td>15.112.x</td><td>versions &gt;= TFS 2017 Update 1</td></tr><tr><td>14.102.x</td><td>versions &gt;= TFS 2015 Update 3</td></tr><tr><td>14.95.x</td><td>versions &gt;= TFS 2015 Update 2</td></tr><tr><td>14.89.x</td><td>versions &gt;= TFS 2015 Update 1</td></tr><tr><td>14.83.x</td><td>versions &gt;= TFS 2015</td></tr></tbody></table><p>在實務開發上還是得花些時間先瞭解套件定義了哪些 class、提供了什麼 function，這部份可以參考官方說明和 github sample code，如果有特殊需求或環境考量需要使用的話，可以參考下列連結：</p><div class="tips"><font color="black"><a class="link"   href="https://learn.microsoft.com/zh-tw/azure/devops/integrate/concepts/dotnet-client-libraries?view=azure-devops&viewFallbackFrom=vsts"  target="_blank">⁍ .NET 用戶端程式庫<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://learn.microsoft.com/zh-tw/azure/devops/integrate/get-started/client-libraries/samples?view=azure-devops"  target="_blank">⁍ C# 用戶端連結庫範例<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://github.com/microsoft/azure-devops-dotnet-samples"  target="_blank">⁍ .NET samples for Azure DevOps<i class="fas fa-external-link-alt"></i></a></font></div><p>(💁 看完上面連結內容有沒有覺得還是使用 REST API 比較方便 💖)</p>]]></content>
    
    
    <summary type="html">&lt;img    
                       lazyload
                       alt=&quot;image&quot;
                       data-src=&quot;/post/2025/04/azure-devops-rest-api/rest_api.jpg&quot;
                         align=&quot;left&quot; style=&quot;margin-right: 10px; width: 125px; border: 1px solid gray;&quot;
                 &gt; 
&lt;p&gt;當我們要自行擴充或串接 Azure DevOps Services / Server 功能時，可以透過 Azure DevOps REST API 來進行客制開發，例如：想要寫一支程式每天發送各專案在版控儲存庫的差異紀錄，或是想要在公司內部表單系統審核後，觸發執行指定的 pipeline … 族繁不及備載，使用 REST API 透過 HTTP 呼叫的好處是可以不用侷限於特定的程式語言，也方便用 Postman 之類的工具測試，這篇整理了呼叫 Azure DevOps REST API 的前置作業與相關說明，方便大家上手😁。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Azure DevOps" scheme="https://timlai.dev/tags/Azure-DevOps/"/>
    
    <category term="Azure DevOps REST API" scheme="https://timlai.dev/tags/Azure-DevOps-REST-API/"/>
    
    <category term="PAT" scheme="https://timlai.dev/tags/PAT/"/>
    
    <category term=".NET Client Library" scheme="https://timlai.dev/tags/NET-Client-Library/"/>
    
  </entry>
  
  <entry>
    <title>Azure DevOps Services 個別服務</title>
    <link href="https://timlai.dev/post/2025/04/azure-devops-individual-services/"/>
    <id>https://timlai.dev/post/2025/04/azure-devops-individual-services/</id>
    <published>2025-04-06T13:02:38.000Z</published>
    <updated>2025-05-28T06:09:20.807Z</updated>
    
    <content type="html"><![CDATA[<img                           lazyload                       alt="image"                       data-src="/post/2025/04/azure-devops-individual-services/individual_services.jpg"                         align="left" style="margin-right: 10px; width: 125px; border: 1px solid gray;"                 > <p><a href="/post/2024/09/azure-devops-licensing-description">上一篇文章</a>提到了 Azure DevOps 雲端和地端的使用者授權，當我們建立私有專案 (Private project) 且成員數量在 5 個人以下時，甚至可以直接免費使用，從第 6 個人起才需要計價，並具有 1 Free Microsoft-hosted CI/CD 和 1 Free Self-hosted CI/CD 以及 Azure Artifacts 2GB 可用儲存容量。在實務使用情境較複雜時，很有可能就需要再增加個別服務的用量 (例如：Azure Pipelines 平行作業數量)，這次就帶大家瞭解這些個別服務計價的方式。</p><span id="more"></span><br><h2 id="Azure-Pipelines">Azure Pipelines</h2><p>不論我們在 Azure Pipelines 使用文字介面或是圖形介面 (classic editor) 建立 pipeline 腳本內容，其中有個 <strong><code>Agent pools</code></strong> 選項是必要設定，它是用來決定執行階段要把工作 (job) 傳遞到哪個 pool 裡，尋找閒置且符合條件的 <strong>Azure Pipelines agents</strong> 執行個體來執行腳本內容，在 Azure DevOps Services 預設有一個 Microsoft-hosted agent 每個月可以免費使用 1800 分鐘，<mark>但預設無法直接使用</mark>，需要填寫 <strong><a class="link"   href="https://aka.ms/azpipelines-parallelism-request" >Azure DevOps Parallelism Request<i class="fas fa-external-link-alt"></i></a></strong> 表單申請審核通過才行，否則在執行的時候會出現如下錯誤：</p><img                         lazyload                       alt="image"                       data-src="/post/2025/04/azure-devops-individual-services/azpipelines-parallelism-request.jpg"                        class=""                 ><p>當然我們也可以自己準備機器，在上面安裝 Azure Pipelines agents 程式 (支援 Windows / Linux / macOS)，這就屬於 Self-hosted agent。由於是自己準備的執行個體，所以使用時數不受限制，但每個工作 (job) 都是經由佇列 (queue) 的方式排隊一個一個執行，若需要同時間處理一個以上的工作 (job)，則需要再增加執行個體才行 (不論是 Microsoft-hosted 或是 Self-hosted)，基於這樣的概念，以下就是我們所關心的計價標準：</p><ul><li>每一個 Microsoft-hosted 每個月有 1800 分鐘可以使用。</li><li>每增加一個額外的 Microsoft-hosted CI/CD 每個月是 USD $40 (大約 <strong>TWD $1279</strong>)。</li><li>每增加一個額外的 Self-hosted CI/CD 每個月是 USD $15 (大約 <strong>TWD $479</strong>)。</li><li><mark>如果在地端自建 Azure DevOps Server 則僅能使用 Self-hosted agent，需要更多的平行作業就自己多準備幾個執行個體，不用再額外採購什麼授權。</mark></li></ul><h2 id="Azure-Artifacts">Azure Artifacts</h2><p>在軟體專案開發過程中，多少都會用到一些公司內部自行開發，或是外部來源提供的套件，一般常見的套件來源像是：NuGet、npm、Maven、Python…等，Azure Artifacts 可以將這些外部提供來源設為上游來源 (Upstream sources)，或是自己建立一個套件提供來源 (Feeds)，讓專案團隊成員在內部環境取用，儲存容量在 2GB 以內是免費，若超過則依下列區間以量計價：</p><table><thead><tr><th>儲存容量</th><th>每GB (USD)</th><th>每GB (TWD)</th></tr></thead><tbody><tr><td>0 - 2 GB</td><td>免費</td><td>免費</td></tr><tr><td>2 - 10 GB</td><td>$2</td><td>大約 $63.98</td></tr><tr><td>10 - 100 GB</td><td>$1</td><td>大約 $31.99</td></tr><tr><td>100 - 1000 GB</td><td>$0.50</td><td>大約 $16.00</td></tr><tr><td>1000 GB 以上</td><td>$0.25</td><td>大約 NT$8.00</td></tr></tbody></table><h2 id="GitHub-Advanced-Security-for-Azure-DevOps">GitHub Advanced Security for Azure DevOps</h2><p>以往我們想要對專案程式碼執行原碼檢測、套件掃描等作業，首先要考量的可能是產品的價錢，或是委外檢測的費用，比較克難一點還可以尋找免費的掃描檢測工具(例如只是想要出個報告 🙈 🙊)，若想要整合到 CI 流程裡，還要得額外花一番功夫，但基本上只要可以透過 command line 來執行，都是可以用 Azure Pipelines 整合起來的。而自從 <strong>GitHub Advanced Security for Azure DevOps</strong> 正式啟用後，省掉了這部份不少麻煩，除了原生的與 Azure DevOps Services 整合 <mark>(不包含地端 Azure DevOps Server)</mark>，也可以與 <strong>Microsoft Defender for Cloud</strong> 串接，它可以做到：</p><ul><li><strong>Code Scanning</strong>：找出原始程式碼中的漏洞並提供修復指導。</li><li><strong>Secret Scanning</strong>：識別 secret 並阻止開發人員將 secret 推送到程式碼儲存庫。</li><li><strong>Dependency Scanning</strong>：發現 open-source 依賴項目的漏洞，並為開發人員自動發出更新警報。</li></ul><p>在 Azure Pipelines 也提供了下列對應的 task 以便我們完善整個 <strong><code>DevSecOps</code></strong> 流程：</p><img                         lazyload                       alt="image"                       data-src="/post/2025/04/azure-devops-individual-services/github_acvanced_security.jpg"                        class=""                 ><p>這個功能可以由每個 git 的儲存庫 (repositry) 個別設定是否啟用 (不支援 TFVC 版控)，計價的原則是：每一個活躍的提交者 (active committer) 每個月 <strong>USD $49</strong> (大約 <strong>TWD $1567</strong>)，在<mark>同一個 Azure Subscription</mark> 中，儲存庫過去 <strong><code>90天</code></strong> 的紀錄中，同一個提交者(committer)在不同專案提交程式碼只會算 1 個數量，不會被重複計價。當我們在 git 儲存庫開啟 <strong><code>Advanced Security</code></strong> 功能時，Azure DevOps 在畫面上也會先幫我們基於上述原則計算有多少使用者會被計費，確定要使用再點選 <strong><code>Begin billing</code></strong> 即可：</p><img                         lazyload                       alt="image"                       data-src="/post/2025/04/azure-devops-individual-services/unique_committers.jpg"                        class=""                 ><p>如同 Azure 各種服務的計價方式，都是<strong>隨付即用 (pay-as-you-go)</strong>，啟用 <strong>GitHub Advanced Security for Azure DevOps</strong> 搭配 CI 流程可以讓我們在開發階段及早發現問題與漏洞，有效減少技術債和後期投入修改的人力成本，跟測試左移 (Shift-Left Testing) 的概念有點雷同，也可以省下大筆購入源碼檢測軟體的費用，大家可以參考看看。</p><div class="tips"><font color="black"><a class="link"   href="https://azure.microsoft.com/zh-tw/pricing/details/devops/azure-devops-services/"  target="_blank">⁍ Azure DevOps 定價<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://azure.microsoft.com/zh-tw/products/devops/github-advanced-security"  target="_blank">⁍ 適用於 Azure DevOps 的 GitHub Advanced Security<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://learn.microsoft.com/zh-tw/azure/devops/repos/security/configure-github-advanced-security-features?view=azure-devops&tabs=yaml"  target="_blank">⁍ 設定適用於 Azure DevOps 的 GitHub Advanced Security<i class="fas fa-external-link-alt"></i></a></font></div>]]></content>
    
    
    <summary type="html">&lt;img    
                       lazyload
                       alt=&quot;image&quot;
                       data-src=&quot;/post/2025/04/azure-devops-individual-services/individual_services.jpg&quot;
                         align=&quot;left&quot; style=&quot;margin-right: 10px; width: 125px; border: 1px solid gray;&quot;
                 &gt; 
&lt;p&gt;&lt;a href=&quot;/post/2024/09/azure-devops-licensing-description&quot;&gt;上一篇文章&lt;/a&gt;提到了 Azure DevOps 雲端和地端的使用者授權，當我們建立私有專案 (Private project) 且成員數量在 5 個人以下時，甚至可以直接免費使用，從第 6 個人起才需要計價，並具有 1 Free Microsoft-hosted CI/CD 和 1 Free Self-hosted CI/CD 以及 Azure Artifacts 2GB 可用儲存容量。在實務使用情境較複雜時，很有可能就需要再增加個別服務的用量 (例如：Azure Pipelines 平行作業數量)，這次就帶大家瞭解這些個別服務計價的方式。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Azure DevOps" scheme="https://timlai.dev/tags/Azure-DevOps/"/>
    
    <category term="授權" scheme="https://timlai.dev/tags/%E6%8E%88%E6%AC%8A/"/>
    
  </entry>
  
  <entry>
    <title>Azure DevOps Services / Server 使用者授權</title>
    <link href="https://timlai.dev/post/2025/04/azure-devops-licensing-description/"/>
    <id>https://timlai.dev/post/2025/04/azure-devops-licensing-description/</id>
    <published>2025-04-03T03:36:15.000Z</published>
    <updated>2025-05-28T06:09:20.807Z</updated>
    
    <content type="html"><![CDATA[<img                           lazyload                       alt="image"                       data-src="/post/2025/04/azure-devops-licensing-description/affliction512.jpg"                         align="left" style="margin-right: 10px; width: 125px; border: 1px solid gray;"                 > <p>Azure DevOps 是一個可以讓我們有效管理軟體開發流程，同時維持良好團隊協作的強大平台，除了可以直接使用雲端 Azure DevOps Services，也可以在地端自建 Azure DevOps Server 讓企業內部環境也能提供相同的服務，但許多人遇到的第一個問題是如何購買授權才能讓成本效益最大化？這篇文章主要協助大家瞭解 Azure DevOps 在授權與定價上的內容。</p><br><span id="more"></span><br><h2 id="Azure-DevOps-Services">Azure DevOps Services</h2><p>Azure DevOps 有五個主要功能：</p><ol><li><strong>Azure Boards</strong> (專案管理、看板管理、Scrum / Kanban、討論議題)</li><li><strong>Azure Repos</strong> (程式碼版控 TFVC/git)</li><li><strong>Azure Pipelines</strong> (自動化建置部署)</li><li><strong>Azure Artifacts</strong> (套件管理、自建套件來源)</li><li><strong>Azure Test Plans</strong> (建立與執行測試計劃)</li></ol><h3 id="Basic-Plan-與-Basic-Test-Plans">Basic Plan 與 Basic + Test Plans</h3><img                         lazyload                       alt="image"                       data-src="/post/2025/04/azure-devops-licensing-description/Basic_TestPlans.jpg"                        class=""                 ><p>在 Azure DevOps 定價頁面中的 <strong><code>Basic Plan</code></strong> 包含了前面四項功能，費用是 <strong>USD $6</strong> (每個人/月)，折合台幣就要看當月的匯率計算 (例如目前是 TWD <strong>$191</strong>)；一般來說，在專案團隊裡並不是每個成員都需要建立與管理測試計劃，所以 <strong>Azure Test Plans</strong> 這項功能額外被拆出來計價，若選擇 <strong><code>Basic + Test Plans</code></strong> 費用則是 <strong>USD $52</strong> (大約 TWD <strong>$1663</strong>)。</p><h3 id="Stakeholder">Stakeholder</h3><p>除了上述兩種存取層級(Access level)之外，還有一種是免費、可使用<mark>有限功能</mark>的 <strong><code>Stakeholder</code></strong>，比較簡單的來說，這個存取層級可以：</p><ul><li>建立 / 編輯 / 查詢工作項目</li><li>檢視 / 核准 pipeline</li><li>檢視測試計劃</li></ul><p>如同它的名稱一樣：想要瞭解專案資訊，但又不需要實際參與開發實作細節(例如：單位主管、使用單位…等)，就不用再額外採購授權，使用 <strong><code>Stakeholder</code></strong> 這個存取層級就行。若需要 <strong>程式碼版控</strong>、<strong>建立/編輯 pipeline</strong>、<strong>執行測試計劃</strong> 那就不用猶豫了，至少一定需要 <strong><code>Basic</code></strong> 存取層級才能使用，這些資訊可以參閱下列連結，利用頁面裡的幣別下拉選單、拖曳數量捲軸來即時檢視費用估算，頁面最後還有一個針對不同存取層級的功能比較表，方便大家查閱。</p><div class="tips"><font color="black"><a class="link"   href="https://azure.microsoft.com/zh-tw/pricing/details/devops/azure-devops-services/"  target="_blank">⁍ Azure DevOps 定價<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://learn.microsoft.com/zh-tw/azure/devops/organizations/security/stakeholder-access?view=azure-devops"  target="_blank">⁍ 項目關係人存取快速參考<i class="fas fa-external-link-alt"></i></a></font></div><h3 id="Visual-Studio-Subscription">Visual Studio Subscription</h3><p>若目前已經具備 <strong>Visual Studio monthly subscription</strong> (注意：<mark>訂閱制</mark>才行)，它也包含了 Azure DevOps 的使用授權，基本上可以理解為：<strong>Visual Studio Professional monthly subscription</strong> 包含了 <strong><code>Basic Plan</code></strong>，而 <strong>Visual Studio Enterprise monthly subscription</strong> 包含了 <strong><code>Basic + Test Plans</code></strong>，詳細功能支援列表可以參考下列連結。</p><div class="tips"><font color="black"><a class="link"   href="https://learn.microsoft.com/zh-tw/azure/devops/organizations/security/access-levels?view=azure-devops"  target="_blank">⁍ 關於存取層級<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://marketplace.visualstudio.com/items?itemName=ms.vs-professional-monthly"  target="_blank">⁍ Visual Studio Professional monthly subscription<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://marketplace.visualstudio.com/items?itemName=ms.vs-enterprise-monthly"  target="_blank">⁍ Visual Studio Enterprise monthly subscription<i class="fas fa-external-link-alt"></i></a></font></div><h2 id="Azure-DevOps-Server">Azure DevOps Server</h2><p>要在地端環境自建 Azure DevOps Server 則需要先準備好 SQL Server 環境，兩者在版本上有相依性，例如：Azure DevOps Server 2022 需要搭配 SQL Server 2019 以上 (不支援 Linux 上的 SQL Server)，其他版本與相關需求建議可以參考下列連結。</p><div class="tips"><font color="black"><a class="link"   href="https://learn.microsoft.com/zh-tw/azure/devops/server/requirements?view=azure-devops-2022"  target="_blank">⁍ Azure DevOps 內部部署的需求<i class="fas fa-external-link-alt"></i></a></font></div><p>以授權的概念來說，安裝幾台 Azure DevOps Server 就需要幾個 Server CAL，可以透過下列幾種方式取得合法授權：</p><ul><li>傳統購買 (<mark>3年SA</mark>) Azure DevOps <mark>Server</mark> CAL</li><li>Visual Studio Professional / Enterprise monthly subscription (包含 Azure DevOps Server CAL)</li></ul><br><p>地端的使用者授權可以由下列幾種方式取得合法授權：</p><ul><li>傳統購買 (<mark>3年SA</mark>) Azure DevOps User CAL (包含 <strong><code>Basic + Test Plans</code></strong> 所有功能)</li><li>Visual Studio Professional / Enterprise monthly subscription (包含 Azure DevOps <mark>User</mark> CAL)</li><li>Azure DevOps <strong><code>Basic</code></strong> 或 <strong><code>Basic + Test Plans</code></strong> (雲端的每人每月購買方式，也包含了地端的使用者授權)</li></ul><br><p>以上是對於 Azure DevOps Services / Server 授權的整理說明，若大家還有其他不瞭解的地方，歡迎透過下方留言討論。 😃</p>]]></content>
    
    
    <summary type="html">&lt;img    
                       lazyload
                       alt=&quot;image&quot;
                       data-src=&quot;/post/2025/04/azure-devops-licensing-description/affliction512.jpg&quot;
                         align=&quot;left&quot; style=&quot;margin-right: 10px; width: 125px; border: 1px solid gray;&quot;
                 &gt; 
&lt;p&gt;Azure DevOps 是一個可以讓我們有效管理軟體開發流程，同時維持良好團隊協作的強大平台，除了可以直接使用雲端 Azure DevOps Services，也可以在地端自建 Azure DevOps Server 讓企業內部環境也能提供相同的服務，但許多人遇到的第一個問題是如何購買授權才能讓成本效益最大化？這篇文章主要協助大家瞭解 Azure DevOps 在授權與定價上的內容。&lt;/p&gt;
&lt;br&gt;</summary>
    
    
    
    
    <category term="Azure DevOps" scheme="https://timlai.dev/tags/Azure-DevOps/"/>
    
    <category term="授權" scheme="https://timlai.dev/tags/%E6%8E%88%E6%AC%8A/"/>
    
  </entry>
  
</feed>
